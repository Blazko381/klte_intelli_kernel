From c0cd980ce6b4cfccda76b06bcf71254130b6d818 Mon Sep 17 00:00:00 2001
From: Samuel Pascua <pascua.samuel.14@gmail.com>
Date: Wed, 21 Aug 2019 15:02:37 +0800
Subject: [PATCH] asd

---
 fs/f2fs/segment.c                    | 2754 ------------
 fs/f2fs/segment.o_shipped            |  Bin 0 -> 47532 bytes
 4 files changed, 14580 deletions(-)
 delete mode 100644 fs/f2fs/segment.c
 create mode 100644 fs/f2fs/segment.o_shipped

diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.c
deleted file mode 100644
index 34a1c1394f1d..000000000000
--- a/fs/f2fs/segment.c
+++ /dev/null
@@ -1,2754 +0,0 @@
-/*
- * fs/f2fs/segment.c
- *
- * Copyright (c) 2012 Samsung Electronics Co., Ltd.
- *             http://www.samsung.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/fs.h>
-#include <linux/f2fs_fs.h>
-#include <linux/bio.h>
-#include <linux/blkdev.h>
-#include <linux/prefetch.h>
-#include <linux/kthread.h>
-#include <linux/swap.h>
-#include <linux/timer.h>
-
-#include "f2fs.h"
-#include "segment.h"
-#include "node.h"
-#include "trace.h"
-#include <trace/events/f2fs.h>
-
-#define __reverse_ffz(x) __reverse_ffs(~(x))
-
-static struct kmem_cache *discard_entry_slab;
-static struct kmem_cache *sit_entry_set_slab;
-static struct kmem_cache *inmem_entry_slab;
-
-static unsigned long __reverse_ulong(unsigned char *str)
-{
-	unsigned long tmp = 0;
-	int shift = 24, idx = 0;
-
-#if BITS_PER_LONG == 64
-	shift = 56;
-#endif
-	while (shift >= 0) {
-		tmp |= (unsigned long)str[idx++] << shift;
-		shift -= BITS_PER_BYTE;
-	}
-	return tmp;
-}
-
-/**
- * Copied from latest lib/llist.c
- * llist_for_each_entry_safe - iterate over some deleted entries of
- *                             lock-less list of given type
- *			       safe against removal of list entry
- * @pos:	the type * to use as a loop cursor.
- * @n:		another type * to use as temporary storage
- * @node:	the first entry of deleted list entries.
- * @member:	the name of the llist_node with the struct.
- *
- * In general, some entries of the lock-less list can be traversed
- * safely only after being removed from list, so start with an entry
- * instead of list head.
- *
- * If being used on entries deleted from lock-less list directly, the
- * traverse order is from the newest to the oldest added entry.  If
- * you want to traverse from the oldest to the newest, you must
- * reverse the order by yourself before traversing.
- */
-#define llist_for_each_entry_safe(pos, n, node, member)			       \
-	for (pos = llist_entry((node), typeof(*pos), member);		       \
-		&pos->member != NULL &&					       \
-		(n = llist_entry(pos->member.next, typeof(*n), member), true); \
-		pos = n)
-
-/**
- * Copied from latest lib/llist.c
- * llist_reverse_order - reverse order of a llist chain
- * @head:	first item of the list to be reversed
- *
- * Reverse the order of a chain of llist entries and return the
- * new first entry.
- */
-struct llist_node *llist_reverse_order(struct llist_node *head)
-{
-	struct llist_node *new_head = NULL;
-
-	while (head) {
-		struct llist_node *tmp = head;
-		head = head->next;
-		tmp->next = new_head;
-		new_head = tmp;
-	}
-
-	return new_head;
-}
-
-/**
- * Copied from latest linux/list.h
- * list_last_entry - get the last element from a list
- * @ptr:        the list head to take the element from.
- * @type:       the type of the struct this is embedded in.
- * @member:     the name of the list_struct within the struct.
- *
- * Note, that list is expected to be not empty.
- */
-#define list_last_entry(ptr, type, member) \
-	list_entry((ptr)->prev, type, member)
-
-/*
- * __reverse_ffs is copied from include/asm-generic/bitops/__ffs.h since
- * MSB and LSB are reversed in a byte by f2fs_set_bit.
- */
-static inline unsigned long __reverse_ffs(unsigned long word)
-{
-	int num = 0;
-
-#if BITS_PER_LONG == 64
-	if ((word & 0xffffffff00000000UL) == 0)
-		num += 32;
-	else
-		word >>= 32;
-#endif
-	if ((word & 0xffff0000) == 0)
-		num += 16;
-	else
-		word >>= 16;
-
-	if ((word & 0xff00) == 0)
-		num += 8;
-	else
-		word >>= 8;
-
-	if ((word & 0xf0) == 0)
-		num += 4;
-	else
-		word >>= 4;
-
-	if ((word & 0xc) == 0)
-		num += 2;
-	else
-		word >>= 2;
-
-	if ((word & 0x2) == 0)
-		num += 1;
-	return num;
-}
-
-/*
- * __find_rev_next(_zero)_bit is copied from lib/find_next_bit.c because
- * f2fs_set_bit makes MSB and LSB reversed in a byte.
- * @size must be integral times of unsigned long.
- * Example:
- *                             MSB <--> LSB
- *   f2fs_set_bit(0, bitmap) => 1000 0000
- *   f2fs_set_bit(7, bitmap) => 0000 0001
- */
-static unsigned long __find_rev_next_bit(const unsigned long *addr,
-			unsigned long size, unsigned long offset)
-{
-	const unsigned long *p = addr + BIT_WORD(offset);
-	unsigned long result = size;
-	unsigned long tmp;
-
-	if (offset >= size)
-		return size;
-
-	size -= (offset & ~(BITS_PER_LONG - 1));
-	offset %= BITS_PER_LONG;
-
-	while (1) {
-		if (*p == 0)
-			goto pass;
-
-		tmp = __reverse_ulong((unsigned char *)p);
-
-		tmp &= ~0UL >> offset;
-		if (size < BITS_PER_LONG)
-			tmp &= (~0UL << (BITS_PER_LONG - size));
-		if (tmp)
-			goto found;
-pass:
-		if (size <= BITS_PER_LONG)
-			break;
-		size -= BITS_PER_LONG;
-		offset = 0;
-		p++;
-	}
-	return result;
-found:
-	return result - size + __reverse_ffs(tmp);
-}
-
-static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,
-			unsigned long size, unsigned long offset)
-{
-	const unsigned long *p = addr + BIT_WORD(offset);
-	unsigned long result = size;
-	unsigned long tmp;
-
-	if (offset >= size)
-		return size;
-
-	size -= (offset & ~(BITS_PER_LONG - 1));
-	offset %= BITS_PER_LONG;
-
-	while (1) {
-		if (*p == ~0UL)
-			goto pass;
-
-		tmp = __reverse_ulong((unsigned char *)p);
-
-		if (offset)
-			tmp |= ~0UL << (BITS_PER_LONG - offset);
-		if (size < BITS_PER_LONG)
-			tmp |= ~0UL >> size;
-		if (tmp != ~0UL)
-			goto found;
-pass:
-		if (size <= BITS_PER_LONG)
-			break;
-		size -= BITS_PER_LONG;
-		offset = 0;
-		p++;
-	}
-	return result;
-found:
-	return result - size + __reverse_ffz(tmp);
-}
-
-void register_inmem_page(struct inode *inode, struct page *page)
-{
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct inmem_pages *new;
-
-	f2fs_trace_pid(page);
-
-	set_page_private(page, (unsigned long)ATOMIC_WRITTEN_PAGE);
-	SetPagePrivate(page);
-
-	new = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);
-
-	/* add atomic page indices to the list */
-	new->page = page;
-	INIT_LIST_HEAD(&new->list);
-
-	/* increase reference count with clean state */
-	mutex_lock(&fi->inmem_lock);
-	get_page(page);
-	list_add_tail(&new->list, &fi->inmem_pages);
-	inc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);
-	mutex_unlock(&fi->inmem_lock);
-
-	trace_f2fs_register_inmem_page(page, INMEM);
-}
-
-static int __revoke_inmem_pages(struct inode *inode,
-				struct list_head *head, bool drop, bool recover)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct inmem_pages *cur, *tmp;
-	int err = 0;
-
-	list_for_each_entry_safe(cur, tmp, head, list) {
-		struct page *page = cur->page;
-
-		if (drop)
-			trace_f2fs_commit_inmem_page(page, INMEM_DROP);
-
-		lock_page(page);
-
-		if (recover) {
-			struct dnode_of_data dn;
-			struct node_info ni;
-
-			trace_f2fs_commit_inmem_page(page, INMEM_REVOKE);
-
-			set_new_dnode(&dn, inode, NULL, NULL, 0);
-			if (get_dnode_of_data(&dn, page->index, LOOKUP_NODE)) {
-				err = -EAGAIN;
-				goto next;
-			}
-			get_node_info(sbi, dn.nid, &ni);
-			f2fs_replace_block(sbi, &dn, dn.data_blkaddr,
-					cur->old_addr, ni.version, true, true);
-			f2fs_put_dnode(&dn);
-		}
-next:
-		/* we don't need to invalidate this in the sccessful status */
-		if (drop || recover)
-			ClearPageUptodate(page);
-		set_page_private(page, 0);
-		ClearPagePrivate(page);
-		f2fs_put_page(page, 1);
-
-		list_del(&cur->list);
-		kmem_cache_free(inmem_entry_slab, cur);
-		dec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);
-	}
-	return err;
-}
-
-void drop_inmem_pages(struct inode *inode)
-{
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-
-	clear_inode_flag(inode, FI_ATOMIC_FILE);
-
-	mutex_lock(&fi->inmem_lock);
-	__revoke_inmem_pages(inode, &fi->inmem_pages, true, false);
-	mutex_unlock(&fi->inmem_lock);
-}
-
-static int __commit_inmem_pages(struct inode *inode,
-					struct list_head *revoke_list)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct inmem_pages *cur, *tmp;
-	struct f2fs_io_info fio = {
-		.sbi = sbi,
-		.type = DATA,
-		.rw = WRITE_SYNC | REQ_PRIO,
-		.encrypted_page = NULL,
-	};
-	bool submit_bio = false;
-	int err = 0;
-
-	list_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {
-		struct page *page = cur->page;
-
-		lock_page(page);
-		if (page->mapping == inode->i_mapping) {
-			trace_f2fs_commit_inmem_page(page, INMEM);
-
-			set_page_dirty(page);
-			f2fs_wait_on_page_writeback(page, DATA, true);
-			if (clear_page_dirty_for_io(page)) {
-				inode_dec_dirty_pages(inode);
-				remove_dirty_inode(inode);
-			}
-
-			fio.page = page;
-			err = do_write_data_page(&fio);
-			if (err) {
-				unlock_page(page);
-				break;
-			}
-
-			/* record old blkaddr for revoking */
-			cur->old_addr = fio.old_blkaddr;
-
-			submit_bio = true;
-		}
-		unlock_page(page);
-		list_move_tail(&cur->list, revoke_list);
-	}
-
-	if (submit_bio)
-		f2fs_submit_merged_bio_cond(sbi, inode, NULL, 0, DATA, WRITE);
-
-	if (!err)
-		__revoke_inmem_pages(inode, revoke_list, false, false);
-
-	return err;
-}
-
-int commit_inmem_pages(struct inode *inode)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct list_head revoke_list;
-	int err;
-
-	INIT_LIST_HEAD(&revoke_list);
-	f2fs_balance_fs(sbi, true);
-	f2fs_lock_op(sbi);
-
-	mutex_lock(&fi->inmem_lock);
-	err = __commit_inmem_pages(inode, &revoke_list);
-	if (err) {
-		int ret;
-		/*
-		 * try to revoke all committed pages, but still we could fail
-		 * due to no memory or other reason, if that happened, EAGAIN
-		 * will be returned, which means in such case, transaction is
-		 * already not integrity, caller should use journal to do the
-		 * recovery or rewrite & commit last transaction. For other
-		 * error number, revoking was done by filesystem itself.
-		 */
-		ret = __revoke_inmem_pages(inode, &revoke_list, false, true);
-		if (ret)
-			err = ret;
-
-		/* drop all uncommitted pages */
-		__revoke_inmem_pages(inode, &fi->inmem_pages, true, false);
-	}
-	mutex_unlock(&fi->inmem_lock);
-
-	f2fs_unlock_op(sbi);
-	return err;
-}
-
-/*
- * This function balances dirty node and dentry pages.
- * In addition, it controls garbage collection.
- */
-void f2fs_balance_fs(struct f2fs_sb_info *sbi, bool need)
-{
-#ifdef CONFIG_F2FS_FAULT_INJECTION
-	if (time_to_inject(sbi, FAULT_CHECKPOINT))
-		f2fs_stop_checkpoint(sbi, false);
-#endif
-
-	if (!need)
-		return;
-
-	/* balance_fs_bg is able to be pending */
-	if (excess_cached_nats(sbi))
-		f2fs_balance_fs_bg(sbi);
-
-	/*
-	 * We should do GC or end up with checkpoint, if there are so many dirty
-	 * dir/node pages without enough free segments.
-	 */
-	if (has_not_enough_free_secs(sbi, 0, 0)) {
-		mutex_lock(&sbi->gc_mutex);
-		f2fs_gc(sbi, false, false);
-	}
-}
-
-void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)
-{
-	/* try to shrink extent cache when there is no enough memory */
-	if (!available_free_memory(sbi, EXTENT_CACHE))
-		f2fs_shrink_extent_tree(sbi, EXTENT_CACHE_SHRINK_NUMBER);
-
-	/* check the # of cached NAT entries */
-	if (!available_free_memory(sbi, NAT_ENTRIES))
-		try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK);
-
-	if (!available_free_memory(sbi, FREE_NIDS))
-		try_to_free_nids(sbi, MAX_FREE_NIDS);
-	else
-		build_free_nids(sbi, false);
-
-	if (!is_idle(sbi))
-		return;
-
-	/* checkpoint is the only way to shrink partial cached entries */
-	if (!available_free_memory(sbi, NAT_ENTRIES) ||
-			!available_free_memory(sbi, INO_ENTRIES) ||
-			excess_prefree_segs(sbi) ||
-			excess_dirty_nats(sbi) ||
-			f2fs_time_over(sbi, CP_TIME)) {
-		if (test_opt(sbi, DATA_FLUSH)) {
-			struct blk_plug plug;
-
-			blk_start_plug(&plug);
-			sync_dirty_inodes(sbi, FILE_INODE);
-			blk_finish_plug(&plug);
-		}
-		f2fs_sync_fs(sbi->sb, true);
-		stat_inc_bg_cp_count(sbi->stat_info);
-	}
-}
-
-struct __submit_bio_ret {
-	struct completion event;
-	int error;
-};
-
-static void __submit_bio_wait_endio(struct bio *bio, int error)
-{
-	struct __submit_bio_ret *ret = bio->bi_private;
-
-	ret->error = error;
-	complete(&ret->event);
-}
-
-static int __submit_bio_wait(int rw, struct bio *bio)
-{
-	struct __submit_bio_ret ret;
-
-	rw |= REQ_SYNC;
-	init_completion(&ret.event);
-	bio->bi_private = &ret;
-	bio->bi_end_io = __submit_bio_wait_endio;
-	submit_bio(rw, bio);
-	wait_for_completion(&ret.event);
-
-	return ret.error;
-}
-
-static int issue_flush_thread(void *data)
-{
-	struct f2fs_sb_info *sbi = data;
-	struct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;
-	wait_queue_head_t *q = &fcc->flush_wait_queue;
-repeat:
-	if (kthread_should_stop())
-		return 0;
-
-	if (!llist_empty(&fcc->issue_list)) {
-		struct bio *bio;
-		struct flush_cmd *cmd, *next;
-		int ret;
-
-		bio = f2fs_bio_alloc(0);
-
-		fcc->dispatch_list = llist_del_all(&fcc->issue_list);
-		fcc->dispatch_list = llist_reverse_order(fcc->dispatch_list);
-
-		bio->bi_bdev = sbi->sb->s_bdev;
-		ret = __submit_bio_wait(WRITE_FLUSH, bio);
-
-		llist_for_each_entry_safe(cmd, next,
-					  fcc->dispatch_list, llnode) {
-			cmd->ret = ret;
-			complete(&cmd->wait);
-		}
-		bio_put(bio);
-		fcc->dispatch_list = NULL;
-	}
-
-	wait_event_interruptible(*q,
-		kthread_should_stop() || !llist_empty(&fcc->issue_list));
-	goto repeat;
-}
-
-int f2fs_issue_flush(struct f2fs_sb_info *sbi)
-{
-	struct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;
-	struct flush_cmd cmd;
-
-	trace_f2fs_issue_flush(sbi->sb, test_opt(sbi, NOBARRIER),
-					test_opt(sbi, FLUSH_MERGE));
-
-	if (test_opt(sbi, NOBARRIER))
-		return 0;
-
-	if (!test_opt(sbi, FLUSH_MERGE) || !atomic_read(&fcc->submit_flush)) {
-		struct bio *bio = f2fs_bio_alloc(0);
-		int ret;
-
-		atomic_inc(&fcc->submit_flush);
-		bio->bi_bdev = sbi->sb->s_bdev;
-		ret = __submit_bio_wait(WRITE_FLUSH, bio);
-		atomic_dec(&fcc->submit_flush);
-		bio_put(bio);
-		return ret;
-	}
-
-	init_completion(&cmd.wait);
-
-	atomic_inc(&fcc->submit_flush);
-	llist_add(&cmd.llnode, &fcc->issue_list);
-
-	if (!fcc->dispatch_list)
-		wake_up(&fcc->flush_wait_queue);
-
-	if (fcc->f2fs_issue_flush) {
-		wait_for_completion(&cmd.wait);
-		atomic_dec(&fcc->submit_flush);
-	} else {
-		llist_del_all(&fcc->issue_list);
-		atomic_set(&fcc->submit_flush, 0);
-	}
-
-	return cmd.ret;
-}
-
-int create_flush_cmd_control(struct f2fs_sb_info *sbi)
-{
-	dev_t dev = sbi->sb->s_bdev->bd_dev;
-	struct flush_cmd_control *fcc;
-	int err = 0;
-
-	if (SM_I(sbi)->cmd_control_info) {
-		fcc = SM_I(sbi)->cmd_control_info;
-		goto init_thread;
-	}
-
-	fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);
-	if (!fcc)
-		return -ENOMEM;
-	atomic_set(&fcc->submit_flush, 0);
-	init_waitqueue_head(&fcc->flush_wait_queue);
-	init_llist_head(&fcc->issue_list);
-	SM_I(sbi)->cmd_control_info = fcc;
-	if (!test_opt(sbi, FLUSH_MERGE))
-		return err;
-
-init_thread:
-	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
-				"f2fs_flush-%u:%u", MAJOR(dev), MINOR(dev));
-	if (IS_ERR(fcc->f2fs_issue_flush)) {
-		err = PTR_ERR(fcc->f2fs_issue_flush);
-		kfree(fcc);
-		SM_I(sbi)->cmd_control_info = NULL;
-		return err;
-	}
-
-	return err;
-}
-
-void destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free)
-{
-	struct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;
-
-	if (fcc && fcc->f2fs_issue_flush) {
-		struct task_struct *flush_thread = fcc->f2fs_issue_flush;
-
-		fcc->f2fs_issue_flush = NULL;
-		kthread_stop(flush_thread);
-	}
-	if (free) {
-		kfree(fcc);
-		SM_I(sbi)->cmd_control_info = NULL;
-	}
-}
-
-static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	/* need not be added */
-	if (IS_CURSEG(sbi, segno))
-		return;
-
-	if (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))
-		dirty_i->nr_dirty[dirty_type]++;
-
-	if (dirty_type == DIRTY) {
-		struct seg_entry *sentry = get_seg_entry(sbi, segno);
-		enum dirty_type t = sentry->type;
-
-		if (unlikely(t >= DIRTY)) {
-			f2fs_bug_on(sbi, 1);
-			return;
-		}
-		if (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))
-			dirty_i->nr_dirty[t]++;
-	}
-}
-
-static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	if (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))
-		dirty_i->nr_dirty[dirty_type]--;
-
-	if (dirty_type == DIRTY) {
-		struct seg_entry *sentry = get_seg_entry(sbi, segno);
-		enum dirty_type t = sentry->type;
-
-		if (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))
-			dirty_i->nr_dirty[t]--;
-
-		if (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)
-			clear_bit(GET_SECNO(sbi, segno),
-						dirty_i->victim_secmap);
-	}
-}
-
-/*
- * Should not occur error such as -ENOMEM.
- * Adding dirty entry into seglist is not critical operation.
- * If a given segment is one of current working segments, it won't be added.
- */
-static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned short valid_blocks;
-
-	if (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))
-		return;
-
-	mutex_lock(&dirty_i->seglist_lock);
-
-	valid_blocks = get_valid_blocks(sbi, segno, 0);
-
-	if (valid_blocks == 0) {
-		__locate_dirty_segment(sbi, segno, PRE);
-		__remove_dirty_segment(sbi, segno, DIRTY);
-	} else if (valid_blocks < sbi->blocks_per_seg) {
-		__locate_dirty_segment(sbi, segno, DIRTY);
-	} else {
-		/* Recovery routine with SSR needs this */
-		__remove_dirty_segment(sbi, segno, DIRTY);
-	}
-
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-#ifdef CONFIG_BLK_DEV_ZONED
-static int f2fs_issue_discard_zone(struct f2fs_sb_info *sbi,
-					block_t blkstart, block_t blklen)
-{
-	sector_t sector = SECTOR_FROM_BLOCK(blkstart);
-	sector_t nr_sects = SECTOR_FROM_BLOCK(blklen);
-	struct block_device *bdev = sbi->sb->s_bdev;
-
-	if (sector & (bdev_zone_size(bdev) - 1) ||
-				nr_sects != bdev_zone_size(bdev)) {
-		f2fs_msg(sbi->sb, KERN_INFO,
-			 "Unaligned discard attempted (sector %llu + %llu)",
-			 (unsigned long long)sector,
-			 (unsigned long long)nr_sects);
-		return -EIO;
-	}
-
-	/*
-	 * We need to know the type of the zone: for conventional zones,
-	 * use regular discard if the drive supports it. For sequential
-	 * zones, reset the zone write pointer.
-	 */
-	switch (get_blkz_type(sbi, blkstart)) {
-
-	case BLK_ZONE_TYPE_CONVENTIONAL:
-		if (!blk_queue_discard(bdev_get_queue(bdev)))
-			return 0;
-		return blkdev_issue_discard(bdev, sector, nr_sects,
-						GFP_NOFS, 0);
-	case BLK_ZONE_TYPE_SEQWRITE_REQ:
-	case BLK_ZONE_TYPE_SEQWRITE_PREF:
-		trace_f2fs_issue_reset_zone(sbi->sb, blkstart);
-		return blkdev_reset_zones(bdev, sector,
-					  nr_sects, GFP_NOFS);
-	default:
-		/* Unknown zone type: broken device ? */
-		return -EIO;
-	}
-}
-#endif
-
-static int f2fs_issue_discard(struct f2fs_sb_info *sbi,
-				block_t blkstart, block_t blklen)
-{
-	sector_t start = SECTOR_FROM_BLOCK(blkstart);
-	sector_t len = SECTOR_FROM_BLOCK(blklen);
-	struct seg_entry *se;
-	unsigned int offset;
-	block_t i;
-
-	for (i = blkstart; i < blkstart + blklen; i++) {
-		se = get_seg_entry(sbi, GET_SEGNO(sbi, i));
-		offset = GET_BLKOFF_FROM_SEG0(sbi, i);
-
-		if (!f2fs_test_and_set_bit(offset, se->discard_map))
-			sbi->discard_blks--;
-	}
-	trace_f2fs_issue_discard(sbi->sb, blkstart, blklen);
-
-#ifdef CONFIG_BLK_DEV_ZONED
-	if (f2fs_sb_mounted_blkzoned(sbi->sb))
-		return f2fs_issue_discard_zone(sbi, blkstart, blklen);
-#endif
-	return blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);
-}
-
-static void __add_discard_entry(struct f2fs_sb_info *sbi,
-		struct cp_control *cpc, struct seg_entry *se,
-		unsigned int start, unsigned int end)
-{
-	struct list_head *head = &SM_I(sbi)->discard_list;
-	struct discard_entry *new, *last;
-
-	if (!list_empty(head)) {
-		last = list_last_entry(head, struct discard_entry, list);
-		if (START_BLOCK(sbi, cpc->trim_start) + start ==
-						last->blkaddr + last->len) {
-			last->len += end - start;
-			goto done;
-		}
-	}
-
-	new = f2fs_kmem_cache_alloc(discard_entry_slab, GFP_NOFS);
-	INIT_LIST_HEAD(&new->list);
-	new->blkaddr = START_BLOCK(sbi, cpc->trim_start) + start;
-	new->len = end - start;
-	list_add_tail(&new->list, head);
-done:
-	SM_I(sbi)->nr_discards += end - start;
-}
-
-static void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	int entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);
-	int max_blocks = sbi->blocks_per_seg;
-	struct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);
-	unsigned long *cur_map = (unsigned long *)se->cur_valid_map;
-	unsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;
-	unsigned long *discard_map = (unsigned long *)se->discard_map;
-	unsigned long *dmap = SIT_I(sbi)->tmp_map;
-	unsigned int start = 0, end = -1;
-	bool force = (cpc->reason == CP_DISCARD);
-	int i;
-
-	if (se->valid_blocks == max_blocks || !f2fs_discard_en(sbi))
-		return;
-
-	if (!force) {
-		if (!test_opt(sbi, DISCARD) || !se->valid_blocks ||
-		    SM_I(sbi)->nr_discards >= SM_I(sbi)->max_discards)
-			return;
-	}
-
-	/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */
-	for (i = 0; i < entries; i++)
-		dmap[i] = force ? ~ckpt_map[i] & ~discard_map[i] :
-				(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];
-
-	while (force || SM_I(sbi)->nr_discards <= SM_I(sbi)->max_discards) {
-		start = __find_rev_next_bit(dmap, max_blocks, end + 1);
-		if (start >= max_blocks)
-			break;
-
-		end = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);
-		if (force && start && end != max_blocks
-					&& (end - start) < cpc->trim_minlen)
-			continue;
-
-		__add_discard_entry(sbi, cpc, se, start, end);
-	}
-}
-
-void release_discard_addrs(struct f2fs_sb_info *sbi)
-{
-	struct list_head *head = &(SM_I(sbi)->discard_list);
-	struct discard_entry *entry, *this;
-
-	/* drop caches */
-	list_for_each_entry_safe(entry, this, head, list) {
-		list_del(&entry->list);
-		kmem_cache_free(discard_entry_slab, entry);
-	}
-}
-
-/*
- * Should call clear_prefree_segments after checkpoint is done.
- */
-static void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned int segno;
-
-	mutex_lock(&dirty_i->seglist_lock);
-	for_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))
-		__set_test_and_free(sbi, segno);
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	struct list_head *head = &(SM_I(sbi)->discard_list);
-	struct discard_entry *entry, *this;
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned long *prefree_map = dirty_i->dirty_segmap[PRE];
-	unsigned int start = 0, end = -1;
-	unsigned int secno, start_segno;
-	bool force = (cpc->reason == CP_DISCARD);
-
-	mutex_lock(&dirty_i->seglist_lock);
-
-	while (1) {
-		int i;
-		start = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);
-		if (start >= MAIN_SEGS(sbi))
-			break;
-		end = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),
-								start + 1);
-
-		for (i = start; i < end; i++)
-			clear_bit(i, prefree_map);
-
-		dirty_i->nr_dirty[PRE] -= end - start;
-
-		if (force || !test_opt(sbi, DISCARD))
-			continue;
-
-		if (!test_opt(sbi, LFS) || sbi->segs_per_sec == 1) {
-			f2fs_issue_discard(sbi, START_BLOCK(sbi, start),
-				(end - start) << sbi->log_blocks_per_seg);
-			continue;
-		}
-next:
-		secno = GET_SECNO(sbi, start);
-		start_segno = secno * sbi->segs_per_sec;
-		if (!IS_CURSEC(sbi, secno) &&
-			!get_valid_blocks(sbi, start, sbi->segs_per_sec))
-			f2fs_issue_discard(sbi, START_BLOCK(sbi, start_segno),
-				sbi->segs_per_sec << sbi->log_blocks_per_seg);
-
-		start = start_segno + sbi->segs_per_sec;
-		if (start < end)
-			goto next;
-	}
-	mutex_unlock(&dirty_i->seglist_lock);
-
-	/* send small discards */
-	list_for_each_entry_safe(entry, this, head, list) {
-		if (force && entry->len < cpc->trim_minlen)
-			goto skip;
-		f2fs_issue_discard(sbi, entry->blkaddr, entry->len);
-		cpc->trimmed += entry->len;
-skip:
-		list_del(&entry->list);
-		SM_I(sbi)->nr_discards -= entry->len;
-		kmem_cache_free(discard_entry_slab, entry);
-	}
-}
-
-static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-
-	if (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {
-		sit_i->dirty_sentries++;
-		return false;
-	}
-
-	return true;
-}
-
-static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,
-					unsigned int segno, int modified)
-{
-	struct seg_entry *se = get_seg_entry(sbi, segno);
-	se->type = type;
-	if (modified)
-		__mark_sit_entry_dirty(sbi, segno);
-}
-
-static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)
-{
-	struct seg_entry *se;
-	unsigned int segno, offset;
-	long int new_vblocks;
-
-	segno = GET_SEGNO(sbi, blkaddr);
-
-	se = get_seg_entry(sbi, segno);
-	new_vblocks = se->valid_blocks + del;
-	offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);
-
-	f2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||
-				(new_vblocks > sbi->blocks_per_seg)));
-
-	se->valid_blocks = new_vblocks;
-	se->mtime = get_mtime(sbi);
-	SIT_I(sbi)->max_mtime = se->mtime;
-
-	/* Update valid block bitmap */
-	if (del > 0) {
-		if (f2fs_test_and_set_bit(offset, se->cur_valid_map))
-			f2fs_bug_on(sbi, 1);
-		if (f2fs_discard_en(sbi) &&
-			!f2fs_test_and_set_bit(offset, se->discard_map))
-			sbi->discard_blks--;
-	} else {
-		if (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))
-			f2fs_bug_on(sbi, 1);
-		if (f2fs_discard_en(sbi) &&
-			f2fs_test_and_clear_bit(offset, se->discard_map))
-			sbi->discard_blks++;
-	}
-	if (!f2fs_test_bit(offset, se->ckpt_valid_map))
-		se->ckpt_valid_blocks += del;
-
-	__mark_sit_entry_dirty(sbi, segno);
-
-	/* update total number of valid blocks to be written in ckpt area */
-	SIT_I(sbi)->written_valid_blocks += del;
-
-	if (sbi->segs_per_sec > 1)
-		get_sec_entry(sbi, segno)->valid_blocks += del;
-}
-
-void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)
-{
-	update_sit_entry(sbi, new, 1);
-	if (GET_SEGNO(sbi, old) != NULL_SEGNO)
-		update_sit_entry(sbi, old, -1);
-
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, old));
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, new));
-}
-
-void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)
-{
-	unsigned int segno = GET_SEGNO(sbi, addr);
-	struct sit_info *sit_i = SIT_I(sbi);
-
-	f2fs_bug_on(sbi, addr == NULL_ADDR);
-	if (addr == NEW_ADDR)
-		return;
-
-	/* add it into sit main buffer */
-	mutex_lock(&sit_i->sentry_lock);
-
-	update_sit_entry(sbi, addr, -1);
-
-	/* add it into dirty seglist */
-	locate_dirty_segment(sbi, segno);
-
-	mutex_unlock(&sit_i->sentry_lock);
-}
-
-bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int segno, offset;
-	struct seg_entry *se;
-	bool is_cp = false;
-
-	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
-		return true;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	segno = GET_SEGNO(sbi, blkaddr);
-	se = get_seg_entry(sbi, segno);
-	offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);
-
-	if (f2fs_test_bit(offset, se->ckpt_valid_map))
-		is_cp = true;
-
-	mutex_unlock(&sit_i->sentry_lock);
-
-	return is_cp;
-}
-
-/*
- * This function should be resided under the curseg_mutex lock
- */
-static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,
-					struct f2fs_summary *sum)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	void *addr = curseg->sum_blk;
-	addr += curseg->next_blkoff * sizeof(struct f2fs_summary);
-	memcpy(addr, sum, sizeof(struct f2fs_summary));
-}
-
-/*
- * Calculate the number of current summary pages for writing
- */
-int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)
-{
-	int valid_sum_count = 0;
-	int i, sum_in_page;
-
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		if (sbi->ckpt->alloc_type[i] == SSR)
-			valid_sum_count += sbi->blocks_per_seg;
-		else {
-			if (for_ra)
-				valid_sum_count += le16_to_cpu(
-					F2FS_CKPT(sbi)->cur_data_blkoff[i]);
-			else
-				valid_sum_count += curseg_blkoff(sbi, i);
-		}
-	}
-
-	sum_in_page = (PAGE_SIZE - 2 * SUM_JOURNAL_SIZE -
-			SUM_FOOTER_SIZE) / SUMMARY_SIZE;
-	if (valid_sum_count <= sum_in_page)
-		return 1;
-	else if ((valid_sum_count - sum_in_page) <=
-		(PAGE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)
-		return 2;
-	return 3;
-}
-
-/*
- * Caller should put this summary page
- */
-struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	return get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));
-}
-
-void update_meta_page(struct f2fs_sb_info *sbi, void *src, block_t blk_addr)
-{
-	struct page *page = grab_meta_page(sbi, blk_addr);
-	void *dst = page_address(page);
-
-	if (src)
-		memcpy(dst, src, PAGE_SIZE);
-	else
-		memset(dst, 0, PAGE_SIZE);
-	set_page_dirty(page);
-	f2fs_put_page(page, 1);
-}
-
-static void write_sum_page(struct f2fs_sb_info *sbi,
-			struct f2fs_summary_block *sum_blk, block_t blk_addr)
-{
-	update_meta_page(sbi, (void *)sum_blk, blk_addr);
-}
-
-static void write_current_sum_page(struct f2fs_sb_info *sbi,
-						int type, block_t blk_addr)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	struct page *page = grab_meta_page(sbi, blk_addr);
-	struct f2fs_summary_block *src = curseg->sum_blk;
-	struct f2fs_summary_block *dst;
-
-	dst = (struct f2fs_summary_block *)page_address(page);
-
-	mutex_lock(&curseg->curseg_mutex);
-
-	down_read(&curseg->journal_rwsem);
-	memcpy(&dst->journal, curseg->journal, SUM_JOURNAL_SIZE);
-	up_read(&curseg->journal_rwsem);
-
-	memcpy(dst->entries, src->entries, SUM_ENTRY_SIZE);
-	memcpy(&dst->footer, &src->footer, SUM_FOOTER_SIZE);
-
-	mutex_unlock(&curseg->curseg_mutex);
-
-	set_page_dirty(page);
-	f2fs_put_page(page, 1);
-}
-
-static int is_next_segment_free(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int segno = curseg->segno + 1;
-	struct free_segmap_info *free_i = FREE_I(sbi);
-
-	if (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)
-		return !test_bit(segno, free_i->free_segmap);
-	return 0;
-}
-
-/*
- * Find a new segment from the free segments bitmap to right order
- * This function should be returned with success, otherwise BUG
- */
-static void get_new_segment(struct f2fs_sb_info *sbi,
-			unsigned int *newseg, bool new_sec, int dir)
-{
-	struct free_segmap_info *free_i = FREE_I(sbi);
-	unsigned int segno, secno, zoneno;
-	unsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;
-	unsigned int hint = *newseg / sbi->segs_per_sec;
-	unsigned int old_zoneno = GET_ZONENO_FROM_SEGNO(sbi, *newseg);
-	unsigned int left_start = hint;
-	bool init = true;
-	int go_left = 0;
-	int i;
-
-	spin_lock(&free_i->segmap_lock);
-
-	if (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {
-		segno = find_next_zero_bit(free_i->free_segmap,
-				(hint + 1) * sbi->segs_per_sec, *newseg + 1);
-		if (segno < (hint + 1) * sbi->segs_per_sec)
-			goto got_it;
-	}
-find_other_zone:
-	secno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);
-	if (secno >= MAIN_SECS(sbi)) {
-		if (dir == ALLOC_RIGHT) {
-			secno = find_next_zero_bit(free_i->free_secmap,
-							MAIN_SECS(sbi), 0);
-			f2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));
-		} else {
-			go_left = 1;
-			left_start = hint - 1;
-		}
-	}
-	if (go_left == 0)
-		goto skip_left;
-
-	while (test_bit(left_start, free_i->free_secmap)) {
-		if (left_start > 0) {
-			left_start--;
-			continue;
-		}
-		left_start = find_next_zero_bit(free_i->free_secmap,
-							MAIN_SECS(sbi), 0);
-		f2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));
-		break;
-	}
-	secno = left_start;
-skip_left:
-	hint = secno;
-	segno = secno * sbi->segs_per_sec;
-	zoneno = secno / sbi->secs_per_zone;
-
-	/* give up on finding another zone */
-	if (!init)
-		goto got_it;
-	if (sbi->secs_per_zone == 1)
-		goto got_it;
-	if (zoneno == old_zoneno)
-		goto got_it;
-	if (dir == ALLOC_LEFT) {
-		if (!go_left && zoneno + 1 >= total_zones)
-			goto got_it;
-		if (go_left && zoneno == 0)
-			goto got_it;
-	}
-	for (i = 0; i < NR_CURSEG_TYPE; i++)
-		if (CURSEG_I(sbi, i)->zone == zoneno)
-			break;
-
-	if (i < NR_CURSEG_TYPE) {
-		/* zone is in user, try another */
-		if (go_left)
-			hint = zoneno * sbi->secs_per_zone - 1;
-		else if (zoneno + 1 >= total_zones)
-			hint = 0;
-		else
-			hint = (zoneno + 1) * sbi->secs_per_zone;
-		init = false;
-		goto find_other_zone;
-	}
-got_it:
-	/* set it as dirty segment in free segmap */
-	f2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));
-	__set_inuse(sbi, segno);
-	*newseg = segno;
-	spin_unlock(&free_i->segmap_lock);
-}
-
-static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	struct summary_footer *sum_footer;
-
-	curseg->segno = curseg->next_segno;
-	curseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);
-	curseg->next_blkoff = 0;
-	curseg->next_segno = NULL_SEGNO;
-
-	sum_footer = &(curseg->sum_blk->footer);
-	memset(sum_footer, 0, sizeof(struct summary_footer));
-	if (IS_DATASEG(type))
-		SET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);
-	if (IS_NODESEG(type))
-		SET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);
-	__set_sit_entry_type(sbi, type, curseg->segno, modified);
-}
-
-/*
- * Allocate a current working segment.
- * This function always allocates a free segment in LFS manner.
- */
-static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int segno = curseg->segno;
-	int dir = ALLOC_LEFT;
-
-	write_sum_page(sbi, curseg->sum_blk,
-				GET_SUM_BLOCK(sbi, segno));
-	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
-		dir = ALLOC_RIGHT;
-
-	if (test_opt(sbi, NOHEAP))
-		dir = ALLOC_RIGHT;
-
-	get_new_segment(sbi, &segno, new_sec, dir);
-	curseg->next_segno = segno;
-	reset_curseg(sbi, type, 1);
-	curseg->alloc_type = LFS;
-}
-
-static void __next_free_blkoff(struct f2fs_sb_info *sbi,
-			struct curseg_info *seg, block_t start)
-{
-	struct seg_entry *se = get_seg_entry(sbi, seg->segno);
-	int entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);
-	unsigned long *target_map = SIT_I(sbi)->tmp_map;
-	unsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;
-	unsigned long *cur_map = (unsigned long *)se->cur_valid_map;
-	int i, pos;
-
-	for (i = 0; i < entries; i++)
-		target_map[i] = ckpt_map[i] | cur_map[i];
-
-	pos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);
-
-	seg->next_blkoff = pos;
-}
-
-/*
- * If a segment is written by LFS manner, next block offset is just obtained
- * by increasing the current block offset. However, if a segment is written by
- * SSR manner, next block offset obtained by calling __next_free_blkoff
- */
-static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,
-				struct curseg_info *seg)
-{
-	if (seg->alloc_type == SSR)
-		__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);
-	else
-		seg->next_blkoff++;
-}
-
-/*
- * This function always allocates a used segment(from dirty seglist) by SSR
- * manner, so it should recover the existing segment information of valid blocks
- */
-static void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int new_segno = curseg->next_segno;
-	struct f2fs_summary_block *sum_node;
-	struct page *sum_page;
-
-	write_sum_page(sbi, curseg->sum_blk,
-				GET_SUM_BLOCK(sbi, curseg->segno));
-	__set_test_and_inuse(sbi, new_segno);
-
-	mutex_lock(&dirty_i->seglist_lock);
-	__remove_dirty_segment(sbi, new_segno, PRE);
-	__remove_dirty_segment(sbi, new_segno, DIRTY);
-	mutex_unlock(&dirty_i->seglist_lock);
-
-	reset_curseg(sbi, type, 1);
-	curseg->alloc_type = SSR;
-	__next_free_blkoff(sbi, curseg, 0);
-
-	if (reuse) {
-		sum_page = get_sum_page(sbi, new_segno);
-		sum_node = (struct f2fs_summary_block *)page_address(sum_page);
-		memcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);
-		f2fs_put_page(sum_page, 1);
-	}
-}
-
-static int get_ssr_segment(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	const struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;
-
-	if (IS_NODESEG(type) || !has_not_enough_free_secs(sbi, 0, 0))
-		return v_ops->get_victim(sbi,
-				&(curseg)->next_segno, BG_GC, type, SSR);
-
-	/* For data segments, let's do SSR more intensively */
-	for (; type >= CURSEG_HOT_DATA; type--)
-		if (v_ops->get_victim(sbi, &(curseg)->next_segno,
-						BG_GC, type, SSR))
-			return 1;
-	return 0;
-}
-
-/*
- * flush out current segment and replace it with new segment
- * This function should be returned with success, otherwise BUG
- */
-static void allocate_segment_by_default(struct f2fs_sb_info *sbi,
-						int type, bool force)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-
-	if (force)
-		new_curseg(sbi, type, true);
-	else if (type == CURSEG_WARM_NODE)
-		new_curseg(sbi, type, false);
-	else if (curseg->alloc_type == LFS && is_next_segment_free(sbi, type))
-		new_curseg(sbi, type, false);
-	else if (need_SSR(sbi) && get_ssr_segment(sbi, type))
-		change_curseg(sbi, type, true);
-	else
-		new_curseg(sbi, type, false);
-
-	stat_inc_seg_type(sbi, curseg);
-}
-
-void allocate_new_segments(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *curseg;
-	unsigned int old_segno;
-	int i;
-
-	if (test_opt(sbi, LFS))
-		return;
-
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		curseg = CURSEG_I(sbi, i);
-		old_segno = curseg->segno;
-		SIT_I(sbi)->s_ops->allocate_segment(sbi, i, true);
-		locate_dirty_segment(sbi, old_segno);
-	}
-}
-
-static const struct segment_allocation default_salloc_ops = {
-	.allocate_segment = allocate_segment_by_default,
-};
-
-int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)
-{
-	__u64 start = F2FS_BYTES_TO_BLK(range->start);
-	__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;
-	unsigned int start_segno, end_segno;
-	struct cp_control cpc;
-	int err = 0;
-
-	if (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)
-		return -EINVAL;
-
-	cpc.trimmed = 0;
-	if (end <= MAIN_BLKADDR(sbi))
-		goto out;
-
-	if (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {
-		f2fs_msg(sbi->sb, KERN_WARNING,
-			"Found FS corruption, run fsck to fix.");
-		goto out;
-	}
-
-	/* start/end segment number in main_area */
-	start_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);
-	end_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :
-						GET_SEGNO(sbi, end);
-	cpc.reason = CP_DISCARD;
-	cpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));
-
-	/* do checkpoint to issue discard commands safely */
-	for (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {
-		cpc.trim_start = start_segno;
-
-		if (sbi->discard_blks == 0)
-			break;
-		else if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))
-			cpc.trim_end = end_segno;
-		else
-			cpc.trim_end = min_t(unsigned int,
-				rounddown(start_segno +
-				BATCHED_TRIM_SEGMENTS(sbi),
-				sbi->segs_per_sec) - 1, end_segno);
-
-		mutex_lock(&sbi->gc_mutex);
-		err = write_checkpoint(sbi, &cpc);
-		mutex_unlock(&sbi->gc_mutex);
-		if (err)
-			break;
-
-		schedule();
-	}
-out:
-	range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);
-	return err;
-}
-
-static bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	if (curseg->next_blkoff < sbi->blocks_per_seg)
-		return true;
-	return false;
-}
-
-static int __get_segment_type_2(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA)
-		return CURSEG_HOT_DATA;
-	else
-		return CURSEG_HOT_NODE;
-}
-
-static int __get_segment_type_4(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA) {
-		struct inode *inode = page->mapping->host;
-
-		if (S_ISDIR(inode->i_mode))
-			return CURSEG_HOT_DATA;
-		else
-			return CURSEG_COLD_DATA;
-	} else {
-		if (IS_DNODE(page) && is_cold_node(page))
-			return CURSEG_WARM_NODE;
-		else
-			return CURSEG_COLD_NODE;
-	}
-}
-
-static int __get_segment_type_6(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA) {
-		struct inode *inode = page->mapping->host;
-
-		if (S_ISDIR(inode->i_mode))
-			return CURSEG_HOT_DATA;
-		else if (is_cold_data(page) || file_is_cold(inode))
-			return CURSEG_COLD_DATA;
-		else
-			return CURSEG_WARM_DATA;
-	} else {
-		if (IS_DNODE(page))
-			return is_cold_node(page) ? CURSEG_WARM_NODE :
-						CURSEG_HOT_NODE;
-		else
-			return CURSEG_COLD_NODE;
-	}
-}
-
-static int __get_segment_type(struct page *page, enum page_type p_type)
-{
-	switch (F2FS_P_SB(page)->active_logs) {
-	case 2:
-		return __get_segment_type_2(page, p_type);
-	case 4:
-		return __get_segment_type_4(page, p_type);
-	}
-	/* NR_CURSEG_TYPE(6) logs by default */
-	f2fs_bug_on(F2FS_P_SB(page),
-		F2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE);
-	return __get_segment_type_6(page, p_type);
-}
-
-void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,
-		block_t old_blkaddr, block_t *new_blkaddr,
-		struct f2fs_summary *sum, int type)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-
-	mutex_lock(&curseg->curseg_mutex);
-	mutex_lock(&sit_i->sentry_lock);
-
-	*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);
-
-	/*
-	 * __add_sum_entry should be resided under the curseg_mutex
-	 * because, this function updates a summary entry in the
-	 * current summary block.
-	 */
-	__add_sum_entry(sbi, type, sum);
-
-	__refresh_next_blkoff(sbi, curseg);
-
-	stat_inc_block_count(sbi, curseg);
-
-	if (!__has_curseg_space(sbi, type))
-		sit_i->s_ops->allocate_segment(sbi, type, false);
-	/*
-	 * SIT information should be updated before segment allocation,
-	 * since SSR needs latest valid block information.
-	 */
-	refresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);
-
-	mutex_unlock(&sit_i->sentry_lock);
-
-	if (page && IS_NODESEG(type))
-		fill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));
-
-	mutex_unlock(&curseg->curseg_mutex);
-}
-
-static void do_write_page(struct f2fs_summary *sum, struct f2fs_io_info *fio)
-{
-	int type = __get_segment_type(fio->page, fio->type);
-
-	if (fio->type == NODE || fio->type == DATA)
-		mutex_lock(&fio->sbi->wio_mutex[fio->type]);
-
-	allocate_data_block(fio->sbi, fio->page, fio->old_blkaddr,
-					&fio->new_blkaddr, sum, type);
-
-	/* writeout dirty page into bdev */
-	f2fs_submit_page_mbio(fio);
-
-	if (fio->type == NODE || fio->type == DATA)
-		mutex_unlock(&fio->sbi->wio_mutex[fio->type]);
-}
-
-void write_meta_page(struct f2fs_sb_info *sbi, struct page *page)
-{
-	struct f2fs_io_info fio = {
-		.sbi = sbi,
-		.type = META,
-		.rw = WRITE_SYNC | REQ_META | REQ_PRIO,
-		.old_blkaddr = page->index,
-		.new_blkaddr = page->index,
-		.page = page,
-		.encrypted_page = NULL,
-	};
-
-	if (unlikely(page->index >= MAIN_BLKADDR(sbi)))
-		fio.rw &= ~REQ_META;
-
-	set_page_writeback(page);
-	f2fs_submit_page_mbio(&fio);
-}
-
-void write_node_page(unsigned int nid, struct f2fs_io_info *fio)
-{
-	struct f2fs_summary sum;
-
-	set_summary(&sum, nid, 0, 0);
-	do_write_page(&sum, fio);
-}
-
-void write_data_page(struct dnode_of_data *dn, struct f2fs_io_info *fio)
-{
-	struct f2fs_sb_info *sbi = fio->sbi;
-	struct f2fs_summary sum;
-	struct node_info ni;
-
-	f2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);
-	get_node_info(sbi, dn->nid, &ni);
-	set_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);
-	do_write_page(&sum, fio);
-	f2fs_update_data_blkaddr(dn, fio->new_blkaddr);
-}
-
-void rewrite_data_page(struct f2fs_io_info *fio)
-{
-	fio->new_blkaddr = fio->old_blkaddr;
-	stat_inc_inplace_blocks(fio->sbi);
-	f2fs_submit_page_mbio(fio);
-}
-
-void __f2fs_replace_block(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,
-				block_t old_blkaddr, block_t new_blkaddr,
-				bool recover_curseg, bool recover_newaddr)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg;
-	unsigned int segno, old_cursegno;
-	struct seg_entry *se;
-	int type;
-	unsigned short old_blkoff;
-
-	segno = GET_SEGNO(sbi, new_blkaddr);
-	se = get_seg_entry(sbi, segno);
-	type = se->type;
-
-	if (!recover_curseg) {
-		/* for recovery flow */
-		if (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {
-			if (old_blkaddr == NULL_ADDR)
-				type = CURSEG_COLD_DATA;
-			else
-				type = CURSEG_WARM_DATA;
-		}
-	} else {
-		if (!IS_CURSEG(sbi, segno))
-			type = CURSEG_WARM_DATA;
-	}
-
-	curseg = CURSEG_I(sbi, type);
-
-	mutex_lock(&curseg->curseg_mutex);
-	mutex_lock(&sit_i->sentry_lock);
-
-	old_cursegno = curseg->segno;
-	old_blkoff = curseg->next_blkoff;
-
-	/* change the current segment */
-	if (segno != curseg->segno) {
-		curseg->next_segno = segno;
-		change_curseg(sbi, type, true);
-	}
-
-	curseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);
-	__add_sum_entry(sbi, type, sum);
-
-	if (!recover_curseg || recover_newaddr)
-		update_sit_entry(sbi, new_blkaddr, 1);
-	if (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)
-		update_sit_entry(sbi, old_blkaddr, -1);
-
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, new_blkaddr));
-
-	locate_dirty_segment(sbi, old_cursegno);
-
-	if (recover_curseg) {
-		if (old_cursegno != curseg->segno) {
-			curseg->next_segno = old_cursegno;
-			change_curseg(sbi, type, true);
-		}
-		curseg->next_blkoff = old_blkoff;
-	}
-
-	mutex_unlock(&sit_i->sentry_lock);
-	mutex_unlock(&curseg->curseg_mutex);
-}
-
-void f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,
-				block_t old_addr, block_t new_addr,
-				unsigned char version, bool recover_curseg,
-				bool recover_newaddr)
-{
-	struct f2fs_summary sum;
-
-	set_summary(&sum, dn->nid, dn->ofs_in_node, version);
-
-	__f2fs_replace_block(sbi, &sum, old_addr, new_addr,
-					recover_curseg, recover_newaddr);
-
-	f2fs_update_data_blkaddr(dn, new_addr);
-}
-
-void f2fs_wait_on_page_writeback(struct page *page,
-				enum page_type type, bool ordered)
-{
-	if (PageWriteback(page)) {
-		struct f2fs_sb_info *sbi = F2FS_P_SB(page);
-
-		f2fs_submit_merged_bio_cond(sbi, NULL, page, 0, type, WRITE);
-		if (ordered)
-			wait_on_page_writeback(page);
-		else
-			/* wait_for_stable_page(page) doesn't support */
-			wait_on_page_writeback(page);
-	}
-}
-
-void f2fs_wait_on_encrypted_page_writeback(struct f2fs_sb_info *sbi,
-							block_t blkaddr)
-{
-	struct page *cpage;
-
-	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
-		return;
-
-	cpage = find_lock_page(META_MAPPING(sbi), blkaddr);
-	if (cpage) {
-		f2fs_wait_on_page_writeback(cpage, DATA, true);
-		f2fs_put_page(cpage, 1);
-	}
-}
-
-static int read_compacted_summaries(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct curseg_info *seg_i;
-	unsigned char *kaddr;
-	struct page *page;
-	block_t start;
-	int i, j, offset;
-
-	start = start_sum_block(sbi);
-
-	page = get_meta_page(sbi, start++);
-	kaddr = (unsigned char *)page_address(page);
-
-	/* Step 1: restore nat cache */
-	seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);
-	memcpy(seg_i->journal, kaddr, SUM_JOURNAL_SIZE);
-
-	/* Step 2: restore sit cache */
-	seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	memcpy(seg_i->journal, kaddr + SUM_JOURNAL_SIZE, SUM_JOURNAL_SIZE);
-	offset = 2 * SUM_JOURNAL_SIZE;
-
-	/* Step 3: restore summary entries */
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		unsigned short blk_off;
-		unsigned int segno;
-
-		seg_i = CURSEG_I(sbi, i);
-		segno = le32_to_cpu(ckpt->cur_data_segno[i]);
-		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);
-		seg_i->next_segno = segno;
-		reset_curseg(sbi, i, 0);
-		seg_i->alloc_type = ckpt->alloc_type[i];
-		seg_i->next_blkoff = blk_off;
-
-		if (seg_i->alloc_type == SSR)
-			blk_off = sbi->blocks_per_seg;
-
-		for (j = 0; j < blk_off; j++) {
-			struct f2fs_summary *s;
-			s = (struct f2fs_summary *)(kaddr + offset);
-			seg_i->sum_blk->entries[j] = *s;
-			offset += SUMMARY_SIZE;
-			if (offset + SUMMARY_SIZE <= PAGE_SIZE -
-						SUM_FOOTER_SIZE)
-				continue;
-
-			f2fs_put_page(page, 1);
-			page = NULL;
-
-			page = get_meta_page(sbi, start++);
-			kaddr = (unsigned char *)page_address(page);
-			offset = 0;
-		}
-	}
-	f2fs_put_page(page, 1);
-	return 0;
-}
-
-static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)
-{
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct f2fs_summary_block *sum;
-	struct curseg_info *curseg;
-	struct page *new;
-	unsigned short blk_off;
-	unsigned int segno = 0;
-	block_t blk_addr = 0;
-
-	/* get segment number and block addr */
-	if (IS_DATASEG(type)) {
-		segno = le32_to_cpu(ckpt->cur_data_segno[type]);
-		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -
-							CURSEG_HOT_DATA]);
-		if (__exist_node_summaries(sbi))
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);
-		else
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);
-	} else {
-		segno = le32_to_cpu(ckpt->cur_node_segno[type -
-							CURSEG_HOT_NODE]);
-		blk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -
-							CURSEG_HOT_NODE]);
-		if (__exist_node_summaries(sbi))
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,
-							type - CURSEG_HOT_NODE);
-		else
-			blk_addr = GET_SUM_BLOCK(sbi, segno);
-	}
-
-	new = get_meta_page(sbi, blk_addr);
-	sum = (struct f2fs_summary_block *)page_address(new);
-
-	if (IS_NODESEG(type)) {
-		if (__exist_node_summaries(sbi)) {
-			struct f2fs_summary *ns = &sum->entries[0];
-			int i;
-			for (i = 0; i < sbi->blocks_per_seg; i++, ns++) {
-				ns->version = 0;
-				ns->ofs_in_node = 0;
-			}
-		} else {
-			int err;
-
-			err = restore_node_summary(sbi, segno, sum);
-			if (err) {
-				f2fs_put_page(new, 1);
-				return err;
-			}
-		}
-	}
-
-	/* set uncompleted segment to curseg */
-	curseg = CURSEG_I(sbi, type);
-	mutex_lock(&curseg->curseg_mutex);
-
-	/* update journal info */
-	down_write(&curseg->journal_rwsem);
-	memcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);
-	up_write(&curseg->journal_rwsem);
-
-	memcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);
-	memcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);
-	curseg->next_segno = segno;
-	reset_curseg(sbi, type, 0);
-	curseg->alloc_type = ckpt->alloc_type[type];
-	curseg->next_blkoff = blk_off;
-	mutex_unlock(&curseg->curseg_mutex);
-	f2fs_put_page(new, 1);
-	return 0;
-}
-
-static int restore_curseg_summaries(struct f2fs_sb_info *sbi)
-{
-	int type = CURSEG_HOT_DATA;
-	int err;
-
-	if (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG)) {
-		int npages = npages_for_summary_flush(sbi, true);
-
-		if (npages >= 2)
-			ra_meta_pages(sbi, start_sum_block(sbi), npages,
-							META_CP, true);
-
-		/* restore for compacted data summary */
-		if (read_compacted_summaries(sbi))
-			return -EINVAL;
-		type = CURSEG_HOT_NODE;
-	}
-
-	if (__exist_node_summaries(sbi))
-		ra_meta_pages(sbi, sum_blk_addr(sbi, NR_CURSEG_TYPE, type),
-					NR_CURSEG_TYPE - type, META_CP, true);
-
-	for (; type <= CURSEG_COLD_NODE; type++) {
-		err = read_normal_summaries(sbi, type);
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
-static void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)
-{
-	struct page *page;
-	unsigned char *kaddr;
-	struct f2fs_summary *summary;
-	struct curseg_info *seg_i;
-	int written_size = 0;
-	int i, j;
-
-	page = grab_meta_page(sbi, blkaddr++);
-	kaddr = (unsigned char *)page_address(page);
-
-	/* Step 1: write nat cache */
-	seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);
-	memcpy(kaddr, seg_i->journal, SUM_JOURNAL_SIZE);
-	written_size += SUM_JOURNAL_SIZE;
-
-	/* Step 2: write sit cache */
-	seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	memcpy(kaddr + written_size, seg_i->journal, SUM_JOURNAL_SIZE);
-	written_size += SUM_JOURNAL_SIZE;
-
-	/* Step 3: write summary entries */
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		unsigned short blkoff;
-		seg_i = CURSEG_I(sbi, i);
-		if (sbi->ckpt->alloc_type[i] == SSR)
-			blkoff = sbi->blocks_per_seg;
-		else
-			blkoff = curseg_blkoff(sbi, i);
-
-		for (j = 0; j < blkoff; j++) {
-			if (!page) {
-				page = grab_meta_page(sbi, blkaddr++);
-				kaddr = (unsigned char *)page_address(page);
-				written_size = 0;
-			}
-			summary = (struct f2fs_summary *)(kaddr + written_size);
-			*summary = seg_i->sum_blk->entries[j];
-			written_size += SUMMARY_SIZE;
-
-			if (written_size + SUMMARY_SIZE <= PAGE_SIZE -
-							SUM_FOOTER_SIZE)
-				continue;
-
-			set_page_dirty(page);
-			f2fs_put_page(page, 1);
-			page = NULL;
-		}
-	}
-	if (page) {
-		set_page_dirty(page);
-		f2fs_put_page(page, 1);
-	}
-}
-
-static void write_normal_summaries(struct f2fs_sb_info *sbi,
-					block_t blkaddr, int type)
-{
-	int i, end;
-	if (IS_DATASEG(type))
-		end = type + NR_CURSEG_DATA_TYPE;
-	else
-		end = type + NR_CURSEG_NODE_TYPE;
-
-	for (i = type; i < end; i++)
-		write_current_sum_page(sbi, i, blkaddr + (i - type));
-}
-
-void write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)
-{
-	if (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG))
-		write_compacted_summaries(sbi, start_blk);
-	else
-		write_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);
-}
-
-void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)
-{
-	write_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);
-}
-
-int lookup_journal_in_cursum(struct f2fs_journal *journal, int type,
-					unsigned int val, int alloc)
-{
-	int i;
-
-	if (type == NAT_JOURNAL) {
-		for (i = 0; i < nats_in_cursum(journal); i++) {
-			if (le32_to_cpu(nid_in_journal(journal, i)) == val)
-				return i;
-		}
-		if (alloc && __has_cursum_space(journal, 1, NAT_JOURNAL))
-			return update_nats_in_cursum(journal, 1);
-	} else if (type == SIT_JOURNAL) {
-		for (i = 0; i < sits_in_cursum(journal); i++)
-			if (le32_to_cpu(segno_in_journal(journal, i)) == val)
-				return i;
-		if (alloc && __has_cursum_space(journal, 1, SIT_JOURNAL))
-			return update_sits_in_cursum(journal, 1);
-	}
-	return -1;
-}
-
-static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,
-					unsigned int segno)
-{
-	return get_meta_page(sbi, current_sit_addr(sbi, segno));
-}
-
-static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,
-					unsigned int start)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct page *src_page, *dst_page;
-	pgoff_t src_off, dst_off;
-	void *src_addr, *dst_addr;
-
-	src_off = current_sit_addr(sbi, start);
-	dst_off = next_sit_addr(sbi, src_off);
-
-	/* get current sit block page without lock */
-	src_page = get_meta_page(sbi, src_off);
-	dst_page = grab_meta_page(sbi, dst_off);
-	f2fs_bug_on(sbi, PageDirty(src_page));
-
-	src_addr = page_address(src_page);
-	dst_addr = page_address(dst_page);
-	memcpy(dst_addr, src_addr, PAGE_SIZE);
-
-	set_page_dirty(dst_page);
-	f2fs_put_page(src_page, 1);
-
-	set_to_next_sit(sit_i, start);
-
-	return dst_page;
-}
-
-static struct sit_entry_set *grab_sit_entry_set(void)
-{
-	struct sit_entry_set *ses =
-			f2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_NOFS);
-
-	ses->entry_cnt = 0;
-	INIT_LIST_HEAD(&ses->set_list);
-	return ses;
-}
-
-static void release_sit_entry_set(struct sit_entry_set *ses)
-{
-	list_del(&ses->set_list);
-	kmem_cache_free(sit_entry_set_slab, ses);
-}
-
-static void adjust_sit_entry_set(struct sit_entry_set *ses,
-						struct list_head *head)
-{
-	struct sit_entry_set *next = ses;
-
-	if (list_is_last(&ses->set_list, head))
-		return;
-
-	list_for_each_entry_continue(next, head, set_list)
-		if (ses->entry_cnt <= next->entry_cnt)
-			break;
-
-	list_move_tail(&ses->set_list, &next->set_list);
-}
-
-static void add_sit_entry(unsigned int segno, struct list_head *head)
-{
-	struct sit_entry_set *ses;
-	unsigned int start_segno = START_SEGNO(segno);
-
-	list_for_each_entry(ses, head, set_list) {
-		if (ses->start_segno == start_segno) {
-			ses->entry_cnt++;
-			adjust_sit_entry_set(ses, head);
-			return;
-		}
-	}
-
-	ses = grab_sit_entry_set();
-
-	ses->start_segno = start_segno;
-	ses->entry_cnt++;
-	list_add(&ses->set_list, head);
-}
-
-static void add_sits_in_set(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_sm_info *sm_info = SM_I(sbi);
-	struct list_head *set_list = &sm_info->sit_entry_set;
-	unsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;
-	unsigned int segno;
-
-	for_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))
-		add_sit_entry(segno, set_list);
-}
-
-static void remove_sits_in_journal(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	int i;
-
-	down_write(&curseg->journal_rwsem);
-	for (i = 0; i < sits_in_cursum(journal); i++) {
-		unsigned int segno;
-		bool dirtied;
-
-		segno = le32_to_cpu(segno_in_journal(journal, i));
-		dirtied = __mark_sit_entry_dirty(sbi, segno);
-
-		if (!dirtied)
-			add_sit_entry(segno, &SM_I(sbi)->sit_entry_set);
-	}
-	update_sits_in_cursum(journal, -i);
-	up_write(&curseg->journal_rwsem);
-}
-
-/*
- * CP calls this function, which flushes SIT entries including sit_journal,
- * and moves prefree segs to free segs.
- */
-void flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned long *bitmap = sit_i->dirty_sentries_bitmap;
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	struct sit_entry_set *ses, *tmp;
-	struct list_head *head = &SM_I(sbi)->sit_entry_set;
-	bool to_journal = true;
-	struct seg_entry *se;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	if (!sit_i->dirty_sentries)
-		goto out;
-
-	/*
-	 * add and account sit entries of dirty bitmap in sit entry
-	 * set temporarily
-	 */
-	add_sits_in_set(sbi);
-
-	/*
-	 * if there are no enough space in journal to store dirty sit
-	 * entries, remove all entries from journal and add and account
-	 * them in sit entry set.
-	 */
-	if (!__has_cursum_space(journal, sit_i->dirty_sentries, SIT_JOURNAL))
-		remove_sits_in_journal(sbi);
-
-	/*
-	 * there are two steps to flush sit entries:
-	 * #1, flush sit entries to journal in current cold data summary block.
-	 * #2, flush sit entries to sit page.
-	 */
-	list_for_each_entry_safe(ses, tmp, head, set_list) {
-		struct page *page = NULL;
-		struct f2fs_sit_block *raw_sit = NULL;
-		unsigned int start_segno = ses->start_segno;
-		unsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,
-						(unsigned long)MAIN_SEGS(sbi));
-		unsigned int segno = start_segno;
-
-		if (to_journal &&
-			!__has_cursum_space(journal, ses->entry_cnt, SIT_JOURNAL))
-			to_journal = false;
-
-		if (to_journal) {
-			down_write(&curseg->journal_rwsem);
-		} else {
-			page = get_next_sit_page(sbi, start_segno);
-			raw_sit = page_address(page);
-		}
-
-		/* flush dirty sit entries in region of current sit set */
-		for_each_set_bit_from(segno, bitmap, end) {
-			int offset, sit_offset;
-
-			se = get_seg_entry(sbi, segno);
-
-			/* add discard candidates */
-			if (cpc->reason != CP_DISCARD) {
-				cpc->trim_start = segno;
-				add_discard_addrs(sbi, cpc);
-			}
-
-			if (to_journal) {
-				offset = lookup_journal_in_cursum(journal,
-							SIT_JOURNAL, segno, 1);
-				f2fs_bug_on(sbi, offset < 0);
-				segno_in_journal(journal, offset) =
-							cpu_to_le32(segno);
-				seg_info_to_raw_sit(se,
-					&sit_in_journal(journal, offset));
-			} else {
-				sit_offset = SIT_ENTRY_OFFSET(sit_i, segno);
-				seg_info_to_raw_sit(se,
-						&raw_sit->entries[sit_offset]);
-			}
-
-			__clear_bit(segno, bitmap);
-			sit_i->dirty_sentries--;
-			ses->entry_cnt--;
-		}
-
-		if (to_journal)
-			up_write(&curseg->journal_rwsem);
-		else
-			f2fs_put_page(page, 1);
-
-		f2fs_bug_on(sbi, ses->entry_cnt);
-		release_sit_entry_set(ses);
-	}
-
-	f2fs_bug_on(sbi, !list_empty(head));
-	f2fs_bug_on(sbi, sit_i->dirty_sentries);
-out:
-	if (cpc->reason == CP_DISCARD) {
-		for (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)
-			add_discard_addrs(sbi, cpc);
-	}
-	mutex_unlock(&sit_i->sentry_lock);
-
-	set_prefree_as_free_segments(sbi);
-}
-
-static int build_sit_info(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
-	struct sit_info *sit_i;
-	unsigned int sit_segs, start;
-	char *src_bitmap, *dst_bitmap;
-	unsigned int bitmap_size;
-
-	/* allocate memory for SIT information */
-	sit_i = kzalloc(sizeof(struct sit_info), GFP_KERNEL);
-	if (!sit_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->sit_info = sit_i;
-
-	sit_i->sentries = f2fs_kvzalloc(MAIN_SEGS(sbi) *
-					sizeof(struct seg_entry), GFP_KERNEL);
-	if (!sit_i->sentries)
-		return -ENOMEM;
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-	sit_i->dirty_sentries_bitmap = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-	if (!sit_i->dirty_sentries_bitmap)
-		return -ENOMEM;
-
-	for (start = 0; start < MAIN_SEGS(sbi); start++) {
-		sit_i->sentries[start].cur_valid_map
-			= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-		sit_i->sentries[start].ckpt_valid_map
-			= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-		if (!sit_i->sentries[start].cur_valid_map ||
-				!sit_i->sentries[start].ckpt_valid_map)
-			return -ENOMEM;
-
-		if (f2fs_discard_en(sbi)) {
-			sit_i->sentries[start].discard_map
-				= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-			if (!sit_i->sentries[start].discard_map)
-				return -ENOMEM;
-		}
-	}
-
-	sit_i->tmp_map = kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-	if (!sit_i->tmp_map)
-		return -ENOMEM;
-
-	if (sbi->segs_per_sec > 1) {
-		sit_i->sec_entries = f2fs_kvzalloc(MAIN_SECS(sbi) *
-					sizeof(struct sec_entry), GFP_KERNEL);
-		if (!sit_i->sec_entries)
-			return -ENOMEM;
-	}
-
-	/* get information related with SIT */
-	sit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;
-
-	/* setup SIT bitmap from ckeckpoint pack */
-	bitmap_size = __bitmap_size(sbi, SIT_BITMAP);
-	src_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);
-
-	dst_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);
-	if (!dst_bitmap)
-		return -ENOMEM;
-
-	/* init SIT information */
-	sit_i->s_ops = &default_salloc_ops;
-
-	sit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);
-	sit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;
-	sit_i->written_valid_blocks = 0;
-	sit_i->sit_bitmap = dst_bitmap;
-	sit_i->bitmap_size = bitmap_size;
-	sit_i->dirty_sentries = 0;
-	sit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;
-	sit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);
-	sit_i->mounted_time = CURRENT_TIME_SEC.tv_sec;
-	mutex_init(&sit_i->sentry_lock);
-	return 0;
-}
-
-static int build_free_segmap(struct f2fs_sb_info *sbi)
-{
-	struct free_segmap_info *free_i;
-	unsigned int bitmap_size, sec_bitmap_size;
-
-	/* allocate memory for free segmap information */
-	free_i = kzalloc(sizeof(struct free_segmap_info), GFP_KERNEL);
-	if (!free_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->free_info = free_i;
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-	free_i->free_segmap = f2fs_kvmalloc(bitmap_size, GFP_KERNEL);
-	if (!free_i->free_segmap)
-		return -ENOMEM;
-
-	sec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));
-	free_i->free_secmap = f2fs_kvmalloc(sec_bitmap_size, GFP_KERNEL);
-	if (!free_i->free_secmap)
-		return -ENOMEM;
-
-	/* set all segments as dirty temporarily */
-	memset(free_i->free_segmap, 0xff, bitmap_size);
-	memset(free_i->free_secmap, 0xff, sec_bitmap_size);
-
-	/* init free segmap information */
-	free_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));
-	free_i->free_segments = 0;
-	free_i->free_sections = 0;
-	spin_lock_init(&free_i->segmap_lock);
-	return 0;
-}
-
-static int build_curseg(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *array;
-	int i;
-
-	array = kcalloc(NR_CURSEG_TYPE, sizeof(*array), GFP_KERNEL);
-	if (!array)
-		return -ENOMEM;
-
-	SM_I(sbi)->curseg_array = array;
-
-	for (i = 0; i < NR_CURSEG_TYPE; i++) {
-		mutex_init(&array[i].curseg_mutex);
-		array[i].sum_blk = kzalloc(PAGE_SIZE, GFP_KERNEL);
-		if (!array[i].sum_blk)
-			return -ENOMEM;
-		init_rwsem(&array[i].journal_rwsem);
-		array[i].journal = kzalloc(sizeof(struct f2fs_journal),
-							GFP_KERNEL);
-		if (!array[i].journal)
-			return -ENOMEM;
-		array[i].segno = NULL_SEGNO;
-		array[i].next_blkoff = 0;
-	}
-	return restore_curseg_summaries(sbi);
-}
-
-static void build_sit_entries(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	struct seg_entry *se;
-	struct f2fs_sit_entry sit;
-	int sit_blk_cnt = SIT_BLK_CNT(sbi);
-	unsigned int i, start, end;
-	unsigned int readed, start_blk = 0;
-
-	do {
-		readed = ra_meta_pages(sbi, start_blk, BIO_MAX_PAGES,
-							META_SIT, true);
-
-		start = start_blk * sit_i->sents_per_block;
-		end = (start_blk + readed) * sit_i->sents_per_block;
-
-		for (; start < end && start < MAIN_SEGS(sbi); start++) {
-			struct f2fs_sit_block *sit_blk;
-			struct page *page;
-
-			se = &sit_i->sentries[start];
-			page = get_current_sit_page(sbi, start);
-			sit_blk = (struct f2fs_sit_block *)page_address(page);
-			sit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];
-			f2fs_put_page(page, 1);
-
-			check_block_count(sbi, start, &sit);
-			seg_info_from_raw_sit(se, &sit);
-
-			/* build discard map only one time */
-			if (f2fs_discard_en(sbi)) {
-				memcpy(se->discard_map, se->cur_valid_map,
-							SIT_VBLOCK_MAP_SIZE);
-				sbi->discard_blks += sbi->blocks_per_seg -
-							se->valid_blocks;
-			}
-
-			if (sbi->segs_per_sec > 1)
-				get_sec_entry(sbi, start)->valid_blocks +=
-							se->valid_blocks;
-		}
-		start_blk += readed;
-	} while (start_blk < sit_blk_cnt);
-
-	down_read(&curseg->journal_rwsem);
-	for (i = 0; i < sits_in_cursum(journal); i++) {
-		unsigned int old_valid_blocks;
-
-		start = le32_to_cpu(segno_in_journal(journal, i));
-		se = &sit_i->sentries[start];
-		sit = sit_in_journal(journal, i);
-
-		old_valid_blocks = se->valid_blocks;
-
-		check_block_count(sbi, start, &sit);
-		seg_info_from_raw_sit(se, &sit);
-
-		if (f2fs_discard_en(sbi)) {
-			memcpy(se->discard_map, se->cur_valid_map,
-						SIT_VBLOCK_MAP_SIZE);
-			sbi->discard_blks += old_valid_blocks -
-						se->valid_blocks;
-		}
-
-		if (sbi->segs_per_sec > 1)
-			get_sec_entry(sbi, start)->valid_blocks +=
-				se->valid_blocks - old_valid_blocks;
-	}
-	up_read(&curseg->journal_rwsem);
-}
-
-static void init_free_segmap(struct f2fs_sb_info *sbi)
-{
-	unsigned int start;
-	int type;
-
-	for (start = 0; start < MAIN_SEGS(sbi); start++) {
-		struct seg_entry *sentry = get_seg_entry(sbi, start);
-		if (!sentry->valid_blocks)
-			__set_free(sbi, start);
-		else
-			SIT_I(sbi)->written_valid_blocks +=
-						sentry->valid_blocks;
-	}
-
-	/* set use the current segments */
-	for (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {
-		struct curseg_info *curseg_t = CURSEG_I(sbi, type);
-		__set_test_and_inuse(sbi, curseg_t->segno);
-	}
-}
-
-static void init_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	struct free_segmap_info *free_i = FREE_I(sbi);
-	unsigned int segno = 0, offset = 0;
-	unsigned short valid_blocks;
-
-	while (1) {
-		/* find dirty segment based on free segmap */
-		segno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);
-		if (segno >= MAIN_SEGS(sbi))
-			break;
-		offset = segno + 1;
-		valid_blocks = get_valid_blocks(sbi, segno, 0);
-		if (valid_blocks == sbi->blocks_per_seg || !valid_blocks)
-			continue;
-		if (valid_blocks > sbi->blocks_per_seg) {
-			f2fs_bug_on(sbi, 1);
-			continue;
-		}
-		mutex_lock(&dirty_i->seglist_lock);
-		__locate_dirty_segment(sbi, segno, DIRTY);
-		mutex_unlock(&dirty_i->seglist_lock);
-	}
-}
-
-static int init_victim_secmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));
-
-	dirty_i->victim_secmap = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-	if (!dirty_i->victim_secmap)
-		return -ENOMEM;
-	return 0;
-}
-
-static int build_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i;
-	unsigned int bitmap_size, i;
-
-	/* allocate memory for dirty segments list information */
-	dirty_i = kzalloc(sizeof(struct dirty_seglist_info), GFP_KERNEL);
-	if (!dirty_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->dirty_info = dirty_i;
-	mutex_init(&dirty_i->seglist_lock);
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-
-	for (i = 0; i < NR_DIRTY_TYPE; i++) {
-		dirty_i->dirty_segmap[i] = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-		if (!dirty_i->dirty_segmap[i])
-			return -ENOMEM;
-	}
-
-	init_dirty_segmap(sbi);
-	return init_victim_secmap(sbi);
-}
-
-/*
- * Update min, max modified time for cost-benefit GC algorithm
- */
-static void init_min_max_mtime(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int segno;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	sit_i->min_mtime = LLONG_MAX;
-
-	for (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {
-		unsigned int i;
-		unsigned long long mtime = 0;
-
-		for (i = 0; i < sbi->segs_per_sec; i++)
-			mtime += get_seg_entry(sbi, segno + i)->mtime;
-
-		mtime = div_u64(mtime, sbi->segs_per_sec);
-
-		if (sit_i->min_mtime > mtime)
-			sit_i->min_mtime = mtime;
-	}
-	sit_i->max_mtime = get_mtime(sbi);
-	mutex_unlock(&sit_i->sentry_lock);
-}
-
-int build_segment_manager(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct f2fs_sm_info *sm_info;
-	int err;
-
-	sm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);
-	if (!sm_info)
-		return -ENOMEM;
-
-	/* init sm info */
-	sbi->sm_info = sm_info;
-	sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);
-	sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);
-	sm_info->segment_count = le32_to_cpu(raw_super->segment_count);
-	sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
-	sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
-	sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);
-	sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);
-	sm_info->rec_prefree_segments = sm_info->main_segments *
-					DEF_RECLAIM_PREFREE_SEGMENTS / 100;
-	if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)
-		sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;
-
-	if (!test_opt(sbi, LFS))
-		sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;
-	sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;
-	sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;
-
-	INIT_LIST_HEAD(&sm_info->discard_list);
-	sm_info->nr_discards = 0;
-	sm_info->max_discards = 0;
-
-	sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;
-
-	INIT_LIST_HEAD(&sm_info->sit_entry_set);
-
-	if (!f2fs_readonly(sbi->sb)) {
-		err = create_flush_cmd_control(sbi);
-		if (err)
-			return err;
-	}
-
-	err = build_sit_info(sbi);
-	if (err)
-		return err;
-	err = build_free_segmap(sbi);
-	if (err)
-		return err;
-	err = build_curseg(sbi);
-	if (err)
-		return err;
-
-	/* reinit free segmap based on SIT */
-	build_sit_entries(sbi);
-
-	init_free_segmap(sbi);
-	err = build_dirty_segmap(sbi);
-	if (err)
-		return err;
-
-	init_min_max_mtime(sbi);
-	return 0;
-}
-
-static void discard_dirty_segmap(struct f2fs_sb_info *sbi,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	mutex_lock(&dirty_i->seglist_lock);
-	f2fs_kvfree(dirty_i->dirty_segmap[dirty_type]);
-	dirty_i->nr_dirty[dirty_type] = 0;
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-static void destroy_victim_secmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	f2fs_kvfree(dirty_i->victim_secmap);
-}
-
-static void destroy_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	int i;
-
-	if (!dirty_i)
-		return;
-
-	/* discard pre-free/dirty segments list */
-	for (i = 0; i < NR_DIRTY_TYPE; i++)
-		discard_dirty_segmap(sbi, i);
-
-	destroy_victim_secmap(sbi);
-	SM_I(sbi)->dirty_info = NULL;
-	kfree(dirty_i);
-}
-
-static void destroy_curseg(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *array = SM_I(sbi)->curseg_array;
-	int i;
-
-	if (!array)
-		return;
-	SM_I(sbi)->curseg_array = NULL;
-	for (i = 0; i < NR_CURSEG_TYPE; i++) {
-		kfree(array[i].sum_blk);
-		kfree(array[i].journal);
-	}
-	kfree(array);
-}
-
-static void destroy_free_segmap(struct f2fs_sb_info *sbi)
-{
-	struct free_segmap_info *free_i = SM_I(sbi)->free_info;
-	if (!free_i)
-		return;
-	SM_I(sbi)->free_info = NULL;
-	f2fs_kvfree(free_i->free_segmap);
-	f2fs_kvfree(free_i->free_secmap);
-	kfree(free_i);
-}
-
-static void destroy_sit_info(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int start;
-
-	if (!sit_i)
-		return;
-
-	if (sit_i->sentries) {
-		for (start = 0; start < MAIN_SEGS(sbi); start++) {
-			kfree(sit_i->sentries[start].cur_valid_map);
-			kfree(sit_i->sentries[start].ckpt_valid_map);
-			kfree(sit_i->sentries[start].discard_map);
-		}
-	}
-	kfree(sit_i->tmp_map);
-
-	f2fs_kvfree(sit_i->sentries);
-	f2fs_kvfree(sit_i->sec_entries);
-	f2fs_kvfree(sit_i->dirty_sentries_bitmap);
-
-	SM_I(sbi)->sit_info = NULL;
-	kfree(sit_i->sit_bitmap);
-	kfree(sit_i);
-}
-
-void destroy_segment_manager(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_sm_info *sm_info = SM_I(sbi);
-
-	if (!sm_info)
-		return;
-	destroy_flush_cmd_control(sbi, true);
-	destroy_dirty_segmap(sbi);
-	destroy_curseg(sbi);
-	destroy_free_segmap(sbi);
-	destroy_sit_info(sbi);
-	sbi->sm_info = NULL;
-	kfree(sm_info);
-}
-
-int __init create_segment_manager_caches(void)
-{
-	discard_entry_slab = f2fs_kmem_cache_create("discard_entry",
-			sizeof(struct discard_entry));
-	if (!discard_entry_slab)
-		goto fail;
-
-	sit_entry_set_slab = f2fs_kmem_cache_create("sit_entry_set",
-			sizeof(struct sit_entry_set));
-	if (!sit_entry_set_slab)
-		goto destory_discard_entry;
-
-	inmem_entry_slab = f2fs_kmem_cache_create("inmem_page_entry",
-			sizeof(struct inmem_pages));
-	if (!inmem_entry_slab)
-		goto destroy_sit_entry_set;
-	return 0;
-
-destroy_sit_entry_set:
-	kmem_cache_destroy(sit_entry_set_slab);
-destory_discard_entry:
-	kmem_cache_destroy(discard_entry_slab);
-fail:
-	return -ENOMEM;
-}
-
-void destroy_segment_manager_caches(void)
-{
-	kmem_cache_destroy(sit_entry_set_slab);
-	kmem_cache_destroy(discard_entry_slab);
-	kmem_cache_destroy(inmem_entry_slab);
-}
diff --git a/fs/f2fs/segment.o_shipped b/fs/f2fs/segment.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..32176ce475d5dd993a0190aa6c6b348adb762781
GIT binary patch
literal 47532
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
WUL{BB?>5BUc2(-~XKDmfyMF*-s8tdG

literal 0
HcmV?d00001

-- 
2.11.0

