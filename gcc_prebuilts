From ccf21a7cb575c9b6e7e82291249100a777047c8e Mon Sep 17 00:00:00 2001
From: Samuel Pascua <pascua.samuel.14@gmail.com>
Date: Tue, 20 Aug 2019 16:03:58 +0800
Subject: [PATCH] asd

---
 drivers/usb/gadget/android.c         | 4013 -----------------
 drivers/usb/gadget/android.o_shipped |  Bin 0 -> 478560 bytes
 fs/f2fs/segment.c                    | 3535 ---------------
 fs/f2fs/segment.o_shipped            |  Bin 0 -> 44068 bytes
 sound/soc/codecs/wcd9320.c           | 7812 ----------------------------------
 sound/soc/codecs/wcd9320.o_shipped   |  Bin 0 -> 148052 bytes
 6 files changed, 15360 deletions(-)
 delete mode 100644 drivers/usb/gadget/android.c
 create mode 100644 drivers/usb/gadget/android.o_shipped
 delete mode 100644 fs/f2fs/segment.c
 create mode 100644 fs/f2fs/segment.o_shipped
 delete mode 100644 sound/soc/codecs/wcd9320.c
 create mode 100644 sound/soc/codecs/wcd9320.o_shipped

diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
deleted file mode 100644
index 18be64363abb..000000000000
--- a/drivers/usb/gadget/android.c
+++ /dev/null
@@ -1,4013 +0,0 @@
-/*
- * Gadget Driver for Android
- *
- * Copyright (C) 2008 Google, Inc.
- * Author: Mike Lockwood <lockwood@android.com>
- *         Benoit Goby <benoit@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/delay.h>
-#include <linux/kernel.h>
-#include <linux/utsname.h>
-#include <linux/platform_device.h>
-#include <linux/pm_qos.h>
-#include <linux/of.h>
-
-#include <linux/usb/ch9.h>
-#include <linux/usb/composite.h>
-#include <linux/usb/gadget.h>
-#include <linux/usb/android.h>
-
-#include <mach/diag_dload.h>
-
-#include "gadget_chips.h"
-
-/*
- * Kbuild is not very cooperative with respect to linking separately
- * compiled library objects into one module.  So for now we won't use
- * separate compilation ... ensuring init/exit sections work to shrink
- * the runtime footprint, and giving us at least some parts of what
- * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
- */
-#include "usbstring.c"
-#include "config.c"
-#include "epautoconf.c"
-#include "composite.c"
-
-#include "f_diag.c"
-#include "f_qdss.c"
-#include "f_rmnet_smd.c"
-#include "f_rmnet_sdio.c"
-#include "f_rmnet_smd_sdio.c"
-#include "f_rmnet.c"
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-#include "f_gps.c"
-#endif
-#ifdef CONFIG_SND_PCM
-#include "f_audio_source.c"
-#endif
-#include "f_fs.c"
-#include "f_mass_storage.c"
-#include "u_serial.c"
-#include "u_sdio.c"
-#include "u_smd.c"
-#include "u_bam.c"
-#include "u_rmnet_ctrl_smd.c"
-#include "u_rmnet_ctrl_qti.c"
-#include "u_ctrl_hsic.c"
-#include "u_data_hsic.c"
-#include "u_ctrl_hsuart.c"
-#include "u_data_hsuart.c"
-#ifdef CONFIG_USB_DUN_SUPPORT
-#include "serial_acm.c"
-#endif
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-#include "f_serial.c"
-#endif
-#include "f_acm.c"
-#include "f_adb.c"
-#include "f_ccid.c"
-#ifdef CONFIG_SND_RAWMIDI
-#include "f_midi.c"
-#endif
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-#include "f_mtp_samsung.c"
-#else
-#include "f_mtp.c"
-#endif
-#include "f_accessory.c"
-#define USB_ETH_RNDIS y
-#include "f_rndis.c"
-#include "rndis.c"
-#include "f_qc_ecm.c"
-#include "f_mbim.c"
-#include "u_bam_data.c"
-#include "f_ecm.c"
-#include "f_qc_rndis.c"
-#include "u_ether.c"
-#include "u_qc_ether.c"
-#ifdef CONFIG_TARGET_CORE
-#include "f_tcm.c"
-#endif
-#ifdef CONFIG_SND_PCM
-#include "u_uac1.c"
-#include "f_uac1.c"
-#endif
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-#include "f_ncm.c"
-#endif
-#ifdef CONFIG_USB_LOCK_SUPPORT_FOR_MDM
-#include <linux/power_supply.h>
-#endif
-
-MODULE_AUTHOR("Mike Lockwood");
-MODULE_DESCRIPTION("Android Composite USB Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0");
-
-static const char longname[] = "Gadget Android";
-
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-static int composite_string_index;
-#endif
-/* Default vendor and product IDs, overridden by userspace */
-#define VENDOR_ID		0x18D1
-#define PRODUCT_ID		0x0001
-
-#define ANDROID_DEVICE_NODE_NAME_LENGTH 11
-
-/* f_midi configuration */
-#ifdef CONFIG_SND_RAWMIDI
-#define SNDRV_DEFAULT_IDX1	(-1)
-#define SNDRV_DEFAULT_STR1	NULL
-#define MIDI_INPUT_PORTS    1
-#define MIDI_OUTPUT_PORTS   1
-#define MIDI_BUFFER_SIZE    1024
-#define MIDI_QUEUE_LENGTH   32
-#endif
-
-struct android_usb_function {
-	char *name;
-	void *config;
-
-	struct device *dev;
-	char *dev_name;
-	struct device_attribute **attributes;
-
-	struct android_dev *android_dev;
-
-	/* Optional: initialization during gadget bind */
-	int (*init)(struct android_usb_function *, struct usb_composite_dev *);
-	/* Optional: cleanup during gadget unbind */
-	void (*cleanup)(struct android_usb_function *);
-	/* Optional: called when the function is added the list of
-	 *		enabled functions */
-	void (*enable)(struct android_usb_function *);
-	/* Optional: called when it is removed */
-	void (*disable)(struct android_usb_function *);
-
-	int (*bind_config)(struct android_usb_function *,
-			   struct usb_configuration *);
-
-	/* Optional: called when the configuration is removed */
-	void (*unbind_config)(struct android_usb_function *,
-			      struct usb_configuration *);
-	/* Optional: handle ctrl requests before the device is configured */
-	int (*ctrlrequest)(struct android_usb_function *,
-					struct usb_composite_dev *,
-					const struct usb_ctrlrequest *);
-};
-#if defined(CONFIG_SEC_H_PROJECT) || defined(CONFIG_SEC_F_PROJECT) || defined(CONFIG_SEC_K_PROJECT)
-u8    usb30en;
-extern int sec_set_speedlimit(struct usb_gadget *gadget,
-			enum usb_device_speed speed);
-extern int sec_get_ss_host_available(struct usb_gadget *gadget);
-#endif
-
-struct android_usb_function_holder {
-
-	struct android_usb_function *f;
-
-	/* for android_conf.enabled_functions */
-	struct list_head enabled_list;
-};
-
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_SIDESYNC
-#include "f_conn_gadget.c"
-#endif
-
-/**
-* struct android_dev - represents android USB gadget device
-* @name: device name.
-* @functions: an array of all the supported USB function
-*    drivers that this gadget support but not necessarily
-*    added to one of the gadget configurations.
-* @cdev: The internal composite device. Android gadget device
-*    is a composite device, such that it can support configurations
-*    with more than one function driver.
-* @dev: The kernel device that represents this android device.
-* @enabled: True if the android gadget is enabled, means all
-*    the configurations were set and all function drivers were
-*    bind and ready for USB enumeration.
-* @disable_depth: Number of times the device was disabled, after
-*    symmetrical number of enables the device willl be enabled.
-*    Used for controlling ADB userspace disable/enable requests.
-* @mutex: Internal mutex for protecting device member fields.
-* @pdata: Platform data fetched from the kernel device platfrom data.
-* @connected: True if got connect notification from the gadget UDC.
-*    False if got disconnect notification from the gadget UDC.
-* @sw_connected: Equal to 'connected' only after the connect
-*    notification was handled by the android gadget work function.
-* @suspended: True if got suspend notification from the gadget UDC.
-*    False if got resume notification from the gadget UDC.
-* @sw_suspended: Equal to 'suspended' only after the susped
-*    notification was handled by the android gadget work function.
-* @pm_qos: An attribute string that can be set by user space in order to
-*    determine pm_qos policy. Set to 'high' for always demand pm_qos
-*    when USB bus is connected and resumed. Set to 'low' for disable
-*    any setting of pm_qos by this driver. Default = 'high'.
-* @work: workqueue used for handling notifications from the gadget UDC.
-* @configs: List of configurations currently configured into the device.
-*    The android gadget supports more than one configuration. The host
-*    may choose one configuration from the suggested.
-* @configs_num: Number of configurations currently configured and existing
-*    in the configs list.
-* @list_item: This driver supports more than one android gadget device (for
-*    example in order to support multiple USB cores), therefore this is
-*    a item in a linked list of android devices.
-*/
-struct android_dev {
-	const char *name;
-	struct android_usb_function **functions;
-	struct usb_composite_dev *cdev;
-	struct device *dev;
-
-	bool enabled;
-	int disable_depth;
-	struct mutex mutex;
-	struct android_usb_platform_data *pdata;
-
-	bool connected;
-	bool sw_connected;
-	bool suspended;
-	bool sw_suspended;
-	char pm_qos[5];
-	struct pm_qos_request pm_qos_req_dma;
-	struct work_struct work;
-	char ffs_aliases[256];
-#if defined(CONFIG_SEC_H_PROJECT)
-	struct delayed_work usb_connection_work;
-	int speaker_check_count;
-#endif
-#ifdef CONFIG_USB_LOCK_SUPPORT_FOR_MDM
-	int usb_lock;
-#endif
-	/* A list of struct android_configuration */
-	struct list_head configs;
-	int configs_num;
-
-	/* A list node inside the android_dev_list */
-	struct list_head list_item;
-};
-
-struct android_configuration {
-	struct usb_configuration usb_config;
-
-	/* A list of the functions supported by this config */
-	struct list_head enabled_functions;
-
-	/* A list node inside the struct android_dev.configs list */
-	struct list_head list_item;
-};
-
-struct dload_struct __iomem *diag_dload;
-static struct class *android_class;
-static struct list_head android_dev_list;
-static int android_dev_count;
-static int android_bind_config(struct usb_configuration *c);
-static void android_unbind_config(struct usb_configuration *c);
-static struct android_dev *cdev_to_android_dev(struct usb_composite_dev *cdev);
-static struct android_configuration *alloc_android_config
-						(struct android_dev *dev);
-static void free_android_config(struct android_dev *dev,
-				struct android_configuration *conf);
-static int usb_diag_update_pid_and_serial_num(uint32_t pid, const char *snum);
-
-/* string IDs are assigned dynamically */
-#define STRING_MANUFACTURER_IDX		0
-#define STRING_PRODUCT_IDX		1
-#define STRING_SERIAL_IDX		2
-
-static char manufacturer_string[256];
-static char product_string[256];
-static char serial_string[256];
-
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-#include "u_ncm.c"
-#endif
-
-/* String Table */
-static struct usb_string strings_dev[] = {
-	[STRING_MANUFACTURER_IDX].s = manufacturer_string,
-	[STRING_PRODUCT_IDX].s = product_string,
-	[STRING_SERIAL_IDX].s = serial_string,
-	{  }			/* end of list */
-};
-
-static struct usb_gadget_strings stringtab_dev = {
-	.language	= 0x0409,	/* en-us */
-	.strings	= strings_dev,
-};
-
-static struct usb_gadget_strings *dev_strings[] = {
-	&stringtab_dev,
-	NULL,
-};
-
-static struct usb_device_descriptor device_desc = {
-	.bLength              = sizeof(device_desc),
-	.bDescriptorType      = USB_DT_DEVICE,
-	.bcdUSB               = __constant_cpu_to_le16(0x0200),
-	.bDeviceClass         = USB_CLASS_PER_INTERFACE,
-	.idVendor             = __constant_cpu_to_le16(VENDOR_ID),
-	.idProduct            = __constant_cpu_to_le16(PRODUCT_ID),
-	.bcdDevice            = __constant_cpu_to_le16(0xffff),
-	.bNumConfigurations   = 1,
-};
-
-static struct usb_otg_descriptor otg_descriptor = {
-	.bLength =		sizeof otg_descriptor,
-	.bDescriptorType =	USB_DT_OTG,
-	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
-	.bcdOTG               = __constant_cpu_to_le16(0x0200),
-};
-
-static const struct usb_descriptor_header *otg_desc[] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
-	NULL,
-};
-
-enum android_device_state {
-	USB_DISCONNECTED,
-	USB_CONNECTED,
-	USB_CONFIGURED,
-	USB_SUSPENDED,
-	USB_RESUMED
-};
-
-static void android_pm_qos_update_latency(struct android_dev *dev, int vote)
-{
-	struct android_usb_platform_data *pdata = dev->pdata;
-	u32 swfi_latency = 0;
-	static int last_vote = -1;
-
-	if (!pdata || vote == last_vote
-		|| !pdata->swfi_latency)
-		return;
-
-	swfi_latency = pdata->swfi_latency + 1;
-	if (vote)
-		pm_qos_update_request(&dev->pm_qos_req_dma,
-				swfi_latency);
-	else
-		pm_qos_update_request(&dev->pm_qos_req_dma,
-				PM_QOS_DEFAULT_VALUE);
-	last_vote = vote;
-}
-
-static void android_work(struct work_struct *data)
-{
-	struct android_dev *dev = container_of(data, struct android_dev, work);
-	struct usb_composite_dev *cdev = dev->cdev;
-	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
-	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
-	char *configured[2]   = { "USB_STATE=CONFIGURED", NULL };
-	char *suspended[2]   = { "USB_STATE=SUSPENDED", NULL };
-	char *resumed[2]   = { "USB_STATE=RESUMED", NULL };
-#if defined(CONFIG_SEC_H_PROJECT)
-	char *cableconnect[2] = { "USB_CONNECTION=CONNECTED", NULL };
-#endif
-	char **uevent_envp = NULL;
-	static enum android_device_state last_uevent, next_state;
-	unsigned long flags;
-	int pm_qos_vote = -1;
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (dev->suspended != dev->sw_suspended && cdev->config) {
-		if (strncmp(dev->pm_qos, "low", 3))
-			pm_qos_vote = dev->suspended ? 0 : 1;
-		next_state = dev->suspended ? USB_SUSPENDED : USB_RESUMED;
-		uevent_envp = dev->suspended ? suspended : resumed;
-	} else if (cdev->config) {
-		uevent_envp = configured;
-		next_state = USB_CONFIGURED;
-	} else if (dev->connected != dev->sw_connected) {
-		uevent_envp = dev->connected ? connected : disconnected;
-		next_state = dev->connected ? USB_CONNECTED : USB_DISCONNECTED;
-		if (dev->connected && strncmp(dev->pm_qos, "low", 3))
-			pm_qos_vote = 1;
-		else if (!dev->connected || !strncmp(dev->pm_qos, "low", 3))
-			pm_qos_vote = 0;
-	}
-	dev->sw_connected = dev->connected;
-	dev->sw_suspended = dev->suspended;
-	spin_unlock_irqrestore(&cdev->lock, flags);
-
-	if (pm_qos_vote != -1)
-		android_pm_qos_update_latency(dev, pm_qos_vote);
-
-	if (uevent_envp) {
-		/*
-		 * Some userspace modules, e.g. MTP, work correctly only if
-		 * CONFIGURED uevent is preceded by DISCONNECT uevent.
-		 * Check if we missed sending out a DISCONNECT uevent. This can
-		 * happen if host PC resets and configures device really quick.
-		 */
-		if (((uevent_envp == connected) &&
-		      (last_uevent != USB_DISCONNECTED)) ||
-		    ((uevent_envp == configured) &&
-		      (last_uevent == USB_CONFIGURED))) {
-			pr_info("%s: sent missed DISCONNECT event\n", __func__);
-			kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE,
-								disconnected);
-//			msleep(20);
-		}
-		/*
-		 * Before sending out CONFIGURED uevent give function drivers
-		 * a chance to wakeup userspace threads and notify disconnect
-		 */
-//		if (uevent_envp == configured)
-//			msleep(50);
-
-		/* Do not notify on suspend / resume */
-		if (next_state != USB_SUSPENDED && next_state != USB_RESUMED) {
-			kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE,
-					   uevent_envp);
-#if defined(CONFIG_SEC_H_PROJECT)
-		if (uevent_envp == connected)
-			kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, cableconnect);
-#endif
-			last_uevent = next_state;
-		}
-		pr_info("%s: sent uevent %s\n", __func__, uevent_envp[0]);
-	} else {
-		pr_info("%s: did not send uevent (%d %d %pK)\n", __func__,
-			 dev->connected, dev->sw_connected, cdev->config);
-	}
-}
-
-#if defined(CONFIG_SEC_H_PROJECT)
-extern int speaker_status;
-
-void usb_gadget_connect_work(struct work_struct *work)
-{
-	struct android_dev *dev =
-	    container_of(work, struct android_dev, usb_connection_work.work);
-	struct usb_composite_dev *cdev = dev->cdev;
-
-	pr_info("%s: speaker_status: %d, speaker_check_count %d\n",
-		__func__, speaker_status, dev->speaker_check_count);
-
-	/* Max 3 sec */
-	if (speaker_status > 0) {
-		dev->speaker_check_count++;
-		if (dev->speaker_check_count < 60) {
-			schedule_delayed_work(&dev->usb_connection_work, msecs_to_jiffies(50));
-			return;
-		}
-	}
-	usb_gadget_connect(cdev->gadget);
-}
-
-void schedule_usb_gadget_connect_work(struct android_dev *dev)
-{
-	char *ready[2] = { "USB_CONNECTION=READY", NULL };
-
-	if (dev == NULL) return;
-
-	pr_info("%s\n",__func__);
-
-	if (work_busy(&dev->usb_connection_work.work)) {
-		cancel_delayed_work(&dev->usb_connection_work);
-		pr_info("%s  canceling the work\n",__func__);
-	}
-
-	kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, ready);
-	dev->speaker_check_count = 0;
-	schedule_delayed_work(&dev->usb_connection_work, msecs_to_jiffies(1));
-}
-#endif
-
-static int android_enable(struct android_dev *dev)
-{
-	struct usb_composite_dev *cdev = dev->cdev;
-	struct android_configuration *conf;
-	int err = 0;
-
-	if (WARN_ON(!dev->disable_depth))
-		return err;
-
-	if (--dev->disable_depth == 0) {
-
-		list_for_each_entry(conf, &dev->configs, list_item) {
-			err = usb_add_config(cdev, &conf->usb_config,
-						android_bind_config);
-			if (err < 0) {
-				pr_err("%s: usb_add_config failed : err: %d\n",
-						__func__, err);
-				return err;
-			}
-		}
-#if defined(CONFIG_SEC_H_PROJECT)
-		schedule_usb_gadget_connect_work(dev);
-#else
-		usb_gadget_connect(cdev->gadget);
-#endif
-	}
-
-	return err;
-}
-
-static void android_disable(struct android_dev *dev)
-{
-	struct usb_composite_dev *cdev = dev->cdev;
-	struct android_configuration *conf;
-
-	if (dev->disable_depth++ == 0) {
-		usb_gadget_disconnect(cdev->gadget);
-		/* Cancel pending control requests */
-		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
-
-		list_for_each_entry(conf, &dev->configs, list_item)
-			usb_remove_config(cdev, &conf->usb_config);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-/* Supported functions initialization */
-
-struct functionfs_config {
-	bool opened;
-	bool enabled;
-	struct ffs_data *data;
-	struct android_dev *dev;
-};
-
-static int ffs_function_init(struct android_usb_function *f,
-			     struct usb_composite_dev *cdev)
-{
-	f->config = kzalloc(sizeof(struct functionfs_config), GFP_KERNEL);
-	if (!f->config)
-		return -ENOMEM;
-
-	return functionfs_init();
-}
-
-static void ffs_function_cleanup(struct android_usb_function *f)
-{
-	functionfs_cleanup();
-	kfree(f->config);
-}
-
-static void ffs_function_enable(struct android_usb_function *f)
-{
-	struct android_dev *dev = f->android_dev;
-	struct functionfs_config *config = f->config;
-
-	config->enabled = true;
-
-	/* Disable the gadget until the function is ready */
-	if (!config->opened)
-		android_disable(dev);
-}
-
-static void ffs_function_disable(struct android_usb_function *f)
-{
-	struct android_dev *dev = f->android_dev;
-	struct functionfs_config *config = f->config;
-
-	config->enabled = false;
-
-	/* Balance the disable that was called in closed_callback */
-	if (!config->opened)
-		android_enable(dev);
-}
-
-static int ffs_function_bind_config(struct android_usb_function *f,
-				    struct usb_configuration *c)
-{
-	struct functionfs_config *config = f->config;
-	return functionfs_bind_config(c->cdev, c, config->data);
-}
-
-static ssize_t
-ffs_aliases_show(struct device *pdev, struct device_attribute *attr, char *buf)
-{
-	struct android_dev *dev;
-	int ret;
-
-	dev = list_first_entry(&android_dev_list, struct android_dev,
-					list_item);
-
-	mutex_lock(&dev->mutex);
-	ret = sprintf(buf, "%s\n", dev->ffs_aliases);
-	mutex_unlock(&dev->mutex);
-
-	return ret;
-}
-
-static ssize_t
-ffs_aliases_store(struct device *pdev, struct device_attribute *attr,
-					const char *buf, size_t size)
-{
-	struct android_dev *dev;
-	char buff[256];
-
-	dev = list_first_entry(&android_dev_list, struct android_dev,
-					list_item);
-
-	mutex_lock(&dev->mutex);
-
-	if (dev->enabled) {
-		mutex_unlock(&dev->mutex);
-		return -EBUSY;
-	}
-
-	strlcpy(buff, buf, sizeof(buff));
-	strlcpy(dev->ffs_aliases, strim(buff), sizeof(dev->ffs_aliases));
-
-	mutex_unlock(&dev->mutex);
-
-	return size;
-}
-
-static DEVICE_ATTR(aliases, S_IRUGO | S_IWUSR, ffs_aliases_show,
-					       ffs_aliases_store);
-static struct device_attribute *ffs_function_attributes[] = {
-	&dev_attr_aliases,
-	NULL
-};
-
-static struct android_usb_function ffs_function = {
-	.name		= "ffs",
-	.init		= ffs_function_init,
-	.enable		= ffs_function_enable,
-	.disable	= ffs_function_disable,
-	.cleanup	= ffs_function_cleanup,
-	.bind_config	= ffs_function_bind_config,
-	.attributes	= ffs_function_attributes,
-};
-
-static int functionfs_ready_callback(struct ffs_data *ffs)
-{
-	struct android_dev *dev = ffs_function.android_dev;
-	struct functionfs_config *config = ffs_function.config;
-	int ret = 0;
-
-	/* dev is null in case ADB is not in the composition */
-	if (dev) {
-		mutex_lock(&dev->mutex);
-		ret = functionfs_bind(ffs, dev->cdev);
-		if (ret) {
-			mutex_unlock(&dev->mutex);
-			return ret;
-		}
-	} else {
-		/* android ffs_func requires daemon to start only after enable*/
-		pr_debug("start adbd only in ADB composition\n");
-		return -ENODEV;
-	}
-
-	config->data = ffs;
-	config->opened = true;
-	/* Save dev in case the adb function will get disabled */
-	config->dev = dev;
-
-	if (config->enabled)
-		android_enable(dev);
-
-	mutex_unlock(&dev->mutex);
-
-	return 0;
-
-}
-
-static void functionfs_closed_callback(struct ffs_data *ffs)
-{
-	struct android_dev *dev = ffs_function.android_dev;
-	struct functionfs_config *config = ffs_function.config;
-
-	/*
-	 * In case new composition is without ADB or ADB got disabled by the
-	 * time ffs_daemon was stopped then use saved one
-	 */
-	if (!dev)
-		dev = config->dev;
-
-	/* fatal-error: It should never happen */
-	if (!dev)
-		pr_err("adb_closed_callback: config->dev is NULL");
-
-	if (dev)
-		mutex_lock(&dev->mutex);
-
-	if (config->enabled && dev)
-		android_disable(dev);
-
-	config->dev = NULL;
-
-	config->opened = false;
-	config->data = NULL;
-
-	functionfs_unbind(ffs);
-
-	if (dev)
-		mutex_unlock(&dev->mutex);
-}
-
-static int functionfs_check_dev_callback(const char *dev_name)
-{
-	return 0;
-}
-
-
-struct adb_data {
-	bool opened;
-	bool enabled;
-	struct android_dev *dev;
-};
-
-static int
-adb_function_init(struct android_usb_function *f,
-		struct usb_composite_dev *cdev)
-{
-	f->config = kzalloc(sizeof(struct adb_data), GFP_KERNEL);
-	if (!f->config)
-		return -ENOMEM;
-
-	return adb_setup();
-}
-
-static void adb_function_cleanup(struct android_usb_function *f)
-{
-	adb_cleanup();
-	kfree(f->config);
-}
-
-static int
-adb_function_bind_config(struct android_usb_function *f,
-		struct usb_configuration *c)
-{
-	return adb_bind_config(c);
-}
-
-static void adb_android_function_enable(struct android_usb_function *f)
-{
-	struct android_dev *dev = f->android_dev;
-	struct adb_data *data = f->config;
-
-	data->enabled = true;
-
-
-	/* Disable the gadget until adbd is ready */
-	if (!data->opened)
-		android_disable(dev);
-}
-
-static void adb_android_function_disable(struct android_usb_function *f)
-{
-	struct android_dev *dev = f->android_dev;
-	struct adb_data *data = f->config;
-
-	data->enabled = false;
-
-	/* Balance the disable that was called in closed_callback */
-	if (!data->opened)
-		android_enable(dev);
-}
-
-static struct android_usb_function adb_function = {
-	.name		= "adb",
-	.enable		= adb_android_function_enable,
-	.disable	= adb_android_function_disable,
-	.init		= adb_function_init,
-	.cleanup	= adb_function_cleanup,
-	.bind_config	= adb_function_bind_config,
-};
-
-static void adb_ready_callback(void)
-{
-	struct android_dev *dev = adb_function.android_dev;
-	struct adb_data *data = adb_function.config;
-
-	/* dev is null in case ADB is not in the composition */
-	if (dev)
-		mutex_lock(&dev->mutex);
-
-	/* Save dev in case the adb function will get disabled */
-	data->dev = dev;
-	data->opened = true;
-
-	if (data->enabled && dev)
-		android_enable(dev);
-
-	if (dev)
-		mutex_unlock(&dev->mutex);
-}
-
-static void adb_closed_callback(void)
-{
-	struct adb_data *data = adb_function.config;
-	struct android_dev *dev = adb_function.android_dev;
-
-	/* In case new composition is without ADB, use saved one */
-	if (!dev)
-		dev = data->dev;
-
-	if (!dev)
-		pr_err("adb_closed_callback: data->dev is NULL");
-
-	if (dev)
-		mutex_lock(&dev->mutex);
-
-	data->opened = false;
-
-	if (data->enabled && dev)
-		android_disable(dev);
-
-	data->dev = NULL;
-
-	if (dev)
-		mutex_unlock(&dev->mutex);
-}
-
-#ifdef CONFIG_SND_RAWMIDI
-static int midi_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
-{
-	struct midi_alsa_config *config;
-	config = kzalloc(sizeof(struct midi_alsa_config), GFP_KERNEL);
-	f->config = config;
-	if (!config)
-		return -ENOMEM;
-	config->card = -1;
-	config->device = -1;
-	return 0;
-}
-
-static void midi_function_cleanup(struct android_usb_function *f)
-{
-	kfree(f->config);
-}
-
-static int midi_function_bind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	struct midi_alsa_config *config = f->config;
-
-	return  f_midi_bind_config(c, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
-			MIDI_INPUT_PORTS, MIDI_OUTPUT_PORTS, MIDI_BUFFER_SIZE,
-			MIDI_QUEUE_LENGTH, config);
-}
-
-static ssize_t midi_alsa_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct midi_alsa_config *config = f->config;
-
-	/* print ALSA card and device numbers */
-	return sprintf(buf, "%d %d\n", config->card, config->device);
-}
-
-static DEVICE_ATTR(alsa, S_IRUGO, midi_alsa_show, NULL);
-
-static struct device_attribute *midi_function_attributes[] = {
-	&dev_attr_alsa,
-	NULL
-};
-
-static struct android_usb_function midi_function = {
-	.name		= "midi",
-	.init		= midi_function_init,
-	.cleanup	= midi_function_cleanup,
-	.bind_config	= midi_function_bind_config,
-	.attributes	= midi_function_attributes,
-};
-#endif
-/*-------------------------------------------------------------------------*/
-/* Supported functions initialization */
-
-/* ACM */
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-#define MAX_ACM_INSTANCES 4
-struct acm_function_config {
-	int instances;
-};
-
-static int acm_function_init(struct android_usb_function *f,
-		struct usb_composite_dev *cdev)
-{
-	int ret;
-
-	f->config = kzalloc(sizeof(struct acm_function_config), GFP_KERNEL);
-	if (!f->config)
-		return -ENOMEM;
-
-	ret = gserial_setup(cdev->gadget, MAX_ACM_INSTANCES);
-
-	return ret;
-}
-
-static void acm_function_cleanup(struct android_usb_function *f)
-{
-	gserial_cleanup();
-	kfree(f->config);
-	f->config = NULL;
-}
-
-static int acm_function_bind_config(struct android_usb_function *f,
-		struct usb_configuration *c)
-{
-	int i;
-	int ret = 0;
-	struct acm_function_config *config = f->config;
-
-	for (i = 0; i < config->instances; i++) {
-		ret = acm_bind_config(c, i);
-		if (ret) {
-			pr_err("Could not bind acm%u config\n", i);
-			break;
-		}
-	}
-	return ret;
-}
-
-static ssize_t acm_instances_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct acm_function_config *config = f->config;
-	return sprintf(buf, "%d\n", config->instances);
-}
-
-static ssize_t acm_instances_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct acm_function_config *config = f->config;
-	int value;
-
-	sscanf(buf, "%d", &value);
-	if (value > MAX_ACM_INSTANCES)
-		value = MAX_ACM_INSTANCES;
-	config->instances = value;
-	return size;
-}
-
-static DEVICE_ATTR(instances, S_IRUGO | S_IWUSR,
-		acm_instances_show, acm_instances_store);
-static struct device_attribute *acm_function_attributes[]
-		= { &dev_attr_instances, NULL };
-
-static struct android_usb_function acm_function = {
-	.name		= "acm",
-	.init		= acm_function_init,
-	.cleanup	= acm_function_cleanup,
-	.bind_config	= acm_function_bind_config,
-	.attributes	= acm_function_attributes,
-};
-#else
-static char acm_transports[32];	/*enabled ACM ports - "tty[,sdio]"*/
-static ssize_t acm_transports_store(
-		struct device *device, struct device_attribute *attr,
-		const char *buff, size_t size)
-{
-	strlcpy(acm_transports, buff, sizeof(acm_transports));
-
-	return size;
-}
-
-static DEVICE_ATTR(acm_transports, S_IWUSR, NULL, acm_transports_store);
-static struct device_attribute *acm_function_attributes[] = {
-		&dev_attr_acm_transports,
-		NULL
-};
-
-static void acm_function_cleanup(struct android_usb_function *f)
-{
-	gserial_cleanup();
-}
-
-static int
-acm_function_bind_config(struct android_usb_function *f,
-		struct usb_configuration *c)
-{
-	char *name;
-	char buf[32], *b;
-	int err = -1, i;
-	static int acm_initialized, ports;
-
-	if (acm_initialized)
-		goto bind_config;
-
-	acm_initialized = 1;
-	strlcpy(buf, acm_transports, sizeof(buf));
-	b = strim(buf);
-
-	while (b) {
-		name = strsep(&b, ",");
-
-		if (name) {
-			err = acm_init_port(ports, name);
-			if (err) {
-				pr_err("acm: Cannot open port '%s'", name);
-				goto out;
-			}
-			ports++;
-		}
-	}
-	err = acm_port_setup(c);
-	if (err) {
-		pr_err("acm: Cannot setup transports");
-		goto out;
-	}
-
-bind_config:
-	for (i = 0; i < ports; i++) {
-		err = acm_bind_config(c, i);
-		if (err) {
-			pr_err("acm: bind_config failed for port %d", i);
-			goto out;
-		}
-	}
-
-out:
-	return err;
-}
-
-static struct android_usb_function acm_function = {
-	.name		= "acm",
-	.cleanup	= acm_function_cleanup,
-	.bind_config	= acm_function_bind_config,
-	.attributes	= acm_function_attributes,
-};
-#endif
-
-/* RMNET_SMD */
-static int rmnet_smd_function_bind_config(struct android_usb_function *f,
-					  struct usb_configuration *c)
-{
-	return rmnet_smd_bind_config(c);
-}
-
-static struct android_usb_function rmnet_smd_function = {
-	.name		= "rmnet_smd",
-	.bind_config	= rmnet_smd_function_bind_config,
-};
-
-/* RMNET_SDIO */
-static int rmnet_sdio_function_bind_config(struct android_usb_function *f,
-					  struct usb_configuration *c)
-{
-	return rmnet_sdio_function_add(c);
-}
-
-static struct android_usb_function rmnet_sdio_function = {
-	.name		= "rmnet_sdio",
-	.bind_config	= rmnet_sdio_function_bind_config,
-};
-
-/* RMNET_SMD_SDIO */
-static int rmnet_smd_sdio_function_init(struct android_usb_function *f,
-				 struct usb_composite_dev *cdev)
-{
-	return rmnet_smd_sdio_init();
-}
-
-static void rmnet_smd_sdio_function_cleanup(struct android_usb_function *f)
-{
-	rmnet_smd_sdio_cleanup();
-}
-
-static int rmnet_smd_sdio_bind_config(struct android_usb_function *f,
-					  struct usb_configuration *c)
-{
-	return rmnet_smd_sdio_function_add(c);
-}
-
-static struct device_attribute *rmnet_smd_sdio_attributes[] = {
-					&dev_attr_transport, NULL };
-
-static struct android_usb_function rmnet_smd_sdio_function = {
-	.name		= "rmnet_smd_sdio",
-	.init		= rmnet_smd_sdio_function_init,
-	.cleanup	= rmnet_smd_sdio_function_cleanup,
-	.bind_config	= rmnet_smd_sdio_bind_config,
-	.attributes	= rmnet_smd_sdio_attributes,
-};
-
-/*rmnet transport string format(per port):"ctrl0,data0,ctrl1,data1..." */
-#define MAX_XPORT_STR_LEN 50
-static char rmnet_transports[MAX_XPORT_STR_LEN];
-
-/*rmnet transport name string - "rmnet_hsic[,rmnet_hsusb]" */
-static char rmnet_xport_names[MAX_XPORT_STR_LEN];
-
-static void rmnet_function_cleanup(struct android_usb_function *f)
-{
-	frmnet_cleanup();
-}
-
-static int rmnet_function_bind_config(struct android_usb_function *f,
-					 struct usb_configuration *c)
-{
-	int i;
-	int err = 0;
-	char *ctrl_name;
-	char *data_name;
-	char *tname = NULL;
-	char buf[MAX_XPORT_STR_LEN], *b;
-	char xport_name_buf[MAX_XPORT_STR_LEN], *tb;
-	static int rmnet_initialized, ports;
-
-	if (!rmnet_initialized) {
-		rmnet_initialized = 1;
-		strlcpy(buf, rmnet_transports, sizeof(buf));
-		b = strim(buf);
-
-		strlcpy(xport_name_buf, rmnet_xport_names,
-				sizeof(xport_name_buf));
-		tb = strim(xport_name_buf);
-
-		while (b) {
-			ctrl_name = strsep(&b, ",");
-			data_name = strsep(&b, ",");
-			if (ctrl_name && data_name) {
-				if (tb)
-					tname = strsep(&tb, ",");
-				err = frmnet_init_port(ctrl_name, data_name,
-						tname);
-				if (err) {
-					pr_err("rmnet: Cannot open ctrl port:"
-						"'%s' data port:'%s'\n",
-						ctrl_name, data_name);
-					goto out;
-				}
-				ports++;
-			}
-		}
-
-		err = rmnet_gport_setup();
-		if (err) {
-			pr_err("rmnet: Cannot setup transports");
-			goto out;
-		}
-	}
-
-	for (i = 0; i < ports; i++) {
-		err = frmnet_bind_config(c, i);
-		if (err) {
-			pr_err("Could not bind rmnet%u config\n", i);
-			break;
-		}
-	}
-out:
-	return err;
-}
-
-static ssize_t rmnet_transports_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%s\n", rmnet_transports);
-}
-
-static ssize_t rmnet_transports_store(
-		struct device *device, struct device_attribute *attr,
-		const char *buff, size_t size)
-{
-	strlcpy(rmnet_transports, buff, sizeof(rmnet_transports));
-
-	return size;
-}
-
-static ssize_t rmnet_xport_names_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%s\n", rmnet_xport_names);
-}
-
-static ssize_t rmnet_xport_names_store(
-		struct device *device, struct device_attribute *attr,
-		const char *buff, size_t size)
-{
-	strlcpy(rmnet_xport_names, buff, sizeof(rmnet_xport_names));
-
-	return size;
-}
-
-static struct device_attribute dev_attr_rmnet_transports =
-					__ATTR(transports, S_IRUGO | S_IWUSR,
-						rmnet_transports_show,
-						rmnet_transports_store);
-
-static struct device_attribute dev_attr_rmnet_xport_names =
-				__ATTR(transport_names, S_IRUGO | S_IWUSR,
-				rmnet_xport_names_show,
-				rmnet_xport_names_store);
-
-static struct device_attribute *rmnet_function_attributes[] = {
-					&dev_attr_rmnet_transports,
-					&dev_attr_rmnet_xport_names,
-					NULL };
-
-static struct android_usb_function rmnet_function = {
-	.name		= "rmnet",
-	.cleanup	= rmnet_function_cleanup,
-	.bind_config	= rmnet_function_bind_config,
-	.attributes	= rmnet_function_attributes,
-};
-
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-static void gps_function_cleanup(struct android_usb_function *f)
-{
-	gps_cleanup();
-}
-
-static int gps_function_bind_config(struct android_usb_function *f,
-					 struct usb_configuration *c)
-{
-	int err;
-	static int gps_initialized;
-
-	if (!gps_initialized) {
-		gps_initialized = 1;
-		err = gps_init_port();
-		if (err) {
-			pr_err("gps: Cannot init gps port");
-			return err;
-		}
-	}
-
-	err = gps_gport_setup();
-	if (err) {
-		pr_err("gps: Cannot setup transports");
-		return err;
-	}
-	err = gps_bind_config(c);
-	if (err) {
-		pr_err("Could not bind gps config\n");
-		return err;
-	}
-
-	return 0;
-}
-
-static struct android_usb_function gps_function = {
-	.name		= "gps",
-	.cleanup	= gps_function_cleanup,
-	.bind_config	= gps_function_bind_config,
-};
-#endif
-
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-/* ncm */
-struct ncm_function_config {
-	u8      ethaddr[ETH_ALEN];
-};
-static int
-ncm_function_init(struct android_usb_function *f, struct usb_composite_dev *c)
-{
-	f->config = kzalloc(sizeof(struct ncm_function_config), GFP_KERNEL);
-	if (!f->config)
-		return -ENOMEM;
-
-	return 0;
-}
-
-static void ncm_function_cleanup(struct android_usb_function *f)
-{
-	kfree(f->config);
-	f->config = NULL;
-}
-
-static int
-ncm_function_bind_config(struct android_usb_function *f,
-				struct usb_configuration *c)
-{
-	struct ncm_function_config *ncm = f->config;
-	int ret;
-
-	if (!ncm) {
-		pr_err("%s: ncm config is null\n", __func__);
-		return -EINVAL;
-	}
-
-	pr_info("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
-		ncm->ethaddr[0], ncm->ethaddr[1], ncm->ethaddr[2],
-		ncm->ethaddr[3], ncm->ethaddr[4], ncm->ethaddr[5]);
-
-	ret = gether_setup_name(c->cdev->gadget, ncm->ethaddr, "ncm");
-	if (ret) {
-		pr_err("%s: gether setup failed err:%d\n", __func__, ret);
-		return ret;
-	}
-
-	ret = ncm_bind_config(c, ncm->ethaddr);
-	if (ret) {
-		pr_err("%s: ncm bind config failed err:%d", __func__, ret);
-		gether_cleanup();
-		return ret;
-	}
-
-	return ret;
-}
-
-static void ncm_function_unbind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	gether_cleanup();
-}
-
-static ssize_t ncm_ethaddr_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct ncm_function_config *ncm = f->config;
-	return snprintf(buf, PAGE_SIZE, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		ncm->ethaddr[0], ncm->ethaddr[1], ncm->ethaddr[2],
-		ncm->ethaddr[3], ncm->ethaddr[4], ncm->ethaddr[5]);
-}
-
-static ssize_t ncm_ethaddr_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct ncm_function_config *ncm = f->config;
-
-	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		    (int *)&ncm->ethaddr[0], (int *)&ncm->ethaddr[1],
-		    (int *)&ncm->ethaddr[2], (int *)&ncm->ethaddr[3],
-		    (int *)&ncm->ethaddr[4], (int *)&ncm->ethaddr[5]) == 6)
-		return size;
-	return -EINVAL;
-}
-
-static DEVICE_ATTR(ncm_ethaddr, S_IRUGO | S_IWUSR, ncm_ethaddr_show,
-					       ncm_ethaddr_store);
-static struct device_attribute *ncm_function_attributes[] = {
-	&dev_attr_ncm_ethaddr,
-	NULL
-};
-
-static struct android_usb_function ncm_function = {
-	.name		= "ncm",
-	.init		= ncm_function_init,
-	.cleanup	= ncm_function_cleanup,
-	.bind_config	= ncm_function_bind_config,
-	.unbind_config	= ncm_function_unbind_config,
-	.attributes	= ncm_function_attributes,
-};
-#endif
-/* ecm transport string */
-static char ecm_transports[MAX_XPORT_STR_LEN];
-
-struct ecm_function_config {
-	u8      ethaddr[ETH_ALEN];
-};
-
-static int ecm_function_init(struct android_usb_function *f,
-				struct usb_composite_dev *cdev)
-{
-	f->config = kzalloc(sizeof(struct ecm_function_config), GFP_KERNEL);
-	if (!f->config)
-		return -ENOMEM;
-	return 0;
-}
-
-static void ecm_function_cleanup(struct android_usb_function *f)
-{
-	kfree(f->config);
-	f->config = NULL;
-}
-
-static int ecm_qc_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
-{
-	int ret;
-	char *trans;
-	struct ecm_function_config *ecm = f->config;
-
-	if (!ecm) {
-		pr_err("%s: ecm_pdata\n", __func__);
-		return -EINVAL;
-	}
-
-	pr_debug("%s: ecm_transport is %s", __func__, ecm_transports);
-
-	trans = strim(ecm_transports);
-	if (strcmp("BAM2BAM_IPA", trans)) {
-		ret = gether_qc_setup_name(c->cdev->gadget,
-						ecm->ethaddr, "ecm");
-		if (ret) {
-			pr_err("%s: gether_setup failed\n", __func__);
-			return ret;
-		}
-	}
-
-	return ecm_qc_bind_config(c, ecm->ethaddr, trans);
-}
-
-static void ecm_qc_function_unbind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	char *trans = strim(ecm_transports);
-
-	if (strcmp("BAM2BAM_IPA", trans))
-		gether_qc_cleanup_name("ecm0");
-}
-
-static ssize_t ecm_ethaddr_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct ecm_function_config *ecm = f->config;
-	return snprintf(buf, PAGE_SIZE, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		ecm->ethaddr[0], ecm->ethaddr[1], ecm->ethaddr[2],
-		ecm->ethaddr[3], ecm->ethaddr[4], ecm->ethaddr[5]);
-}
-
-static ssize_t ecm_ethaddr_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct ecm_function_config *ecm = f->config;
-
-	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		    (int *)&ecm->ethaddr[0], (int *)&ecm->ethaddr[1],
-		    (int *)&ecm->ethaddr[2], (int *)&ecm->ethaddr[3],
-		    (int *)&ecm->ethaddr[4], (int *)&ecm->ethaddr[5]) == 6)
-		return size;
-	return -EINVAL;
-}
-
-static DEVICE_ATTR(ecm_ethaddr, S_IRUGO | S_IWUSR, ecm_ethaddr_show,
-					       ecm_ethaddr_store);
-
-static ssize_t ecm_transports_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%s\n", ecm_transports);
-}
-
-static ssize_t ecm_transports_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	strlcpy(ecm_transports, buf, sizeof(ecm_transports));
-	return size;
-}
-
-static DEVICE_ATTR(ecm_transports, S_IRUGO | S_IWUSR, ecm_transports_show,
-					       ecm_transports_store);
-
-static struct device_attribute *ecm_function_attributes[] = {
-	&dev_attr_ecm_transports,
-	&dev_attr_ecm_ethaddr,
-	NULL
-};
-
-static struct android_usb_function ecm_qc_function = {
-	.name		= "ecm_qc",
-	.init		= ecm_function_init,
-	.cleanup	= ecm_function_cleanup,
-	.bind_config	= ecm_qc_function_bind_config,
-	.unbind_config	= ecm_qc_function_unbind_config,
-	.attributes	= ecm_function_attributes,
-};
-
-/* MBIM - used with BAM */
-#define MAX_MBIM_INSTANCES 1
-
-static int mbim_function_init(struct android_usb_function *f,
-					 struct usb_composite_dev *cdev)
-{
-	return mbim_init(MAX_MBIM_INSTANCES);
-}
-
-static void mbim_function_cleanup(struct android_usb_function *f)
-{
-	fmbim_cleanup();
-}
-
-
-/* mbim transport string */
-static char mbim_transports[MAX_XPORT_STR_LEN];
-
-static int mbim_function_bind_config(struct android_usb_function *f,
-					  struct usb_configuration *c)
-{
-	char *trans;
-
-	pr_debug("%s: mbim transport is %s", __func__, mbim_transports);
-	trans = strim(mbim_transports);
-	return mbim_bind_config(c, 0, trans);
-}
-
-static int mbim_function_ctrlrequest(struct android_usb_function *f,
-					struct usb_composite_dev *cdev,
-					const struct usb_ctrlrequest *c)
-{
-	return mbim_ctrlrequest(cdev, c);
-}
-
-static ssize_t mbim_transports_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%s\n", mbim_transports);
-}
-
-static ssize_t mbim_transports_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	strlcpy(mbim_transports, buf, sizeof(mbim_transports));
-	return size;
-}
-
-static DEVICE_ATTR(mbim_transports, S_IRUGO | S_IWUSR, mbim_transports_show,
-				   mbim_transports_store);
-
-static struct device_attribute *mbim_function_attributes[] = {
-	&dev_attr_mbim_transports,
-	NULL
-};
-
-static struct android_usb_function mbim_function = {
-	.name		= "usb_mbim",
-	.cleanup	= mbim_function_cleanup,
-	.bind_config	= mbim_function_bind_config,
-	.init		= mbim_function_init,
-	.ctrlrequest	= mbim_function_ctrlrequest,
-	.attributes		= mbim_function_attributes,
-};
-
-#ifdef CONFIG_SND_PCM
-/* PERIPHERAL AUDIO */
-static int audio_function_bind_config(struct android_usb_function *f,
-					  struct usb_configuration *c)
-{
-	return audio_bind_config(c);
-}
-
-static struct android_usb_function audio_function = {
-	.name		= "audio",
-	.bind_config	= audio_function_bind_config,
-};
-#endif
-
-
-/* DIAG */
-static char diag_clients[32];	    /*enabled DIAG clients- "diag[,diag_mdm]" */
-static ssize_t clients_store(
-		struct device *device, struct device_attribute *attr,
-		const char *buff, size_t size)
-{
-	strlcpy(diag_clients, buff, sizeof(diag_clients));
-
-	return size;
-}
-
-static DEVICE_ATTR(clients, S_IWUSR, NULL, clients_store);
-static struct device_attribute *diag_function_attributes[] =
-					 { &dev_attr_clients, NULL };
-
-static int diag_function_init(struct android_usb_function *f,
-				 struct usb_composite_dev *cdev)
-{
-	return diag_setup();
-}
-
-static void diag_function_cleanup(struct android_usb_function *f)
-{
-	diag_cleanup();
-}
-
-static int diag_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
-{
-	char *name;
-	char buf[32], *b;
-	int once = 0, err = -1;
-	int (*notify)(uint32_t, const char *);
-	struct android_dev *dev = cdev_to_android_dev(c->cdev);
-
-	strlcpy(buf, diag_clients, sizeof(buf));
-	b = strim(buf);
-
-	while (b) {
-		notify = NULL;
-		name = strsep(&b, ",");
-		/* Allow only first diag channel to update pid and serial no */
-		if (!once++) {
-			if (dev->pdata && dev->pdata->update_pid_and_serial_num)
-				notify = dev->pdata->update_pid_and_serial_num;
-			else
-				notify = usb_diag_update_pid_and_serial_num;
-		}
-
-		if (name) {
-			err = diag_function_add(c, name, notify);
-			if (err)
-				pr_err("diag: Cannot open channel '%s'", name);
-		}
-	}
-
-	return err;
-}
-
-static struct android_usb_function diag_function = {
-	.name		= "diag",
-	.init		= diag_function_init,
-	.cleanup	= diag_function_cleanup,
-	.bind_config	= diag_function_bind_config,
-	.attributes	= diag_function_attributes,
-};
-
-/* DEBUG */
-static int qdss_function_init(struct android_usb_function *f,
-	struct usb_composite_dev *cdev)
-{
-	return qdss_setup();
-}
-
-static void qdss_function_cleanup(struct android_usb_function *f)
-{
-	qdss_cleanup();
-}
-
-static int qdss_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
-{
-	int  err = -1;
-
-	err = qdss_bind_config(c, "qdss");
-	if (err)
-		pr_err("qdss: Cannot open channel qdss");
-
-	return err;
-}
-
-static struct android_usb_function qdss_function = {
-	.name		= "qdss",
-	.init		= qdss_function_init,
-	.cleanup	= qdss_function_cleanup,
-	.bind_config	= qdss_function_bind_config,
-};
-
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-/* SERIAL */
-static char serial_transports[32];	/*enabled FSERIAL ports - "tty[,sdio]"*/
-static ssize_t serial_transports_store(
-		struct device *device, struct device_attribute *attr,
-		const char *buff, size_t size)
-{
-	strlcpy(serial_transports, buff, sizeof(serial_transports));
-
-	return size;
-}
-
-/*enabled FSERIAL transport names - "serial_hsic[,serial_hsusb]"*/
-static char serial_xport_names[32];
-static ssize_t serial_xport_names_store(
-		struct device *device, struct device_attribute *attr,
-		const char *buff, size_t size)
-{
-	strlcpy(serial_xport_names, buff, sizeof(serial_xport_names));
-
-	return size;
-}
-
-static ssize_t serial_xport_names_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%s\n", serial_xport_names);
-}
-
-static DEVICE_ATTR(transports, S_IWUSR, NULL, serial_transports_store);
-static struct device_attribute dev_attr_serial_xport_names =
-				__ATTR(transport_names, S_IRUGO | S_IWUSR,
-				serial_xport_names_show,
-				serial_xport_names_store);
-
-static struct device_attribute *serial_function_attributes[] = {
-					&dev_attr_transports,
-					&dev_attr_serial_xport_names,
-					NULL };
-
-static void serial_function_cleanup(struct android_usb_function *f)
-{
-	gserial_cleanup();
-}
-
-static int serial_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
-{
-	char *name, *xport_name = NULL;
-	char buf[32], *b, xport_name_buf[32], *tb;
-	int err = -1, i;
-	static int serial_initialized = 0, ports = 0;
-
-	if (serial_initialized)
-		goto bind_config;
-
-	serial_initialized = 1;
-	strlcpy(buf, serial_transports, sizeof(buf));
-	b = strim(buf);
-
-	strlcpy(xport_name_buf, serial_xport_names, sizeof(xport_name_buf));
-	tb = strim(xport_name_buf);
-
-	while (b) {
-		name = strsep(&b, ",");
-
-		if (name) {
-			if (tb)
-				xport_name = strsep(&tb, ",");
-			err = gserial_init_port(ports, name, xport_name);
-			if (err) {
-				pr_err("serial: Cannot open port '%s'", name);
-				goto out;
-			}
-			ports++;
-		}
-	}
-	err = gport_setup(c);
-	if (err) {
-		pr_err("serial: Cannot setup transports");
-		goto out;
-	}
-
-bind_config:
-	for (i = 0; i < ports; i++) {
-		err = gser_bind_config(c, i);
-		if (err) {
-			pr_err("serial: bind_config failed for port %d", i);
-			goto out;
-		}
-	}
-
-out:
-	return err;
-}
-
-static struct android_usb_function serial_function = {
-	.name		= "serial",
-	.cleanup	= serial_function_cleanup,
-	.bind_config	= serial_function_bind_config,
-	.attributes	= serial_function_attributes,
-};
-#endif
-
-/* CCID */
-static int ccid_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
-{
-	return ccid_setup();
-}
-
-static void ccid_function_cleanup(struct android_usb_function *f)
-{
-	ccid_cleanup();
-}
-
-static int ccid_function_bind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	return ccid_bind_config(c);
-}
-
-static struct android_usb_function ccid_function = {
-	.name		= "ccid",
-	.init		= ccid_function_init,
-	.cleanup	= ccid_function_cleanup,
-	.bind_config	= ccid_function_bind_config,
-};
-
-static int
-mtp_function_init(struct android_usb_function *f,
-		struct usb_composite_dev *cdev)
-{
-	return mtp_setup();
-}
-
-static void mtp_function_cleanup(struct android_usb_function *f)
-{
-	mtp_cleanup();
-}
-
-static int
-mtp_function_bind_config(struct android_usb_function *f,
-		struct usb_configuration *c)
-{
-	return mtp_bind_config(c, false);
-}
-
-static int
-ptp_function_init(struct android_usb_function *f,
-		struct usb_composite_dev *cdev)
-{
-	/* nothing to do - initialization is handled by mtp_function_init */
-	return 0;
-}
-
-static void ptp_function_cleanup(struct android_usb_function *f)
-{
-	/* nothing to do - cleanup is handled by mtp_function_cleanup */
-}
-
-static int
-ptp_function_bind_config(struct android_usb_function *f,
-		struct usb_configuration *c)
-{
-	return mtp_bind_config(c, true);
-}
-
-static int mtp_function_ctrlrequest(struct android_usb_function *f,
-					struct usb_composite_dev *cdev,
-					const struct usb_ctrlrequest *c)
-{
-	return mtp_ctrlrequest(cdev, c);
-}
-
-static struct android_usb_function mtp_function = {
-	.name		= "mtp",
-	.init		= mtp_function_init,
-	.cleanup	= mtp_function_cleanup,
-	.bind_config	= mtp_function_bind_config,
-	.ctrlrequest	= mtp_function_ctrlrequest,
-};
-
-/* PTP function is same as MTP with slightly different interface descriptor */
-static struct android_usb_function ptp_function = {
-	.name		= "ptp",
-	.init		= ptp_function_init,
-	.cleanup	= ptp_function_cleanup,
-	.bind_config	= ptp_function_bind_config,
-	.ctrlrequest 	= mtp_function_ctrlrequest,
-};
-
-
-struct rndis_function_config {
-	u8      ethaddr[ETH_ALEN];
-	u32     vendorID;
-	u8      max_pkt_per_xfer;
-	char	manufacturer[256];
-	/* "Wireless" RNDIS; auto-detected by Windows */
-	bool	wceis;
-};
-
-static int
-rndis_function_init(struct android_usb_function *f,
-		struct usb_composite_dev *cdev)
-{
-	f->config = kzalloc(sizeof(struct rndis_function_config), GFP_KERNEL);
-	if (!f->config)
-		return -ENOMEM;
-	return 0;
-}
-
-static void rndis_function_cleanup(struct android_usb_function *f)
-{
-	kfree(f->config);
-	f->config = NULL;
-}
-
-static int rndis_qc_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
-{
-	f->config = kzalloc(sizeof(struct rndis_function_config), GFP_KERNEL);
-	if (!f->config)
-		return -ENOMEM;
-
-	return rndis_qc_init();
-}
-
-static void rndis_qc_function_cleanup(struct android_usb_function *f)
-{
-	rndis_qc_cleanup();
-	kfree(f->config);
-}
-
-static int
-rndis_function_bind_config(struct android_usb_function *f,
-		struct usb_configuration *c)
-{
-	int ret;
-	struct rndis_function_config *rndis = f->config;
-
-	if (!rndis) {
-		pr_err("%s: rndis_pdata\n", __func__);
-		return -1;
-	}
-
-	pr_info("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
-		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
-		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
-
-	ret = gether_setup_name(c->cdev->gadget, rndis->ethaddr, "rndis");
-	if (ret) {
-		pr_err("%s: gether_setup failed\n", __func__);
-		return ret;
-	}
-
-	if (rndis->wceis) {
-		/* "Wireless" RNDIS; auto-detected by Windows */
-		rndis_iad_descriptor.bFunctionClass =
-						USB_CLASS_WIRELESS_CONTROLLER;
-		rndis_iad_descriptor.bFunctionSubClass = 0x01;
-		rndis_iad_descriptor.bFunctionProtocol = 0x03;
-		rndis_control_intf.bInterfaceClass =
-						USB_CLASS_WIRELESS_CONTROLLER;
-		rndis_control_intf.bInterfaceSubClass =	 0x01;
-		rndis_control_intf.bInterfaceProtocol =	 0x03;
-	}
-
-	return rndis_bind_config_vendor(c, rndis->ethaddr, rndis->vendorID,
-					   rndis->manufacturer);
-}
-
-static int rndis_qc_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
-{
-	int ret;
-	struct rndis_function_config *rndis = f->config;
-
-	if (!rndis) {
-		pr_err("%s: rndis_pdata\n", __func__);
-		return -EINVAL;
-	}
-
-	pr_info("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
-		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
-		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
-
-	ret = gether_qc_setup_name(c->cdev->gadget, rndis->ethaddr, "rndis");
-	if (ret) {
-		pr_err("%s: gether_setup failed\n", __func__);
-		return ret;
-	}
-
-	if (rndis->wceis) {
-		/* "Wireless" RNDIS; auto-detected by Windows */
-		rndis_qc_iad_descriptor.bFunctionClass =
-						USB_CLASS_WIRELESS_CONTROLLER;
-		rndis_qc_iad_descriptor.bFunctionSubClass = 0x01;
-		rndis_qc_iad_descriptor.bFunctionProtocol = 0x03;
-		rndis_qc_control_intf.bInterfaceClass =
-						USB_CLASS_WIRELESS_CONTROLLER;
-		rndis_qc_control_intf.bInterfaceSubClass =	 0x01;
-		rndis_qc_control_intf.bInterfaceProtocol =	 0x03;
-	}
-
-	return rndis_qc_bind_config_vendor(c, rndis->ethaddr, rndis->vendorID,
-				    rndis->manufacturer,
-					rndis->max_pkt_per_xfer);
-}
-
-static void rndis_function_unbind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	gether_cleanup();
-}
-
-static void rndis_qc_function_unbind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	gether_qc_cleanup_name("rndis0");
-}
-
-static ssize_t rndis_manufacturer_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", config->manufacturer);
-}
-
-static ssize_t rndis_manufacturer_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-
-	if (size >= sizeof(config->manufacturer))
-		return -EINVAL;
-
-	if (sscanf(buf, "%255s", config->manufacturer) == 1)
-		return size;
-	return -1;
-}
-
-static DEVICE_ATTR(manufacturer, S_IRUGO | S_IWUSR, rndis_manufacturer_show,
-						    rndis_manufacturer_store);
-
-static ssize_t rndis_wceis_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", config->wceis);
-}
-
-static ssize_t rndis_wceis_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-	int value;
-
-	if (sscanf(buf, "%d", &value) == 1) {
-		config->wceis = value;
-		return size;
-	}
-	return -EINVAL;
-}
-
-static DEVICE_ATTR(wceis, S_IRUGO | S_IWUSR, rndis_wceis_show,
-					     rndis_wceis_store);
-
-static ssize_t rndis_ethaddr_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *rndis = f->config;
-
-	return snprintf(buf, PAGE_SIZE, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
-		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
-}
-
-static ssize_t rndis_ethaddr_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *rndis = f->config;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	int i;
-	char *src;
-	for (i = 0; i < ETH_ALEN; i++)
-			rndis->ethaddr[i] = 0;
-	/* create a fake MAC address from our serial number.
-	 * first byte is 0x02 to signify locally administered.
-	 */
-	rndis->ethaddr[0] = 0x02;
-	src = serial_string;
-	for (i = 0; (i < 256) && *src; i++) {
-		/* XOR the USB serial across the remaining bytes */
-		rndis->ethaddr[i % (ETH_ALEN - 1) + 1] ^= *src++;
-	}
-	return size;
-#else
-	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-		    (int *)&rndis->ethaddr[0], (int *)&rndis->ethaddr[1],
-		    (int *)&rndis->ethaddr[2], (int *)&rndis->ethaddr[3],
-		    (int *)&rndis->ethaddr[4], (int *)&rndis->ethaddr[5]) == 6)
-		return size;
-	return -EINVAL;
-#endif
-}
-
-static DEVICE_ATTR(ethaddr, S_IRUGO | S_IWUSR, rndis_ethaddr_show,
-					       rndis_ethaddr_store);
-
-static ssize_t rndis_vendorID_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-
-	return snprintf(buf, PAGE_SIZE, "%04x\n", config->vendorID);
-}
-
-static ssize_t rndis_vendorID_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-	int value;
-
-	if (sscanf(buf, "%04x", &value) == 1) {
-		config->vendorID = value;
-		return size;
-	}
-	return -EINVAL;
-}
-
-static DEVICE_ATTR(vendorID, S_IRUGO | S_IWUSR, rndis_vendorID_show,
-						rndis_vendorID_store);
-
-static ssize_t rndis_max_pkt_per_xfer_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-	return snprintf(buf, PAGE_SIZE, "%d\n", config->max_pkt_per_xfer);
-}
-
-static ssize_t rndis_max_pkt_per_xfer_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct rndis_function_config *config = f->config;
-	int value;
-
-	if (sscanf(buf, "%d", &value) == 1) {
-		config->max_pkt_per_xfer = value;
-		return size;
-	}
-	return -EINVAL;
-}
-
-static DEVICE_ATTR(max_pkt_per_xfer, S_IRUGO | S_IWUSR,
-				   rndis_max_pkt_per_xfer_show,
-				   rndis_max_pkt_per_xfer_store);
-
-static struct device_attribute *rndis_function_attributes[] = {
-	&dev_attr_manufacturer,
-	&dev_attr_wceis,
-	&dev_attr_ethaddr,
-	&dev_attr_vendorID,
-	&dev_attr_max_pkt_per_xfer,
-	NULL
-};
-
-static struct android_usb_function rndis_function = {
-	.name		= "rndis",
-	.init		= rndis_function_init,
-	.cleanup	= rndis_function_cleanup,
-	.bind_config	= rndis_function_bind_config,
-	.unbind_config	= rndis_function_unbind_config,
-	.attributes	= rndis_function_attributes,
-};
-
-static struct android_usb_function rndis_qc_function = {
-	.name		= "rndis_qc",
-	.init		= rndis_qc_function_init,
-	.cleanup	= rndis_qc_function_cleanup,
-	.bind_config	= rndis_qc_function_bind_config,
-	.unbind_config	= rndis_qc_function_unbind_config,
-	.attributes	= rndis_function_attributes,
-};
-
-static int ecm_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
-{
-	int ret;
-	struct ecm_function_config *ecm = f->config;
-
-	if (!ecm) {
-		pr_err("%s: ecm_pdata\n", __func__);
-		return -EINVAL;
-	}
-
-	ret = gether_setup_name(c->cdev->gadget, ecm->ethaddr, "ecm");
-	if (ret) {
-		pr_err("%s: gether_setup failed\n", __func__);
-		return ret;
-	}
-
-	ret = ecm_bind_config(c, ecm->ethaddr);
-	if (ret) {
-		pr_err("%s: ecm_bind_config failed\n", __func__);
-		gether_cleanup();
-	}
-	return ret;
-}
-
-static void ecm_function_unbind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	gether_cleanup();
-}
-
-static struct android_usb_function ecm_function = {
-	.name		= "ecm",
-	.init		= ecm_function_init,
-	.cleanup	= ecm_function_cleanup,
-	.bind_config	= ecm_function_bind_config,
-	.unbind_config	= ecm_function_unbind_config,
-	.attributes	= ecm_function_attributes,
-};
-
-struct mass_storage_function_config {
-	struct fsg_config fsg;
-	struct fsg_common *common;
-};
-
-static int mass_storage_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
-{
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	struct android_dev *dev = cdev_to_android_dev(cdev);
-#endif
-	struct mass_storage_function_config *config;
-	struct fsg_common *common;
-	int err;
-	int i;
-	const char *name[3];
-
-	config = kzalloc(sizeof(struct mass_storage_function_config),
-								GFP_KERNEL);
-	if (!config)
-		return -ENOMEM;
-
-	config->fsg.nluns = 1;
-	name[0] = "lun";
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	config->fsg.luns[0].cdrom = 1;
-	config->fsg.luns[0].ro = 0;
-	config->fsg.luns[0].removable = 1;
-#else
-	if (dev->pdata && dev->pdata->cdrom) {
-		config->fsg.luns[config->fsg.nluns].cdrom = 1;
-		config->fsg.luns[config->fsg.nluns].ro = 1;
-		config->fsg.luns[config->fsg.nluns].removable = 0;
-		name[config->fsg.nluns] = "lun0";
-		config->fsg.nluns++;
-	}
-	if (dev->pdata && dev->pdata->internal_ums) {
-		config->fsg.luns[config->fsg.nluns].cdrom = 0;
-		config->fsg.luns[config->fsg.nluns].ro = 0;
-		config->fsg.luns[config->fsg.nluns].removable = 1;
-		name[config->fsg.nluns] = "lun1";
-		config->fsg.nluns++;
-	}
-
-	config->fsg.luns[0].removable = 1;
-#endif
-
-	common = fsg_common_init(NULL, cdev, &config->fsg);
-	if (IS_ERR(common)) {
-		kfree(config);
-		return PTR_ERR(common);
-	}
-
-	for (i = 0; i < config->fsg.nluns; i++) {
-		err = sysfs_create_link(&f->dev->kobj,
-					&common->luns[i].dev.kobj,
-					name[i]);
-		if (err)
-			goto error;
-	}
-
-	config->common = common;
-	f->config = config;
-	return 0;
-error:
-	for (; i > 0 ; i--)
-		sysfs_remove_link(&f->dev->kobj, name[i-1]);
-
-	fsg_common_release(&common->ref);
-	kfree(config);
-	return err;
-}
-
-static void mass_storage_function_cleanup(struct android_usb_function *f)
-{
-	kfree(f->config);
-	f->config = NULL;
-}
-
-static int mass_storage_function_bind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	struct mass_storage_function_config *config = f->config;
-	return fsg_bind_config(c->cdev, c, config->common);
-}
-
-static ssize_t mass_storage_inquiry_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	return snprintf(buf, PAGE_SIZE, "%s\n", config->common->inquiry_string);
-}
-
-static ssize_t mass_storage_inquiry_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	if (size >= sizeof(config->common->inquiry_string))
-		return -EINVAL;
-	if (sscanf(buf, "%28s", config->common->inquiry_string) != 1)
-		return -EINVAL;
-	return size;
-}
-
-static DEVICE_ATTR(inquiry_string, S_IRUGO | S_IWUSR,
-					mass_storage_inquiry_show,
-					mass_storage_inquiry_store);
-
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-static ssize_t mass_storage_vendor_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	return sprintf(buf, "%s\n", config->common->vendor_string);
-}
-
-static ssize_t mass_storage_vendor_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-
-	if (size >= sizeof(config->common->vendor_string))
-		return -EINVAL;
-	if (sscanf(buf, "%s", config->common->vendor_string) != 1)
-		return -EINVAL;
-
-	printk(KERN_DEBUG "%s: vendor %s", __func__,
-				config->common->vendor_string);
-	return size;
-}
-
-static DEVICE_ATTR(vendor_string, S_IRUGO | S_IWUSR,
-					mass_storage_vendor_show,
-					mass_storage_vendor_store);
-
-static ssize_t mass_storage_product_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	return sprintf(buf, "%s\n", config->common->product_string);
-}
-
-static ssize_t mass_storage_product_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-
-	if (size >= sizeof(config->common->product_string))
-		return -EINVAL;
-	if (sscanf(buf, "%s", config->common->product_string) != 1)
-		return -EINVAL;
-
-	printk(KERN_DEBUG "%s: product %s", __func__,
-				config->common->product_string);
-	return size;
-}
-
-static DEVICE_ATTR(product_string, S_IRUGO | S_IWUSR,
-					mass_storage_product_show,
-					mass_storage_product_store);
-
-static ssize_t sua_version_info_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	int ret;
-
-	ret = sprintf(buf, "%s\r\n",config->common-> version_string);
-	printk(KERN_DEBUG "usb: %s version %s\n", __func__, buf);
-	return ret;
-}
-
-/*
- /sys/class/android_usb/android0/f_mass_storage/sua_version_info
-*/
-static ssize_t sua_version_info_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	int len=0;
-
-	if (size < sizeof(config->common-> version_string))
-		memcpy(config->common-> version_string,buf,size);
-	else
-	{
-		len=sizeof(config->common-> version_string);
-		memcpy(config->common-> version_string,buf,len-1);
-	}
-	printk(KERN_DEBUG "usb: %s buf=%s[%d], %s\n", __func__, buf,sizeof(buf),config->common-> version_string);
-	return size;
-}
-
-static DEVICE_ATTR(sua_version_info,  S_IRUGO | S_IWUSR,
-		sua_version_info_show, sua_version_info_store);
-#endif
-
-static struct device_attribute *mass_storage_function_attributes[] = {
-	&dev_attr_inquiry_string,
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	&dev_attr_vendor_string,
-	&dev_attr_product_string,
-	&dev_attr_sua_version_info,
-#endif
-	NULL
-};
-
-static struct android_usb_function mass_storage_function = {
-	.name		= "mass_storage",
-	.init		= mass_storage_function_init,
-	.cleanup	= mass_storage_function_cleanup,
-	.bind_config	= mass_storage_function_bind_config,
-	.attributes	= mass_storage_function_attributes,
-};
-
-
-static int accessory_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
-{
-	return acc_setup();
-}
-
-static void accessory_function_cleanup(struct android_usb_function *f)
-{
-	acc_cleanup();
-}
-
-static int accessory_function_bind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	return acc_bind_config(c);
-}
-
-static int accessory_function_ctrlrequest(struct android_usb_function *f,
-						struct usb_composite_dev *cdev,
-						const struct usb_ctrlrequest *c)
-{
-	return acc_ctrlrequest(cdev, c);
-}
-
-static struct android_usb_function accessory_function = {
-	.name		= "accessory",
-	.init		= accessory_function_init,
-	.cleanup	= accessory_function_cleanup,
-	.bind_config	= accessory_function_bind_config,
-	.ctrlrequest	= accessory_function_ctrlrequest,
-};
-
-#ifdef CONFIG_SND_PCM
-static int audio_source_function_init(struct android_usb_function *f,
-			struct usb_composite_dev *cdev)
-{
-	struct audio_source_config *config;
-
-	config = kzalloc(sizeof(struct audio_source_config), GFP_KERNEL);
-	if (!config)
-		return -ENOMEM;
-	config->card = -1;
-	config->device = -1;
-	f->config = config;
-	return 0;
-}
-
-static void audio_source_function_cleanup(struct android_usb_function *f)
-{
-	kfree(f->config);
-}
-
-static int audio_source_function_bind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	struct audio_source_config *config = f->config;
-
-	return audio_source_bind_config(c, config);
-}
-
-static void audio_source_function_unbind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	struct audio_source_config *config = f->config;
-
-	config->card = -1;
-	config->device = -1;
-}
-
-static ssize_t audio_source_pcm_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct audio_source_config *config = f->config;
-
-	/* print PCM card and device numbers */
-	return snprintf(buf, PAGE_SIZE,
-			"%d %d\n", config->card, config->device);
-}
-
-static DEVICE_ATTR(pcm, S_IRUGO | S_IWUSR, audio_source_pcm_show, NULL);
-
-static struct device_attribute *audio_source_function_attributes[] = {
-	&dev_attr_pcm,
-	NULL
-};
-
-static struct android_usb_function audio_source_function = {
-	.name		= "audio_source",
-	.init		= audio_source_function_init,
-	.cleanup	= audio_source_function_cleanup,
-	.bind_config	= audio_source_function_bind_config,
-	.unbind_config	= audio_source_function_unbind_config,
-	.attributes	= audio_source_function_attributes,
-};
-#endif
-
-static int android_uasp_connect_cb(bool connect)
-{
-	/*
-	 * TODO
-	 * We may have to disable gadget till UASP configfs nodes
-	 * are configured which includes mapping LUN with the
-	 * backing file. It is a fundamental difference between
-	 * f_mass_storage and f_tcp. That means UASP can not be
-	 * in default composition.
-	 *
-	 * For now, assume that UASP configfs nodes are configured
-	 * before enabling android gadget. Or cable should be
-	 * reconnected after mapping the LUN.
-	 *
-	 * Also consider making UASP to respond to Host requests when
-	 * Lun is not mapped.
-	 */
-	pr_debug("UASP %s\n", connect ? "connect" : "disconnect");
-
-	return 0;
-}
-
-static int uasp_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
-{
-	return f_tcm_init(&android_uasp_connect_cb);
-}
-
-static void uasp_function_cleanup(struct android_usb_function *f)
-{
-	f_tcm_exit();
-}
-
-static int uasp_function_bind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-	return tcm_bind_config(c);
-}
-
-static struct android_usb_function uasp_function = {
-	.name		= "uasp",
-	.init		= uasp_function_init,
-	.cleanup	= uasp_function_cleanup,
-	.bind_config	= uasp_function_bind_config,
-};
-
-static struct android_usb_function *supported_functions[] = {
-	&ffs_function,
-	&mbim_function,
-	&ecm_qc_function,
-#ifdef CONFIG_SND_PCM
-	&audio_function,
-#endif
-	&rmnet_smd_function,
-	&rmnet_sdio_function,
-	&rmnet_smd_sdio_function,
-	&rmnet_function,
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	&gps_function,
-#endif
-	&diag_function,
-	&qdss_function,
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	&serial_function,
-#endif
-	&adb_function,
-#ifdef CONFIG_SND_RAWMIDI
-	&midi_function,
-#endif
-	&ccid_function,
-	&acm_function,
-	&mtp_function,
-	&ptp_function,
-	&rndis_function,
-	&rndis_qc_function,
-	&ecm_function,
-	&ncm_function,
-	&mass_storage_function,
-	&accessory_function,
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_SIDESYNC
-	&conn_gadget_function,
-#endif
-#ifdef CONFIG_SND_PCM
-	&audio_source_function,
-#endif
-	&uasp_function,
-	NULL
-};
-
-static void android_cleanup_functions(struct android_usb_function **functions)
-{
-	struct android_usb_function *f;
-	struct device_attribute **attrs;
-	struct device_attribute *attr;
-
-	while (*functions) {
-		f = *functions++;
-
-		if (f->dev) {
-			device_destroy(android_class, f->dev->devt);
-			kfree(f->dev_name);
-		} else
-			continue;
-
-		if (f->cleanup)
-			f->cleanup(f);
-
-		attrs = f->attributes;
-		if (attrs) {
-			while ((attr = *attrs++))
-				device_remove_file(f->dev, attr);
-		}
-	}
-}
-
-static int android_init_functions(struct android_usb_function **functions,
-				  struct usb_composite_dev *cdev)
-{
-	struct android_dev *dev = cdev_to_android_dev(cdev);
-	struct android_usb_function *f;
-	struct device_attribute **attrs;
-	struct device_attribute *attr;
-	int err = 0;
-	int index = 1; /* index 0 is for android0 device */
-
-	for (; (f = *functions++); index++) {
-		f->dev_name = kasprintf(GFP_KERNEL, "f_%s", f->name);
-		f->android_dev = NULL;
-		if (!f->dev_name) {
-			err = -ENOMEM;
-			goto err_out;
-		}
-		f->dev = device_create(android_class, dev->dev,
-				MKDEV(0, index), f, f->dev_name);
-		if (IS_ERR(f->dev)) {
-			pr_err("%s: Failed to create dev %s", __func__,
-							f->dev_name);
-			err = PTR_ERR(f->dev);
-			f->dev = NULL;
-			goto err_create;
-		}
-
-		if (f->init) {
-			err = f->init(f, cdev);
-			if (err) {
-				pr_err("%s: Failed to init %s", __func__,
-								f->name);
-				goto err_init;
-			}
-		}
-
-		attrs = f->attributes;
-		if (attrs) {
-			while ((attr = *attrs++) && !err)
-				err = device_create_file(f->dev, attr);
-		}
-		if (err) {
-			pr_err("%s: Failed to create function %s attributes",
-					__func__, f->name);
-			goto err_attrs;
-		}
-	}
-	return 0;
-
-err_attrs:
-	for (attr = *(attrs -= 2); attrs != f->attributes; attr = *(attrs--))
-		device_remove_file(f->dev, attr);
-	if (f->cleanup)
-		f->cleanup(f);
-err_init:
-	device_destroy(android_class, f->dev->devt);
-err_create:
-	f->dev = NULL;
-	kfree(f->dev_name);
-err_out:
-	android_cleanup_functions(dev->functions);
-	return err;
-}
-
-static int
-android_bind_enabled_functions(struct android_dev *dev,
-			       struct usb_configuration *c)
-{
-	struct android_usb_function_holder *f_holder;
-	struct android_configuration *conf =
-		container_of(c, struct android_configuration, usb_config);
-	int ret;
-
-	list_for_each_entry(f_holder, &conf->enabled_functions, enabled_list) {
-		ret = f_holder->f->bind_config(f_holder->f, c);
-		if (ret) {
-			pr_err("%s: %s failed\n", __func__, f_holder->f->name);
-			while (!list_empty(&c->functions)) {
-				struct usb_function		*f;
-
-				f = list_first_entry(&c->functions,
-					struct usb_function, list);
-				list_del(&f->list);
-				if (f->unbind)
-					f->unbind(c, f);
-			}
-			if (c->unbind)
-				c->unbind(c);
-			return ret;
-		}
-	}
-	return 0;
-}
-
-static void
-android_unbind_enabled_functions(struct android_dev *dev,
-			       struct usb_configuration *c)
-{
-	struct android_usb_function_holder *f_holder;
-	struct android_configuration *conf =
-		container_of(c, struct android_configuration, usb_config);
-
-	list_for_each_entry(f_holder, &conf->enabled_functions, enabled_list) {
-		if (f_holder->f->unbind_config)
-			f_holder->f->unbind_config(f_holder->f, c);
-	}
-}
-
-static inline void check_streaming_func(struct usb_gadget *gadget,
-		struct android_usb_platform_data *pdata,
-		char *name)
-{
-	int i;
-
-	for (i = 0; i < pdata->streaming_func_count; i++) {
-		if (!strcmp(name,
-			pdata->streaming_func[i])) {
-			pr_debug("set streaming_enabled to true\n");
-			gadget->streaming_enabled = true;
-			break;
-		}
-	}
-}
-
-static int android_enable_function(struct android_dev *dev,
-				   struct android_configuration *conf,
-				   char *name)
-{
-	struct android_usb_function **functions = dev->functions;
-	struct android_usb_function *f;
-	struct android_usb_function_holder *f_holder;
-	struct android_usb_platform_data *pdata = dev->pdata;
-	struct usb_gadget *gadget = dev->cdev->gadget;
-
-	while ((f = *functions++)) {
-		if (!strcmp(name, f->name)) {
-			if (f->android_dev && f->android_dev != dev)
-				pr_err("%s is enabled in other device\n",
-					f->name);
-			else {
-				f_holder = kzalloc(sizeof(*f_holder),
-						GFP_KERNEL);
-				if (!f_holder) {
-					pr_err("Failed to alloc f_holder\n");
-					return -ENOMEM;
-				}
-
-				f->android_dev = dev;
-				f_holder->f = f;
-				list_add_tail(&f_holder->enabled_list,
-					      &conf->enabled_functions);
-				pr_debug("func:%s is enabled.\n", f->name);
-				/*
-				 * compare enable function with streaming func
-				 * list and based on the same request streaming.
-				 */
-				check_streaming_func(gadget, pdata, f->name);
-
-				return 0;
-			}
-		}
-	}
-	return -EINVAL;
-}
-
-/*-------------------------------------------------------------------------*/
-/* /sys/class/android_usb/android%d/ interface */
-
-static ssize_t remote_wakeup_show(struct device *pdev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	struct android_configuration *conf;
-
-	/*
-	 * Show the wakeup attribute of the first configuration,
-	 * since all configurations have the same wakeup attribute
-	 */
-	if (dev->configs_num == 0)
-		return 0;
-	conf = list_entry(dev->configs.next,
-			  struct android_configuration,
-			  list_item);
-
-	return snprintf(buf, PAGE_SIZE, "%d\n",
-			!!(conf->usb_config.bmAttributes &
-				USB_CONFIG_ATT_WAKEUP));
-}
-
-static ssize_t remote_wakeup_store(struct device *pdev,
-		struct device_attribute *attr, const char *buff, size_t size)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	struct android_configuration *conf;
-	int enable = 0;
-
-	sscanf(buff, "%d", &enable);
-
-	pr_debug("android_usb: %s remote wakeup\n",
-			enable ? "enabling" : "disabling");
-
-	list_for_each_entry(conf, &dev->configs, list_item)
-		if (enable)
-			conf->usb_config.bmAttributes |=
-					USB_CONFIG_ATT_WAKEUP;
-		else
-			conf->usb_config.bmAttributes &=
-					~USB_CONFIG_ATT_WAKEUP;
-
-	return size;
-}
-
-static ssize_t
-functions_show(struct device *pdev, struct device_attribute *attr, char *buf)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	struct android_configuration *conf;
-	struct android_usb_function_holder *f_holder;
-	char *buff = buf;
-
-	mutex_lock(&dev->mutex);
-
-	list_for_each_entry(conf, &dev->configs, list_item) {
-		if (buff != buf)
-			*(buff-1) = ':';
-		list_for_each_entry(f_holder, &conf->enabled_functions,
-					enabled_list)
-			buff += snprintf(buff, PAGE_SIZE, "%s,",
-					f_holder->f->name);
-	}
-
-	mutex_unlock(&dev->mutex);
-
-	if (buff != buf)
-		*(buff-1) = '\n';
-	return buff - buf;
-}
-
-static ssize_t
-functions_store(struct device *pdev, struct device_attribute *attr,
-			       const char *buff, size_t size)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	struct list_head *curr_conf = &dev->configs;
-	struct android_configuration *conf;
-	char *conf_str;
-	struct android_usb_function_holder *f_holder;
-	char *name;
-	char buf[256], *b;
-	char aliases[256], *a;
-	int err;
-	int is_ffs;
-	int ffs_enabled = 0;
-
-	mutex_lock(&dev->mutex);
-
-	if (dev->enabled) {
-		mutex_unlock(&dev->mutex);
-		return -EBUSY;
-	}
-
-	/* Clear previous enabled list */
-	list_for_each_entry(conf, &dev->configs, list_item) {
-		while (conf->enabled_functions.next !=
-				&conf->enabled_functions) {
-			f_holder = list_entry(conf->enabled_functions.next,
-					typeof(*f_holder),
-					enabled_list);
-			f_holder->f->android_dev = NULL;
-			list_del(&f_holder->enabled_list);
-			kfree(f_holder);
-		}
-		INIT_LIST_HEAD(&conf->enabled_functions);
-	}
-
-	strlcpy(buf, buff, sizeof(buf));
-	b = strim(buf);
-
-	while (b) {
-		conf_str = strsep(&b, ":");
-		if (conf_str) {
-			/* If the next not equal to the head, take it */
-			if (curr_conf->next != &dev->configs)
-				conf = list_entry(curr_conf->next,
-						  struct android_configuration,
-						  list_item);
-			else
-				conf = alloc_android_config(dev);
-
-			curr_conf = curr_conf->next;
-		}
-
-		while (conf_str) {
-			name = strsep(&conf_str, ",");
-
-			is_ffs = 0;
-			strlcpy(aliases, dev->ffs_aliases, sizeof(aliases));
-			a = aliases;
-
-
-			while (a) {
-				char *alias = strsep(&a, ",");
-				if (alias && !strcmp(name, alias)) {
-					is_ffs = 1;
-					break;
-				}
-			}
-
-			if (is_ffs) {
-				if (ffs_enabled)
-					continue;
-				err = android_enable_function(dev, conf, "ffs");
-				if (err)
-					pr_err("android_usb: Cannot enable ffs (%d)",
-						err);
-				else
-					ffs_enabled = 1;
-				continue;
-			}
-
-			err = android_enable_function(dev, conf, name);
-			if (err)
-				pr_err("android_usb: Cannot enable '%s' (%d)",
-								   name, err);
-		}
-	}
-
-	/* Free uneeded configurations if exists */
-	while (curr_conf->next != &dev->configs) {
-		conf = list_entry(curr_conf->next,
-				  struct android_configuration, list_item);
-		free_android_config(dev, conf);
-	}
-
-	mutex_unlock(&dev->mutex);
-
-	return size;
-}
-
-static ssize_t enable_show(struct device *pdev, struct device_attribute *attr,
-			   char *buf)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	printk(KERN_DEBUG "usb: %s dev->enabled=%d\n", __func__,  dev->enabled);
-	return snprintf(buf, PAGE_SIZE, "%d\n", dev->enabled);
-}
-
-static ssize_t enable_store(struct device *pdev, struct device_attribute *attr,
-			    const char *buff, size_t size)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	struct usb_composite_dev *cdev = dev->cdev;
-	struct android_usb_function_holder *f_holder;
-	struct android_configuration *conf;
-	int enabled = 0;
-	bool audio_enabled = false;
-	static DEFINE_RATELIMIT_STATE(rl, 10*HZ, 1);
-	int err = 0;
-
-	if (!cdev)
-		return -ENODEV;
-
-	mutex_lock(&dev->mutex);
-
-	sscanf(buff, "%d", &enabled);
-	printk(KERN_INFO "usb: enabled: %d, dev->enabled: %d\n",
-			enabled, dev->enabled);
-	if (enabled && !dev->enabled) {
-		/*
-		 * Update values in composite driver's copy of
-		 * device descriptor.
-		 */
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-		cdev->next_string_id = composite_string_index;
-		strncpy(manufacturer_string, "SAMSUNG",
-				sizeof(manufacturer_string) - 1);
-		strncpy(product_string, "SAMSUNG_Android",
-				sizeof(product_string) - 1);
-#else
-		cdev->next_string_id = 0;
-#endif
-		cdev->desc.idVendor = device_desc.idVendor;
-		cdev->desc.idProduct = device_desc.idProduct;
-		cdev->desc.bcdDevice = device_desc.bcdDevice;
-		cdev->desc.bDeviceClass = device_desc.bDeviceClass;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-		list_for_each_entry(conf, &dev->configs, list_item)
-			list_for_each_entry(f_holder, &conf->enabled_functions,
-						enabled_list) {
-				printk(KERN_DEBUG "usb: %s f_holder->f:%s\n",
-					__func__, f_holder->f->name);
-				if (!strcmp(f_holder->f->name, "acm")) {
-					printk(KERN_DEBUG "usb: acm is enabled. (bcdDevice=0x400)\n");
-					/* Samsung KIES needs fixed bcdDevice number */
-					cdev->desc.bcdDevice = cpu_to_le16(0x0400);
-				}
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_SIDESYNC
-				if (!strcmp(f_holder->f->name, "conn_gadget")) {
-					if(cdev->desc.bcdDevice == cpu_to_le16(0x0400))	{
-						printk(KERN_DEBUG "usb: conn_gadget + kies (bcdDevice=0xC00)\n");
-						cdev->desc.bcdDevice = cpu_to_le16(0x0C00);
-					} else {
-						printk(KERN_DEBUG "usb: conn_gadget only (bcdDevice=0x800)\n");
-						cdev->desc.bcdDevice = cpu_to_le16(0x0800);
-					}
-				}
-#endif
-			}
-		strncpy(manufacturer_string, "SAMSUNG", sizeof(manufacturer_string) - 1);
-		strncpy(product_string, "SAMSUNG_Android", sizeof(product_string) - 1);
-#endif
-		cdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;
-		cdev->desc.bDeviceProtocol = device_desc.bDeviceProtocol;
-
-		printk(KERN_DEBUG "usb: %s vendor=%x,product=%x,bcdDevice=%x",
-				__func__, cdev->desc.idVendor,
-				cdev->desc.idProduct, cdev->desc.bcdDevice);
-		printk(KERN_DEBUG ",Class=%x,SubClass=%x,Protocol=%x\n",
-				cdev->desc.bDeviceClass,
-				cdev->desc.bDeviceSubClass,
-				cdev->desc.bDeviceProtocol);
-		printk(KERN_DEBUG "usb: %s next cmd : usb_add_config\n",
-				__func__);
-
-		/* Audio dock accessory is unable to enumerate device if
-		 * pull-up is enabled immediately. The enumeration is
-		 * reliable with 100 msec delay.
-		 */
-		list_for_each_entry(conf, &dev->configs, list_item)
-			list_for_each_entry(f_holder, &conf->enabled_functions,
-						enabled_list) {
-				if (f_holder->f->enable)
-					f_holder->f->enable(f_holder->f);
-				if (!strncmp(f_holder->f->name,
-						"audio_source", 12))
-					audio_enabled = true;
-			}
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-		if (audio_enabled)
-			msleep(100);
-#endif
-		err = android_enable(dev);
-		if (err < 0) {
-			pr_err("%s: android_enable failed\n", __func__);
-			dev->connected = 0;
-			dev->enabled = false;
-			mutex_unlock(&dev->mutex);
-			return size;
-		}
-		dev->enabled = true;
-	} else if (!enabled && dev->enabled) {
-		android_disable(dev);
-		list_for_each_entry(conf, &dev->configs, list_item)
-			list_for_each_entry(f_holder, &conf->enabled_functions,
-						enabled_list) {
-				if (f_holder->f->disable)
-					f_holder->f->disable(f_holder->f);
-			}
-		dev->enabled = false;
-	} else if (!enabled) {
-		usb_gadget_disconnect(cdev->gadget);
-		dev->enabled = false;
-	} else if (__ratelimit(&rl)) {
-		pr_err("android_usb: already %s\n",
-				dev->enabled ? "enabled" : "disabled");
-	}
-
-	mutex_unlock(&dev->mutex);
-
-	return size;
-}
-
-static ssize_t pm_qos_show(struct device *pdev,
-			   struct device_attribute *attr, char *buf)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", dev->pm_qos);
-}
-
-static ssize_t pm_qos_store(struct device *pdev,
-			   struct device_attribute *attr,
-			   const char *buff, size_t size)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-
-	strlcpy(dev->pm_qos, buff, sizeof(dev->pm_qos));
-
-	return size;
-}
-
-static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
-			   char *buf)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	struct usb_composite_dev *cdev = dev->cdev;
-	char *state = "DISCONNECTED";
-	unsigned long flags;
-
-	if (!cdev)
-		goto out;
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (cdev->config)
-		state = "CONFIGURED";
-	else if (dev->connected)
-		state = "CONNECTED";
-	spin_unlock_irqrestore(&cdev->lock, flags);
-out:
-	printk(KERN_DEBUG "usb: %s buf=%s\n", __func__, state);
-	return snprintf(buf, PAGE_SIZE, "%s\n", state);
-}
-
-#define DESCRIPTOR_ATTR(field, format_string)				\
-static ssize_t								\
-field ## _show(struct device *dev, struct device_attribute *attr,	\
-		char *buf)						\
-{									\
-	return snprintf(buf, PAGE_SIZE,					\
-			format_string, device_desc.field);		\
-}									\
-static ssize_t								\
-field ## _store(struct device *dev, struct device_attribute *attr,	\
-		const char *buf, size_t size)				\
-{									\
-	int value;							\
-	if (sscanf(buf, format_string, &value) == 1) {			\
-		device_desc.field = value;				\
-		return size;						\
-	}								\
-	return -1;							\
-}									\
-static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
-
-#define DESCRIPTOR_STRING_ATTR(field, buffer)				\
-static ssize_t								\
-field ## _show(struct device *dev, struct device_attribute *attr,	\
-		char *buf)						\
-{									\
-	return snprintf(buf, PAGE_SIZE, "%s", buffer);			\
-}									\
-static ssize_t								\
-field ## _store(struct device *dev, struct device_attribute *attr,	\
-		const char *buf, size_t size)				\
-{									\
-	if (size >= sizeof(buffer))					\
-		return -EINVAL;						\
-	strlcpy(buffer, buf, sizeof(buffer));				\
-	strim(buffer);							\
-	return size;							\
-}									\
-static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
-
-
-DESCRIPTOR_ATTR(idVendor, "%04x\n")
-DESCRIPTOR_ATTR(idProduct, "%04x\n")
-DESCRIPTOR_ATTR(bcdDevice, "%04x\n")
-DESCRIPTOR_ATTR(bDeviceClass, "%d\n")
-DESCRIPTOR_ATTR(bDeviceSubClass, "%d\n")
-DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n")
-DESCRIPTOR_STRING_ATTR(iManufacturer, manufacturer_string)
-DESCRIPTOR_STRING_ATTR(iProduct, product_string)
-DESCRIPTOR_STRING_ATTR(iSerial, serial_string)
-
-static ssize_t
-bcdUSB_show(struct device *pdev, struct device_attribute *attr, char *buf)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-
-	if(dev->cdev) {
-		return sprintf(buf, "%04x\n", dev->cdev->desc.bcdUSB);
-	} else {
-		return sprintf(buf, "%04x\n", device_desc.bcdUSB);
-	}
-}
-
-#if defined(CONFIG_SEC_H_PROJECT) || defined(CONFIG_SEC_F_PROJECT) || defined(CONFIG_SEC_K_PROJECT)
-static ssize_t
-usb30en_show(struct device *pdev, struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%01x\n", usb30en);
-}
-
-extern void set_redriver_power(int on);
-static ssize_t usb30en_store (struct device *pdev,
-			struct device_attribute *attr,
-			const char *buf, size_t size)
-{
-	int value;
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	if(get_host_os_type() == 0) {
-		usb30en = 0;
-		printk(KERN_ERR "usb: %s MAC host is always disabled \n", __func__);
-		return size;
-	}
-	if (sscanf(buf, "%d", &value) == 1) {
-		if (dev->cdev ) {
-			if(usb30en == value){
-				printk(KERN_INFO "usb: %s ignore!! usb30en(%d), value(%d)\n",
-						__func__, usb30en, value);
-				return size;
-			}
-			usb30en = value;
-			usb_gadget_disconnect(dev->cdev->gadget);
-			sec_set_speedlimit(dev->cdev->gadget,
-					(usb30en ? USB_SPEED_SUPER : USB_SPEED_HIGH));
-			printk(KERN_DEBUG "usb: %s B4 disconectng gadget\n", __func__);
-			msleep(200);
-#if defined(CONFIG_SEC_H_PROJECT)
-			if (!usb30en)
-				schedule_usb_gadget_connect_work(dev);
-			else
-#endif
-			usb_gadget_connect(dev->cdev->gadget);
-			printk(KERN_DEBUG "usb: %s after usb_gadget_connect\n",	__func__);
-			return size;
-		}
-	}
-	printk(KERN_ERR "usb: %s Failed to set the usb30_en value\n", __func__);
-	return -1;
-}
-
-static ssize_t ss_host_available_show(struct device *pdev,
-				struct device_attribute *attr, char *buf)
-{
-	int value = 0;
-	int ss_host_available;
-	int windowsos;
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	if (dev->cdev ) {
-		ss_host_available = sec_get_ss_host_available(dev->cdev->gadget);
-		windowsos = get_host_os_type();
-		if((ss_host_available == 1) && ( windowsos == 1)) {
-			printk(KERN_ERR "usb: %s superspeed available \n", __func__);
-			value = 1;
-		}
-		printk(KERN_ERR "usb: %s ss_host_available(%d), windowsos(%d)\n",
-			__func__, ss_host_available, windowsos);
-	} else {
-		printk(KERN_ERR "usb: %s gadget not available \n", __func__);
-		value = -1;
-	}
-	return sprintf(buf, "%d\n", value);
-}
-
-static ssize_t macos_show(struct device *pdev,
-			struct device_attribute *attr, char *buf)
-{
-	int value = 1;
-	int ss_host_available;
-	int windowsos;
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	if (dev->cdev ) {
-		ss_host_available = sec_get_ss_host_available(dev->cdev->gadget);
-		windowsos = get_host_os_type();
-		if((ss_host_available == 1) && ( windowsos == 1)) {
-			printk(KERN_ERR "usb: %s superspeed available \n", __func__);
-			value = 0;
-		}
-		printk(KERN_ERR "usb: %s ss_host_available(%d), windowsos(%d)\n",
-			__func__, ss_host_available, windowsos);
-	} else {
-		printk(KERN_ERR "usb: %s gadget not available \n", __func__);
-		value = -1;
-	}
-	return sprintf(buf, "%d\n", value);
-}
-#endif
-
-#ifdef CONFIG_USB_LOCK_SUPPORT_FOR_MDM
-static ssize_t show_usb_device_lock_state(struct device *pdev,
-		struct device_attribute *attr, char *buf)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-
-	if (!dev->usb_lock)
-		return snprintf(buf, PAGE_SIZE, "USB_UNLOCK\n");
-	else
-		return snprintf(buf, PAGE_SIZE, "USB_LOCK\n");
-}
-
-static ssize_t store_usb_device_lock_state(struct device *pdev,
-		struct device_attribute *attr, const char *buff, size_t count)
-{
-	struct android_dev *dev = dev_get_drvdata(pdev);
-	struct power_supply *psy;
-
-	psy = power_supply_get_by_name("dwc-usb");
-
-	if (!psy) {
-		pr_info("%s: couldn't get usb power supply\n", __func__);
-		return -EINVAL;
-	}
-
-	if (!strncmp(buff, "0", 1)){
-		mutex_lock(&dev->mutex);
-		dev->usb_lock = 0;
-		android_enable(dev);
-		mutex_unlock(&dev->mutex);
-	} else if (!strncmp(buff, "1", 1)){
-		mutex_lock(&dev->mutex);
-		dev->usb_lock = 1;
-		android_disable(dev);
-		mutex_unlock(&dev->mutex);
-	} else {
-		pr_warn("%s: Wrong command\n", __func__);
-		return count;
-	}
-
-	if(dev->usb_lock) {
-		power_supply_set_present(psy, 0);
-		pr_info("[%s][%d] : usb disconnect for support MDM\n",
-			__func__,__LINE__);
-	}
-
-	return count;
-}
-#endif
-
-
-static DEVICE_ATTR(bcdUSB, S_IRUGO | S_IWUSR, bcdUSB_show, NULL);
-#if defined(CONFIG_SEC_H_PROJECT) || defined(CONFIG_SEC_F_PROJECT) || defined(CONFIG_SEC_K_PROJECT)
-static DEVICE_ATTR(usb30en,S_IRUGO | S_IWUSR, usb30en_show, usb30en_store);
-static DEVICE_ATTR(ss_host_available,S_IRUGO | S_IWUSR, ss_host_available_show, NULL);
-static DEVICE_ATTR(macos,S_IRUGO | S_IWUSR, macos_show, NULL);
-#endif
-static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show,
-						 functions_store);
-static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
-static DEVICE_ATTR(pm_qos, S_IRUGO | S_IWUSR,
-		pm_qos_show, pm_qos_store);
-static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
-static DEVICE_ATTR(remote_wakeup, S_IRUGO | S_IWUSR,
-		remote_wakeup_show, remote_wakeup_store);
-
-#ifdef CONFIG_USB_LOCK_SUPPORT_FOR_MDM
-static DEVICE_ATTR(usb_lock, S_IRUGO | S_IWUSR,
-		show_usb_device_lock_state, store_usb_device_lock_state);
-#endif
-
-static struct device_attribute *android_usb_attributes[] = {
-	&dev_attr_idVendor,
-	&dev_attr_idProduct,
-	&dev_attr_bcdDevice,
-	&dev_attr_bDeviceClass,
-	&dev_attr_bDeviceSubClass,
-	&dev_attr_bDeviceProtocol,
-	&dev_attr_iManufacturer,
-	&dev_attr_iProduct,
-	&dev_attr_iSerial,
-	&dev_attr_functions,
-	&dev_attr_enable,
-	&dev_attr_pm_qos,
-	&dev_attr_state,
-	&dev_attr_bcdUSB,
-#if defined(CONFIG_SEC_H_PROJECT) || defined(CONFIG_SEC_F_PROJECT) || defined(CONFIG_SEC_K_PROJECT)
-	&dev_attr_usb30en,
-	&dev_attr_ss_host_available,
-	&dev_attr_macos,
-#endif
-	&dev_attr_remote_wakeup,
-#ifdef CONFIG_USB_LOCK_SUPPORT_FOR_MDM
-	&dev_attr_usb_lock,
-#endif
-	NULL
-};
-
-/*-------------------------------------------------------------------------*/
-/* Composite driver */
-
-static int android_bind_config(struct usb_configuration *c)
-{
-	struct android_dev *dev = cdev_to_android_dev(c->cdev);
-	int ret = 0;
-
-	ret = android_bind_enabled_functions(dev, c);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static void android_unbind_config(struct usb_configuration *c)
-{
-	struct android_dev *dev = cdev_to_android_dev(c->cdev);
-
-	if (c->cdev->gadget->streaming_enabled) {
-		c->cdev->gadget->streaming_enabled = false;
-		pr_debug("setting streaming_enabled to false.\n");
-	}
-	android_unbind_enabled_functions(dev, c);
-}
-
-static int android_bind(struct usb_composite_dev *cdev)
-{
-	struct android_dev *dev;
-	struct usb_gadget	*gadget = cdev->gadget;
-	struct android_configuration *conf;
-	int			gcnum, id, ret;
-
-	/* Bind to the last android_dev that was probed */
-	dev = list_entry(android_dev_list.prev, struct android_dev, list_item);
-
-	dev->cdev = cdev;
-
-	printk(KERN_DEBUG "usb: %s disconnect\n", __func__);
-	/*
-	 * Start disconnected. Userspace will connect the gadget once
-	 * it is done configuring the functions.
-	 */
-	usb_gadget_disconnect(gadget);
-
-	/* Init the supported functions only once, on the first android_dev */
-	if (android_dev_count == 1) {
-		ret = android_init_functions(dev->functions, cdev);
-		if (ret)
-			return ret;
-	}
-
-	/* Allocate string descriptor numbers ... note that string
-	 * contents can be overridden by the composite_dev glue.
-	 */
-	id = usb_string_id(cdev);
-	if (id < 0)
-		return id;
-	strings_dev[STRING_MANUFACTURER_IDX].id = id;
-	device_desc.iManufacturer = id;
-
-	id = usb_string_id(cdev);
-	if (id < 0)
-		return id;
-	strings_dev[STRING_PRODUCT_IDX].id = id;
-	device_desc.iProduct = id;
-
-	/* Default strings - should be updated by userspace */
-	strlcpy(manufacturer_string, "Android",
-		sizeof(manufacturer_string) - 1);
-	strlcpy(product_string, "Android", sizeof(product_string) - 1);
-	strlcpy(serial_string, "0123456789ABCDEF", sizeof(serial_string) - 1);
-
-	id = usb_string_id(cdev);
-	if (id < 0)
-		return id;
-	strings_dev[STRING_SERIAL_IDX].id = id;
-	device_desc.iSerialNumber = id;
-
-	if (gadget_is_otg(cdev->gadget))
-		list_for_each_entry(conf, &dev->configs, list_item)
-			conf->usb_config.descriptors = otg_desc;
-
-	gcnum = usb_gadget_controller_number(gadget);
-	if (gcnum >= 0)
-		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
-	else {
-		pr_warning("%s: controller '%s' not recognized\n",
-			longname, gadget->name);
-		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
-	}
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	composite_string_index = 4;
-#endif
-	return 0;
-}
-
-static int android_usb_unbind(struct usb_composite_dev *cdev)
-{
-	struct android_dev *dev = cdev_to_android_dev(cdev);
-
-	printk(KERN_DEBUG "usb: %s\n", __func__);
-
-	manufacturer_string[0] = '\0';
-	product_string[0] = '\0';
-	serial_string[0] = '0';
-	cancel_work_sync(&dev->work);
-	android_cleanup_functions(dev->functions);
-	return 0;
-}
-
-static struct usb_composite_driver android_usb_driver = {
-	.name		= "android_usb",
-	.dev		= &device_desc,
-	.strings	= dev_strings,
-	.unbind		= android_usb_unbind,
-#if defined(CONFIG_SEC_LT03_PROJECT) || defined(CONFIG_SEC_MONDRIAN_PROJECT)\
-	|| defined(CONFIG_SEC_KS01_PROJECT) || defined(CONFIG_SEC_PICASSO_PROJECT)\
-	|| defined(CONFIG_SEC_KACTIVE_PROJECT) || defined(CONFIG_SEC_FRESCO_PROJECT)\
-	|| defined(CONFIG_SEC_KSPORTS_PROJECT) || defined(CONFIG_SEC_JACTIVE_PROJECT)\
-	|| defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_SEC_PATEK_PROJECT)\
-	|| defined(CONFIG_SEC_CHAGALL_PROJECT) || defined(CONFIG_SEC_KLIMT_PROJECT)\
-	|| defined(CONFIG_MACH_JS01LTEDCM) ||defined(CONFIG_MACH_JSGLTE_CHN_CMCC)
-	.max_speed	= USB_SPEED_HIGH
-#else
-	.max_speed	= USB_SPEED_SUPER
-#endif
-};
-
-static int
-android_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)
-{
-	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
-	struct android_dev		*dev = cdev_to_android_dev(cdev);
-	struct usb_request		*req = cdev->req;
-	struct android_usb_function	*f;
-	struct android_usb_function_holder *f_holder;
-	struct android_configuration	*conf;
-	int value = -EOPNOTSUPP;
-	unsigned long flags;
-	bool do_work = false;
-	bool prev_configured = false;
-
-	req->zero = 0;
-	req->complete = composite_setup_complete;
-	req->length = 0;
-	gadget->ep0->driver_data = cdev;
-
-	list_for_each_entry(conf, &dev->configs, list_item)
-		list_for_each_entry(f_holder,
-				    &conf->enabled_functions,
-				    enabled_list) {
-			f = f_holder->f;
-			if (f->ctrlrequest) {
-				value = f->ctrlrequest(f, cdev, c);
-				if (value >= 0)
-					break;
-			}
-		}
-
-
-	/*
-	 * skip the  work when 2nd set config arrives
-	 * with same value from the host.
-	 */
-	if (cdev->config)
-		prev_configured = true;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	if (value < 0)
-		value = terminal_ctrl_request(cdev, c);
-#endif
-	/* Special case the accessory function.
-	 * It needs to handle control requests before it is enabled.
-	 */
-	if (value < 0)
-		value = acc_ctrlrequest(cdev, c);
-
-	if (value < 0)
-		value = composite_setup(gadget, c);
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (!dev->connected) {
-		dev->connected = 1;
-		do_work = true;
-	} else if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
-						cdev->config) {
-		if (!prev_configured)
-			do_work = true;
-	}
-	spin_unlock_irqrestore(&cdev->lock, flags);
-	if (do_work)
-		schedule_work(&dev->work);
-	return value;
-}
-
-static void android_disconnect(struct usb_gadget *gadget)
-{
-	struct usb_composite_dev *cdev = get_gadget_data(gadget);
-	struct android_dev *dev = cdev_to_android_dev(cdev);
-	unsigned long flags;
-
-	composite_disconnect(gadget);
-	/* accessory HID support can be active while the
-	   accessory function is not actually enabled,
-	   so we need to inform it when we are disconnected.
-	 */
-	acc_disconnect();
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	dev->connected = 0;
-	schedule_work(&dev->work);
-	spin_unlock_irqrestore(&cdev->lock, flags);
-}
-
-static void android_suspend(struct usb_gadget *gadget)
-{
-	struct usb_composite_dev *cdev = get_gadget_data(gadget);
-	struct android_dev *dev = cdev_to_android_dev(cdev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (!dev->suspended) {
-		dev->suspended = 1;
-		schedule_work(&dev->work);
-	}
-	spin_unlock_irqrestore(&cdev->lock, flags);
-
-	composite_suspend(gadget);
-}
-
-static void android_resume(struct usb_gadget *gadget)
-{
-	struct usb_composite_dev *cdev = get_gadget_data(gadget);
-	struct android_dev *dev = cdev_to_android_dev(cdev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (dev->suspended) {
-		dev->suspended = 0;
-		schedule_work(&dev->work);
-	}
-	spin_unlock_irqrestore(&cdev->lock, flags);
-
-	composite_resume(gadget);
-}
-
-
-static int android_create_device(struct android_dev *dev, u8 usb_core_id)
-{
-	struct device_attribute **attrs = android_usb_attributes;
-	struct device_attribute *attr;
-	char device_node_name[ANDROID_DEVICE_NODE_NAME_LENGTH];
-	int err;
-
-	/*
-	 * The primary usb core should always have usb_core_id=0, since
-	 * Android user space is currently interested in android0 events.
-	 */
-	snprintf(device_node_name, ANDROID_DEVICE_NODE_NAME_LENGTH,
-		 "android%d", usb_core_id);
-	dev->dev = device_create(android_class, NULL,
-					MKDEV(0, 0), NULL, device_node_name);
-	if (IS_ERR(dev->dev))
-		return PTR_ERR(dev->dev);
-
-	dev_set_drvdata(dev->dev, dev);
-
-	while ((attr = *attrs++)) {
-		err = device_create_file(dev->dev, attr);
-		if (err) {
-			device_destroy(android_class, dev->dev->devt);
-			return err;
-		}
-	}
-	return 0;
-}
-
-static void android_destroy_device(struct android_dev *dev)
-{
-	struct device_attribute **attrs = android_usb_attributes;
-	struct device_attribute *attr;
-
-	while ((attr = *attrs++))
-		device_remove_file(dev->dev, attr);
-	device_destroy(android_class, dev->dev->devt);
-}
-
-static struct android_dev *cdev_to_android_dev(struct usb_composite_dev *cdev)
-{
-	struct android_dev *dev = NULL;
-
-	/* Find the android dev from the list */
-	list_for_each_entry(dev, &android_dev_list, list_item) {
-		if (dev->cdev == cdev)
-			break;
-	}
-
-	return dev;
-}
-
-static struct android_configuration *alloc_android_config
-						(struct android_dev *dev)
-{
-	struct android_configuration *conf;
-
-	conf = kzalloc(sizeof(*conf), GFP_KERNEL);
-	if (!conf) {
-		pr_err("%s(): Failed to alloc memory for android conf\n",
-			__func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	dev->configs_num++;
-	conf->usb_config.label = dev->name;
-	conf->usb_config.unbind = android_unbind_config;
-	conf->usb_config.bConfigurationValue = dev->configs_num;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	conf->usb_config.bmAttributes
-		= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER;
-	conf->usb_config.bMaxPower = 0x30; /* 96ma */
-#endif
-	INIT_LIST_HEAD(&conf->enabled_functions);
-
-	list_add_tail(&conf->list_item, &dev->configs);
-
-	return conf;
-}
-
-static void free_android_config(struct android_dev *dev,
-			     struct android_configuration *conf)
-{
-	list_del(&conf->list_item);
-	dev->configs_num--;
-	kfree(conf);
-}
-
-static int usb_diag_update_pid_and_serial_num(u32 pid, const char *snum)
-{
-	struct dload_struct local_diag_dload = { 0 };
-	int *src, *dst, i;
-
-	if (!diag_dload) {
-		pr_debug("%s: unable to update PID and serial_no\n", __func__);
-		return -ENODEV;
-	}
-
-	pr_debug("%s: dload:%pK pid:%x serial_num:%s\n",
-				__func__, diag_dload, pid, snum);
-
-	/* update pid */
-	local_diag_dload.magic_struct.pid = PID_MAGIC_ID;
-	local_diag_dload.pid = pid;
-
-	/* update serial number */
-	if (!snum) {
-		local_diag_dload.magic_struct.serial_num = 0;
-		memset(&local_diag_dload.serial_number, 0,
-				SERIAL_NUMBER_LENGTH);
-	} else {
-		local_diag_dload.magic_struct.serial_num = SERIAL_NUM_MAGIC_ID;
-		strlcpy((char *)&local_diag_dload.serial_number, snum,
-				SERIAL_NUMBER_LENGTH);
-	}
-
-	/* Copy to shared struct (accesses need to be 32 bit aligned) */
-	src = (int *)&local_diag_dload;
-	dst = (int *)diag_dload;
-
-	for (i = 0; i < sizeof(*diag_dload) / 4; i++)
-		*dst++ = *src++;
-
-	return 0;
-}
-
-static int __devinit android_probe(struct platform_device *pdev)
-{
-	struct android_usb_platform_data *pdata;
-	struct android_dev *android_dev;
-	struct resource *res;
-	int ret = 0, i, len = 0;
-
-	if (pdev->dev.of_node) {
-		dev_dbg(&pdev->dev, "device tree enabled\n");
-		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
-		if (!pdata) {
-			pr_err("unable to allocate platform data\n");
-			return -ENOMEM;
-		}
-
-		of_property_read_u32(pdev->dev.of_node,
-				"qcom,android-usb-swfi-latency",
-				&pdata->swfi_latency);
-		pdata->cdrom = of_property_read_bool(pdev->dev.of_node,
-				"qcom,android-usb-cdrom");
-		pdata->internal_ums = of_property_read_bool(pdev->dev.of_node,
-				"qcom,android-usb-internal-ums");
-		len = of_property_count_strings(pdev->dev.of_node,
-				"qcom,streaming-func");
-		if (len > MAX_STREAMING_FUNCS) {
-			pr_err("Invalid number of functions used.\n");
-			return -EINVAL;
-		}
-
-		for (i = 0; i < len; i++) {
-			const char *name = NULL;
-
-			of_property_read_string_index(pdev->dev.of_node,
-				"qcom,streaming-func", i, &name);
-			if (!name)
-				continue;
-
-			if (sizeof(name) > FUNC_NAME_LEN) {
-				pr_err("Function name is bigger than allowed.\n");
-				continue;
-			}
-
-			strlcpy(pdata->streaming_func[i], name,
-				sizeof(pdata->streaming_func[i]));
-			pr_debug("name of streaming function:%s\n",
-				pdata->streaming_func[i]);
-		}
-
-		pdata->streaming_func_count = len;
-	} else {
-		pdata = pdev->dev.platform_data;
-	}
-
-	if (!android_class) {
-		android_class = class_create(THIS_MODULE, "android_usb");
-		if (IS_ERR(android_class))
-			return PTR_ERR(android_class);
-	}
-
-	android_dev = kzalloc(sizeof(*android_dev), GFP_KERNEL);
-	if (!android_dev) {
-		pr_err("%s(): Failed to alloc memory for android_dev\n",
-			__func__);
-		ret = -ENOMEM;
-		goto err_alloc;
-	}
-
-	android_dev->name = pdev->name;
-	android_dev->disable_depth = 1;
-	android_dev->functions = supported_functions;
-	android_dev->configs_num = 0;
-	INIT_LIST_HEAD(&android_dev->configs);
-	INIT_WORK(&android_dev->work, android_work);
-#if defined(CONFIG_SEC_H_PROJECT)
-	INIT_DELAYED_WORK(&android_dev->usb_connection_work, usb_gadget_connect_work);
-#endif
-	mutex_init(&android_dev->mutex);
-
-	android_dev->pdata = pdata;
-
-	list_add_tail(&android_dev->list_item, &android_dev_list);
-	android_dev_count++;
-
-	if (pdata)
-		composite_driver.usb_core_id = pdata->usb_core_id;
-	else
-		composite_driver.usb_core_id = 0; /*To backward compatibility*/
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (res) {
-		diag_dload = devm_ioremap(&pdev->dev, res->start,
-							resource_size(res));
-		if (!diag_dload) {
-			dev_err(&pdev->dev, "ioremap failed\n");
-			ret = -ENOMEM;
-			goto err_dev;
-		}
-	} else {
-		dev_dbg(&pdev->dev, "failed to get mem resource\n");
-	}
-
-	ret = android_create_device(android_dev, composite_driver.usb_core_id);
-	if (ret) {
-		pr_err("%s(): android_create_device failed\n", __func__);
-		goto err_dev;
-	}
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	/* Create below sysfs
-	 *   /sys/class/android_usb/android0/terminal_version
-	 */
-	ret = create_terminal_attribute(&android_dev->dev);
-	if (ret) {
-		printk(KERN_ERR "usb: %s To create terminal_atttrr is failed\n",
-				__func__);
-		return ret;
-	}
-#endif
-	ret = usb_composite_probe(&android_usb_driver, android_bind);
-	if (ret) {
-		pr_err("%s(): Failed to register android "
-				 "composite driver\n", __func__);
-		goto err_probe;
-	}
-
-	/* pm qos request to prevent apps idle power collapse */
-	if (pdata && pdata->swfi_latency)
-		pm_qos_add_request(&android_dev->pm_qos_req_dma,
-			PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
-	strlcpy(android_dev->pm_qos, "high", sizeof(android_dev->pm_qos));
-
-#ifdef CONFIG_USB_DUN_SUPPORT
-		ret = modem_misc_register();
-		if (ret) {
-			printk(KERN_ERR "usb: %s modem misc register is failed\n",
-					 __func__);
-			goto err_probe;
-		}
-#endif
-
-	return ret;
-err_probe:
-	android_destroy_device(android_dev);
-err_dev:
-	list_del(&android_dev->list_item);
-	android_dev_count--;
-	kfree(android_dev);
-err_alloc:
-	if (list_empty(&android_dev_list)) {
-		class_destroy(android_class);
-		android_class = NULL;
-	}
-	return ret;
-}
-
-static int android_remove(struct platform_device *pdev)
-{
-	struct android_dev *dev = NULL;
-	struct android_usb_platform_data *pdata = pdev->dev.platform_data;
-	int usb_core_id = 0;
-
-	if (pdata)
-		usb_core_id = pdata->usb_core_id;
-
-	/* Find the android dev from the list */
-	list_for_each_entry(dev, &android_dev_list, list_item) {
-		if (!dev->pdata)
-			break; /*To backward compatibility*/
-		if (dev->pdata->usb_core_id == usb_core_id)
-			break;
-	}
-
-	if (dev) {
-		android_destroy_device(dev);
-		if (pdata && pdata->swfi_latency)
-			pm_qos_remove_request(&dev->pm_qos_req_dma);
-		list_del(&dev->list_item);
-		android_dev_count--;
-		kfree(dev);
-	}
-
-	if (list_empty(&android_dev_list)) {
-		class_destroy(android_class);
-		android_class = NULL;
-		usb_composite_unregister(&android_usb_driver);
-	}
-
-	return 0;
-}
-
-static const struct platform_device_id android_id_table[] __devinitconst = {
-	{
-		.name = "android_usb",
-	},
-	{
-		.name = "android_usb_hsic",
-	},
-};
-
-static struct of_device_id usb_android_dt_match[] = {
-	{	.compatible = "qcom,android-usb",
-	},
-	{}
-};
-
-static struct platform_driver android_platform_driver = {
-	.driver = {
-		.name = "android_usb",
-		.of_match_table = usb_android_dt_match,
-	},
-	.probe = android_probe,
-	.remove = android_remove,
-	.id_table = android_id_table,
-};
-
-static int __init init(void)
-{
-	int ret;
-
-	/* Override composite driver functions */
-	composite_driver.setup = android_setup;
-	composite_driver.disconnect = android_disconnect;
-	composite_driver.suspend = android_suspend;
-	composite_driver.resume = android_resume;
-
-	INIT_LIST_HEAD(&android_dev_list);
-	android_dev_count = 0;
-
-	ret = platform_driver_register(&android_platform_driver);
-	if (ret) {
-		pr_err("%s(): Failed to register android"
-				 "platform driver\n", __func__);
-	}
-
-	return ret;
-}
-module_init(init);
-
-static void __exit cleanup(void)
-{
-	platform_driver_unregister(&android_platform_driver);
-}
-module_exit(cleanup);
diff --git a/drivers/usb/gadget/android.o_shipped b/drivers/usb/gadget/android.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..0ddee7d7933a250607a0454dfd4d11663e7535c5
GIT binary patch
literal 478560
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%0DOEO~365yh
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
Z{MX=dQJ?oqx0cK5-Vu+uWdRrE{trsgS2F+r

literal 0
HcmV?d00001

diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.c
deleted file mode 100644
index b892662f1a8d..000000000000
--- a/fs/f2fs/segment.c
+++ /dev/null
@@ -1,3535 +0,0 @@
-/*
- * fs/f2fs/segment.c
- *
- * Copyright (c) 2012 Samsung Electronics Co., Ltd.
- *             http://www.samsung.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/fs.h>
-#include <linux/f2fs_fs.h>
-#include <linux/bio.h>
-#include <linux/blkdev.h>
-#include <linux/prefetch.h>
-#include <linux/kthread.h>
-#include <linux/swap.h>
-#include <linux/timer.h>
-
-#include "f2fs.h"
-#include "segment.h"
-#include "node.h"
-#include "trace.h"
-#include <trace/events/f2fs.h>
-
-#define __reverse_ffz(x) __reverse_ffs(~(x))
-
-static struct kmem_cache *discard_entry_slab;
-static struct kmem_cache *discard_cmd_slab;
-static struct kmem_cache *sit_entry_set_slab;
-static struct kmem_cache *inmem_entry_slab;
-
-/**
- * Copied from latest lib/llist.c
- * llist_for_each_entry_safe - iterate over some deleted entries of
- *                             lock-less list of given type
- *			       safe against removal of list entry
- * @pos:	the type * to use as a loop cursor.
- * @n:		another type * to use as temporary storage
- * @node:	the first entry of deleted list entries.
- * @member:	the name of the llist_node with the struct.
- *
- * In general, some entries of the lock-less list can be traversed
- * safely only after being removed from list, so start with an entry
- * instead of list head.
- *
- * If being used on entries deleted from lock-less list directly, the
- * traverse order is from the newest to the oldest added entry.  If
- * you want to traverse from the oldest to the newest, you must
- * reverse the order by yourself before traversing.
- */
-#define llist_for_each_entry_safe(pos, n, node, member)			       \
-	for (pos = llist_entry((node), typeof(*pos), member);		       \
-		&pos->member != NULL &&					       \
-		(n = llist_entry(pos->member.next, typeof(*n), member), true); \
-		pos = n)
-
-/**
- * Copied from latest lib/llist.c
- * llist_reverse_order - reverse order of a llist chain
- * @head:	first item of the list to be reversed
- *
- * Reverse the order of a chain of llist entries and return the
- * new first entry.
- */
-struct llist_node *llist_reverse_order(struct llist_node *head)
-{
-	struct llist_node *new_head = NULL;
-
-	while (head) {
-		struct llist_node *tmp = head;
-		head = head->next;
-		tmp->next = new_head;
-		new_head = tmp;
-	}
-
-	return new_head;
-}
-
-/**
- * Copied from latest linux/list.h
- * list_last_entry - get the last element from a list
- * @ptr:        the list head to take the element from.
- * @type:       the type of the struct this is embedded in.
- * @member:     the name of the list_struct within the struct.
- *
- * Note, that list is expected to be not empty.
- */
-#define list_last_entry(ptr, type, member) \
-	list_entry((ptr)->prev, type, member)
-
-static unsigned long __reverse_ulong(unsigned char *str)
-{
-	unsigned long tmp = 0;
-	int shift = 24, idx = 0;
-
-#if BITS_PER_LONG == 64
-	shift = 56;
-#endif
-	while (shift >= 0) {
-		tmp |= (unsigned long)str[idx++] << shift;
-		shift -= BITS_PER_BYTE;
-	}
-	return tmp;
-}
-
-/*
- * __reverse_ffs is copied from include/asm-generic/bitops/__ffs.h since
- * MSB and LSB are reversed in a byte by f2fs_set_bit.
- */
-static inline unsigned long __reverse_ffs(unsigned long word)
-{
-	int num = 0;
-
-#if BITS_PER_LONG == 64
-	if ((word & 0xffffffff00000000UL) == 0)
-		num += 32;
-	else
-		word >>= 32;
-#endif
-	if ((word & 0xffff0000) == 0)
-		num += 16;
-	else
-		word >>= 16;
-
-	if ((word & 0xff00) == 0)
-		num += 8;
-	else
-		word >>= 8;
-
-	if ((word & 0xf0) == 0)
-		num += 4;
-	else
-		word >>= 4;
-
-	if ((word & 0xc) == 0)
-		num += 2;
-	else
-		word >>= 2;
-
-	if ((word & 0x2) == 0)
-		num += 1;
-	return num;
-}
-
-/*
- * __find_rev_next(_zero)_bit is copied from lib/find_next_bit.c because
- * f2fs_set_bit makes MSB and LSB reversed in a byte.
- * @size must be integral times of unsigned long.
- * Example:
- *                             MSB <--> LSB
- *   f2fs_set_bit(0, bitmap) => 1000 0000
- *   f2fs_set_bit(7, bitmap) => 0000 0001
- */
-static unsigned long __find_rev_next_bit(const unsigned long *addr,
-			unsigned long size, unsigned long offset)
-{
-	const unsigned long *p = addr + BIT_WORD(offset);
-	unsigned long result = size;
-	unsigned long tmp;
-
-	if (offset >= size)
-		return size;
-
-	size -= (offset & ~(BITS_PER_LONG - 1));
-	offset %= BITS_PER_LONG;
-
-	while (1) {
-		if (*p == 0)
-			goto pass;
-
-		tmp = __reverse_ulong((unsigned char *)p);
-
-		tmp &= ~0UL >> offset;
-		if (size < BITS_PER_LONG)
-			tmp &= (~0UL << (BITS_PER_LONG - size));
-		if (tmp)
-			goto found;
-pass:
-		if (size <= BITS_PER_LONG)
-			break;
-		size -= BITS_PER_LONG;
-		offset = 0;
-		p++;
-	}
-	return result;
-found:
-	return result - size + __reverse_ffs(tmp);
-}
-
-static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,
-			unsigned long size, unsigned long offset)
-{
-	const unsigned long *p = addr + BIT_WORD(offset);
-	unsigned long result = size;
-	unsigned long tmp;
-
-	if (offset >= size)
-		return size;
-
-	size -= (offset & ~(BITS_PER_LONG - 1));
-	offset %= BITS_PER_LONG;
-
-	while (1) {
-		if (*p == ~0UL)
-			goto pass;
-
-		tmp = __reverse_ulong((unsigned char *)p);
-
-		if (offset)
-			tmp |= ~0UL << (BITS_PER_LONG - offset);
-		if (size < BITS_PER_LONG)
-			tmp |= ~0UL >> size;
-		if (tmp != ~0UL)
-			goto found;
-pass:
-		if (size <= BITS_PER_LONG)
-			break;
-		size -= BITS_PER_LONG;
-		offset = 0;
-		p++;
-	}
-	return result;
-found:
-	return result - size + __reverse_ffz(tmp);
-}
-
-void register_inmem_page(struct inode *inode, struct page *page)
-{
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct inmem_pages *new;
-
-	f2fs_trace_pid(page);
-
-	set_page_private(page, (unsigned long)ATOMIC_WRITTEN_PAGE);
-	SetPagePrivate(page);
-
-	new = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);
-
-	/* add atomic page indices to the list */
-	new->page = page;
-	INIT_LIST_HEAD(&new->list);
-
-	/* increase reference count with clean state */
-	mutex_lock(&fi->inmem_lock);
-	get_page(page);
-	list_add_tail(&new->list, &fi->inmem_pages);
-	inc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);
-	mutex_unlock(&fi->inmem_lock);
-
-	trace_f2fs_register_inmem_page(page, INMEM);
-}
-
-static int __revoke_inmem_pages(struct inode *inode,
-				struct list_head *head, bool drop, bool recover)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct inmem_pages *cur, *tmp;
-	int err = 0;
-
-	list_for_each_entry_safe(cur, tmp, head, list) {
-		struct page *page = cur->page;
-
-		if (drop)
-			trace_f2fs_commit_inmem_page(page, INMEM_DROP);
-
-		lock_page(page);
-
-		if (recover) {
-			struct dnode_of_data dn;
-			struct node_info ni;
-
-			trace_f2fs_commit_inmem_page(page, INMEM_REVOKE);
-
-			set_new_dnode(&dn, inode, NULL, NULL, 0);
-			if (get_dnode_of_data(&dn, page->index, LOOKUP_NODE)) {
-				err = -EAGAIN;
-				goto next;
-			}
-			get_node_info(sbi, dn.nid, &ni);
-			f2fs_replace_block(sbi, &dn, dn.data_blkaddr,
-					cur->old_addr, ni.version, true, true);
-			f2fs_put_dnode(&dn);
-		}
-next:
-		/* we don't need to invalidate this in the sccessful status */
-		if (drop || recover)
-			ClearPageUptodate(page);
-		set_page_private(page, 0);
-		ClearPagePrivate(page);
-		f2fs_put_page(page, 1);
-
-		list_del(&cur->list);
-		kmem_cache_free(inmem_entry_slab, cur);
-		dec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);
-	}
-	return err;
-}
-
-void drop_inmem_pages(struct inode *inode)
-{
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-
-	mutex_lock(&fi->inmem_lock);
-	__revoke_inmem_pages(inode, &fi->inmem_pages, true, false);
-	mutex_unlock(&fi->inmem_lock);
-
-	clear_inode_flag(inode, FI_ATOMIC_FILE);
-	stat_dec_atomic_write(inode);
-}
-
-void drop_inmem_page(struct inode *inode, struct page *page)
-{
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct list_head *head = &fi->inmem_pages;
-	struct inmem_pages *cur = NULL;
-
-	f2fs_bug_on(sbi, !IS_ATOMIC_WRITTEN_PAGE(page));
-
-	mutex_lock(&fi->inmem_lock);
-	list_for_each_entry(cur, head, list) {
-		if (cur->page == page)
-			break;
-	}
-
-	f2fs_bug_on(sbi, !cur || cur->page != page);
-	list_del(&cur->list);
-	mutex_unlock(&fi->inmem_lock);
-
-	dec_page_count(sbi, F2FS_INMEM_PAGES);
-	kmem_cache_free(inmem_entry_slab, cur);
-
-	ClearPageUptodate(page);
-	set_page_private(page, 0);
-	ClearPagePrivate(page);
-	f2fs_put_page(page, 0);
-
-	trace_f2fs_commit_inmem_page(page, INMEM_INVALIDATE);
-}
-
-static int __commit_inmem_pages(struct inode *inode,
-					struct list_head *revoke_list)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct inmem_pages *cur, *tmp;
-	struct f2fs_io_info fio = {
-		.sbi = sbi,
-		.type = DATA,
-		.op = REQ_OP_WRITE,
-		.op_flags = REQ_SYNC | REQ_PRIO,
-	};
-	pgoff_t last_idx = ULONG_MAX;
-	int err = 0;
-
-	list_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {
-		struct page *page = cur->page;
-
-		lock_page(page);
-		if (page->mapping == inode->i_mapping) {
-			trace_f2fs_commit_inmem_page(page, INMEM);
-
-			set_page_dirty(page);
-			f2fs_wait_on_page_writeback(page, DATA, true);
-			if (clear_page_dirty_for_io(page)) {
-				inode_dec_dirty_pages(inode);
-				remove_dirty_inode(inode);
-			}
-
-			fio.page = page;
-			fio.old_blkaddr = NULL_ADDR;
-			fio.encrypted_page = NULL;
-			fio.need_lock = LOCK_DONE;
-			err = do_write_data_page(&fio);
-			if (err) {
-				unlock_page(page);
-				break;
-			}
-
-			/* record old blkaddr for revoking */
-			cur->old_addr = fio.old_blkaddr;
-			last_idx = page->index;
-		}
-		unlock_page(page);
-		list_move_tail(&cur->list, revoke_list);
-	}
-
-	if (last_idx != ULONG_MAX)
-		f2fs_submit_merged_bio_cond(sbi, inode, 0, last_idx,
-							DATA, WRITE);
-
-	if (!err)
-		__revoke_inmem_pages(inode, revoke_list, false, false);
-
-	return err;
-}
-
-int commit_inmem_pages(struct inode *inode)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct list_head revoke_list;
-	int err;
-
-	INIT_LIST_HEAD(&revoke_list);
-	f2fs_balance_fs(sbi, true);
-	f2fs_lock_op(sbi);
-
-	set_inode_flag(inode, FI_ATOMIC_COMMIT);
-
-	mutex_lock(&fi->inmem_lock);
-	err = __commit_inmem_pages(inode, &revoke_list);
-	if (err) {
-		int ret;
-		/*
-		 * try to revoke all committed pages, but still we could fail
-		 * due to no memory or other reason, if that happened, EAGAIN
-		 * will be returned, which means in such case, transaction is
-		 * already not integrity, caller should use journal to do the
-		 * recovery or rewrite & commit last transaction. For other
-		 * error number, revoking was done by filesystem itself.
-		 */
-		ret = __revoke_inmem_pages(inode, &revoke_list, false, true);
-		if (ret)
-			err = ret;
-
-		/* drop all uncommitted pages */
-		__revoke_inmem_pages(inode, &fi->inmem_pages, true, false);
-	}
-	mutex_unlock(&fi->inmem_lock);
-
-	clear_inode_flag(inode, FI_ATOMIC_COMMIT);
-
-	f2fs_unlock_op(sbi);
-	return err;
-}
-
-/*
- * This function balances dirty node and dentry pages.
- * In addition, it controls garbage collection.
- */
-void f2fs_balance_fs(struct f2fs_sb_info *sbi, bool need)
-{
-#ifdef CONFIG_F2FS_FAULT_INJECTION
-	if (time_to_inject(sbi, FAULT_CHECKPOINT)) {
-		f2fs_show_injection_info(FAULT_CHECKPOINT);
-		f2fs_stop_checkpoint(sbi, false);
-	}
-#endif
-
-	/* balance_fs_bg is able to be pending */
-	if (need && excess_cached_nats(sbi))
-		f2fs_balance_fs_bg(sbi);
-
-	/*
-	 * We should do GC or end up with checkpoint, if there are so many dirty
-	 * dir/node pages without enough free segments.
-	 */
-	if (has_not_enough_free_secs(sbi, 0, 0)) {
-		mutex_lock(&sbi->gc_mutex);
-		f2fs_gc(sbi, false, false, NULL_SEGNO);
-	}
-}
-
-void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)
-{
-	/* try to shrink extent cache when there is no enough memory */
-	if (!available_free_memory(sbi, EXTENT_CACHE))
-		f2fs_shrink_extent_tree(sbi, EXTENT_CACHE_SHRINK_NUMBER);
-
-	/* check the # of cached NAT entries */
-	if (!available_free_memory(sbi, NAT_ENTRIES))
-		try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK);
-
-	if (!available_free_memory(sbi, FREE_NIDS))
-		try_to_free_nids(sbi, MAX_FREE_NIDS);
-	else
-		build_free_nids(sbi, false, false);
-
-	if (!is_idle(sbi) && !excess_dirty_nats(sbi))
-		return;
-
-	/* checkpoint is the only way to shrink partial cached entries */
-	if (!available_free_memory(sbi, NAT_ENTRIES) ||
-			!available_free_memory(sbi, INO_ENTRIES) ||
-			excess_prefree_segs(sbi) ||
-			excess_dirty_nats(sbi) ||
-			f2fs_time_over(sbi, CP_TIME)) {
-		if (test_opt(sbi, DATA_FLUSH)) {
-			struct blk_plug plug;
-
-			blk_start_plug(&plug);
-			sync_dirty_inodes(sbi, FILE_INODE);
-			blk_finish_plug(&plug);
-		}
-		f2fs_sync_fs(sbi->sb, true);
-		stat_inc_bg_cp_count(sbi->stat_info);
-	}
-}
-
-static int __submit_flush_wait(struct f2fs_sb_info *sbi,
-				struct block_device *bdev)
-{
-	struct bio *bio = f2fs_bio_alloc(0);
-	int ret;
-
-	bio->bi_rw = REQ_OP_WRITE;
-	bio->bi_bdev = bdev;
-	ret = submit_bio_wait(WRITE_FLUSH, bio);
-	bio_put(bio);
-
-	trace_f2fs_issue_flush(bdev, test_opt(sbi, NOBARRIER),
-				test_opt(sbi, FLUSH_MERGE), ret);
-	return ret;
-}
-
-static int submit_flush_wait(struct f2fs_sb_info *sbi)
-{
-	int ret = __submit_flush_wait(sbi, sbi->sb->s_bdev);
-	int i;
-
-	if (!sbi->s_ndevs || ret)
-		return ret;
-
-	for (i = 1; i < sbi->s_ndevs; i++) {
-		ret = __submit_flush_wait(sbi, FDEV(i).bdev);
-		if (ret)
-			break;
-	}
-	return ret;
-}
-
-static int issue_flush_thread(void *data)
-{
-	struct f2fs_sb_info *sbi = data;
-	struct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;
-	wait_queue_head_t *q = &fcc->flush_wait_queue;
-repeat:
-	if (kthread_should_stop())
-		return 0;
-
-	sb_start_intwrite(sbi->sb);
-
-	if (!llist_empty(&fcc->issue_list)) {
-		struct flush_cmd *cmd, *next;
-		int ret;
-
-		fcc->dispatch_list = llist_del_all(&fcc->issue_list);
-		fcc->dispatch_list = llist_reverse_order(fcc->dispatch_list);
-
-		ret = submit_flush_wait(sbi);
-		atomic_inc(&fcc->issued_flush);
-
-		llist_for_each_entry_safe(cmd, next,
-					  fcc->dispatch_list, llnode) {
-			cmd->ret = ret;
-			complete(&cmd->wait);
-		}
-		fcc->dispatch_list = NULL;
-	}
-
-	sb_end_intwrite(sbi->sb);
-
-	wait_event_interruptible(*q,
-		kthread_should_stop() || !llist_empty(&fcc->issue_list));
-	goto repeat;
-}
-
-int f2fs_issue_flush(struct f2fs_sb_info *sbi)
-{
-	struct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;
-	struct flush_cmd cmd;
-	int ret;
-
-	if (test_opt(sbi, NOBARRIER))
-		return 0;
-
-	if (!test_opt(sbi, FLUSH_MERGE)) {
-		ret = submit_flush_wait(sbi);
-		atomic_inc(&fcc->issued_flush);
-		return ret;
-	}
-
-	if (!atomic_read(&fcc->issing_flush)) {
-		atomic_inc(&fcc->issing_flush);
-		ret = submit_flush_wait(sbi);
-		atomic_dec(&fcc->issing_flush);
-
-		atomic_inc(&fcc->issued_flush);
-		return ret;
-	}
-
-	init_completion(&cmd.wait);
-
-	atomic_inc(&fcc->issing_flush);
-	llist_add(&cmd.llnode, &fcc->issue_list);
-
-	if (!fcc->dispatch_list)
-		wake_up(&fcc->flush_wait_queue);
-
-	if (fcc->f2fs_issue_flush) {
-		wait_for_completion(&cmd.wait);
-		atomic_dec(&fcc->issing_flush);
-	} else {
-		llist_del_all(&fcc->issue_list);
-		atomic_set(&fcc->issing_flush, 0);
-	}
-
-	return cmd.ret;
-}
-
-int create_flush_cmd_control(struct f2fs_sb_info *sbi)
-{
-	dev_t dev = sbi->sb->s_bdev->bd_dev;
-	struct flush_cmd_control *fcc;
-	int err = 0;
-
-	if (SM_I(sbi)->fcc_info) {
-		fcc = SM_I(sbi)->fcc_info;
-		goto init_thread;
-	}
-
-	fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);
-	if (!fcc)
-		return -ENOMEM;
-	atomic_set(&fcc->issued_flush, 0);
-	atomic_set(&fcc->issing_flush, 0);
-	init_waitqueue_head(&fcc->flush_wait_queue);
-	init_llist_head(&fcc->issue_list);
-	SM_I(sbi)->fcc_info = fcc;
-	if (!test_opt(sbi, FLUSH_MERGE))
-		return err;
-
-init_thread:
-	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
-				"f2fs_flush-%u:%u", MAJOR(dev), MINOR(dev));
-	if (IS_ERR(fcc->f2fs_issue_flush)) {
-		err = PTR_ERR(fcc->f2fs_issue_flush);
-		kfree(fcc);
-		SM_I(sbi)->fcc_info = NULL;
-		return err;
-	}
-
-	return err;
-}
-
-void destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free)
-{
-	struct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;
-
-	if (fcc && fcc->f2fs_issue_flush) {
-		struct task_struct *flush_thread = fcc->f2fs_issue_flush;
-
-		fcc->f2fs_issue_flush = NULL;
-		kthread_stop(flush_thread);
-	}
-	if (free) {
-		kfree(fcc);
-		SM_I(sbi)->fcc_info = NULL;
-	}
-}
-
-static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	/* need not be added */
-	if (IS_CURSEG(sbi, segno))
-		return;
-
-	if (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))
-		dirty_i->nr_dirty[dirty_type]++;
-
-	if (dirty_type == DIRTY) {
-		struct seg_entry *sentry = get_seg_entry(sbi, segno);
-		enum dirty_type t = sentry->type;
-
-		if (unlikely(t >= DIRTY)) {
-			f2fs_bug_on(sbi, 1);
-			return;
-		}
-		if (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))
-			dirty_i->nr_dirty[t]++;
-	}
-}
-
-static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	if (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))
-		dirty_i->nr_dirty[dirty_type]--;
-
-	if (dirty_type == DIRTY) {
-		struct seg_entry *sentry = get_seg_entry(sbi, segno);
-		enum dirty_type t = sentry->type;
-
-		if (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))
-			dirty_i->nr_dirty[t]--;
-
-		if (get_valid_blocks(sbi, segno, true) == 0)
-			clear_bit(GET_SEC_FROM_SEG(sbi, segno),
-						dirty_i->victim_secmap);
-	}
-}
-
-/*
- * Should not occur error such as -ENOMEM.
- * Adding dirty entry into seglist is not critical operation.
- * If a given segment is one of current working segments, it won't be added.
- */
-static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned short valid_blocks;
-
-	if (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))
-		return;
-
-	mutex_lock(&dirty_i->seglist_lock);
-
-	valid_blocks = get_valid_blocks(sbi, segno, false);
-
-	if (valid_blocks == 0) {
-		__locate_dirty_segment(sbi, segno, PRE);
-		__remove_dirty_segment(sbi, segno, DIRTY);
-	} else if (valid_blocks < sbi->blocks_per_seg) {
-		__locate_dirty_segment(sbi, segno, DIRTY);
-	} else {
-		/* Recovery routine with SSR needs this */
-		__remove_dirty_segment(sbi, segno, DIRTY);
-	}
-
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-static struct discard_cmd *__create_discard_cmd(struct f2fs_sb_info *sbi,
-		struct block_device *bdev, block_t lstart,
-		block_t start, block_t len)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct list_head *pend_list;
-	struct discard_cmd *dc;
-
-	f2fs_bug_on(sbi, !len);
-
-	pend_list = &dcc->pend_list[plist_idx(len)];
-
-	dc = f2fs_kmem_cache_alloc(discard_cmd_slab, GFP_NOFS);
-	INIT_LIST_HEAD(&dc->list);
-	dc->bdev = bdev;
-	dc->lstart = lstart;
-	dc->start = start;
-	dc->len = len;
-	dc->ref = 0;
-	dc->state = D_PREP;
-	dc->error = 0;
-	init_completion(&dc->wait);
-	list_add_tail(&dc->list, pend_list);
-	atomic_inc(&dcc->discard_cmd_cnt);
-	dcc->undiscard_blks += len;
-
-	return dc;
-}
-
-static struct discard_cmd *__attach_discard_cmd(struct f2fs_sb_info *sbi,
-				struct block_device *bdev, block_t lstart,
-				block_t start, block_t len,
-				struct rb_node *parent, struct rb_node **p)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct discard_cmd *dc;
-
-	dc = __create_discard_cmd(sbi, bdev, lstart, start, len);
-
-	rb_link_node(&dc->rb_node, parent, p);
-	rb_insert_color(&dc->rb_node, &dcc->root);
-
-	return dc;
-}
-
-static void __detach_discard_cmd(struct discard_cmd_control *dcc,
-							struct discard_cmd *dc)
-{
-	if (dc->state == D_DONE)
-		atomic_dec(&dcc->issing_discard);
-
-	list_del(&dc->list);
-	rb_erase(&dc->rb_node, &dcc->root);
-	dcc->undiscard_blks -= dc->len;
-
-	kmem_cache_free(discard_cmd_slab, dc);
-
-	atomic_dec(&dcc->discard_cmd_cnt);
-}
-
-static void __remove_discard_cmd(struct f2fs_sb_info *sbi,
-							struct discard_cmd *dc)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-
-	if (dc->error == -EOPNOTSUPP)
-		dc->error = 0;
-
-	if (dc->error)
-		f2fs_msg(sbi->sb, KERN_INFO,
-				"Issue discard failed, ret: %d", dc->error);
-	__detach_discard_cmd(dcc, dc);
-}
-
-static void f2fs_submit_discard_endio(struct bio *bio, int err)
-{
-	struct discard_cmd *dc = (struct discard_cmd *)bio->bi_private;
-
-	dc->error = err;
-	dc->state = D_DONE;
-	complete(&dc->wait);
-	bio_put(bio);
-}
-
-/* copied from block/blk-lib.c in 4.10-rc1 */
-static int __blkdev_issue_discard(struct block_device *bdev, sector_t sector,
-		sector_t nr_sects, gfp_t gfp_mask, int flags,
-		struct bio **biop)
-{
-	struct request_queue *q = bdev_get_queue(bdev);
-	struct bio *bio = *biop;
-	unsigned int granularity;
-	int op = REQ_WRITE | REQ_DISCARD;
-	int alignment;
-	sector_t bs_mask;
-
-	if (!q)
-		return -ENXIO;
-
-	if (!blk_queue_discard(q))
-		return -EOPNOTSUPP;
-
-	if (flags & BLKDEV_DISCARD_SECURE) {
-		if (!blk_queue_secdiscard(q))
-			return -EOPNOTSUPP;
-		op |= REQ_SECURE;
-	}
-
-	bs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;
-	if ((sector | nr_sects) & bs_mask)
-		return -EINVAL;
-
-	/* Zero-sector (unknown) and one-sector granularities are the same.  */
-	granularity = max(q->limits.discard_granularity >> 9, 1U);
-	alignment = (bdev_discard_alignment(bdev) >> 9) % granularity;
-
-	while (nr_sects) {
-		unsigned int req_sects;
-		sector_t end_sect, tmp;
-
-		/* Make sure bi_size doesn't overflow */
-		req_sects = min_t(sector_t, nr_sects, UINT_MAX >> 9);
-
-		/**
-		 * If splitting a request, and the next starting sector would be
-		 * misaligned, stop the discard at the previous aligned sector.
-		 */
-		end_sect = sector + req_sects;
-		tmp = end_sect;
-		if (req_sects < nr_sects &&
-		    sector_div(tmp, granularity) != alignment) {
-			end_sect = end_sect - alignment;
-			sector_div(end_sect, granularity);
-			end_sect = end_sect * granularity + alignment;
-			req_sects = end_sect - sector;
-		}
-
-		if (bio) {
-			int ret = submit_bio_wait(0, bio);
-			bio_put(bio);
-			if (ret)
-				return ret;
-		}
-		bio = f2fs_bio_alloc(1);
-		bio->bi_sector = sector;
-		bio->bi_bdev = bdev;
-		bio_set_op_attrs(bio, op, 0);
-
-		bio->bi_size = req_sects << 9;
-		nr_sects -= req_sects;
-		sector = end_sect;
-
-		/*
-		 * We can loop for a long time in here, if someone does
-		 * full device discards (like mkfs). Be nice and allow
-		 * us to schedule out to avoid softlocking if preempt
-		 * is disabled.
-		 */
-		cond_resched();
-	}
-
-	*biop = bio;
-	return 0;
-}
-
-static void __submit_discard_cmd(struct f2fs_sb_info *sbi,
-				struct discard_cmd *dc)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct bio *bio = NULL;
-
-	if (dc->state != D_PREP)
-		return;
-
-	trace_f2fs_issue_discard(dc->bdev, dc->start, dc->len);
-
-	dc->error = __blkdev_issue_discard(dc->bdev,
-				SECTOR_FROM_BLOCK(dc->start),
-				SECTOR_FROM_BLOCK(dc->len),
-				GFP_NOFS, 0, &bio);
-	if (!dc->error) {
-		/* should keep before submission to avoid D_DONE right away */
-		dc->state = D_SUBMIT;
-		atomic_inc(&dcc->issued_discard);
-		atomic_inc(&dcc->issing_discard);
-		if (bio) {
-			bio->bi_private = dc;
-			bio->bi_end_io = f2fs_submit_discard_endio;
-			submit_bio(REQ_SYNC, bio);
-			list_move_tail(&dc->list, &dcc->wait_list);
-		}
-	} else {
-		__remove_discard_cmd(sbi, dc);
-	}
-}
-
-static struct discard_cmd *__insert_discard_tree(struct f2fs_sb_info *sbi,
-				struct block_device *bdev, block_t lstart,
-				block_t start, block_t len,
-				struct rb_node **insert_p,
-				struct rb_node *insert_parent)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct rb_node **p = &dcc->root.rb_node;
-	struct rb_node *parent = NULL;
-	struct discard_cmd *dc = NULL;
-
-	if (insert_p && insert_parent) {
-		parent = insert_parent;
-		p = insert_p;
-		goto do_insert;
-	}
-
-	p = __lookup_rb_tree_for_insert(sbi, &dcc->root, &parent, lstart);
-do_insert:
-	dc = __attach_discard_cmd(sbi, bdev, lstart, start, len, parent, p);
-	if (!dc)
-		return NULL;
-
-	return dc;
-}
-
-static void __relocate_discard_cmd(struct discard_cmd_control *dcc,
-						struct discard_cmd *dc)
-{
-	list_move_tail(&dc->list, &dcc->pend_list[plist_idx(dc->len)]);
-}
-
-static void __punch_discard_cmd(struct f2fs_sb_info *sbi,
-				struct discard_cmd *dc, block_t blkaddr)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct discard_info di = dc->di;
-	bool modified = false;
-
-	if (dc->state == D_DONE || dc->len == 1) {
-		__remove_discard_cmd(sbi, dc);
-		return;
-	}
-
-	dcc->undiscard_blks -= di.len;
-
-	if (blkaddr > di.lstart) {
-		dc->len = blkaddr - dc->lstart;
-		dcc->undiscard_blks += dc->len;
-		__relocate_discard_cmd(dcc, dc);
-		f2fs_bug_on(sbi, !__check_rb_tree_consistence(sbi, &dcc->root));
-		modified = true;
-	}
-
-	if (blkaddr < di.lstart + di.len - 1) {
-		if (modified) {
-			__insert_discard_tree(sbi, dc->bdev, blkaddr + 1,
-					di.start + blkaddr + 1 - di.lstart,
-					di.lstart + di.len - 1 - blkaddr,
-					NULL, NULL);
-			f2fs_bug_on(sbi,
-				!__check_rb_tree_consistence(sbi, &dcc->root));
-		} else {
-			dc->lstart++;
-			dc->len--;
-			dc->start++;
-			dcc->undiscard_blks += dc->len;
-			__relocate_discard_cmd(dcc, dc);
-			f2fs_bug_on(sbi,
-				!__check_rb_tree_consistence(sbi, &dcc->root));
-		}
-	}
-}
-
-static void __update_discard_tree_range(struct f2fs_sb_info *sbi,
-				struct block_device *bdev, block_t lstart,
-				block_t start, block_t len)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct discard_cmd *prev_dc = NULL, *next_dc = NULL;
-	struct discard_cmd *dc;
-	struct discard_info di = {0};
-	struct rb_node **insert_p = NULL, *insert_parent = NULL;
-	block_t end = lstart + len;
-
-	mutex_lock(&dcc->cmd_lock);
-
-	dc = (struct discard_cmd *)__lookup_rb_tree_ret(&dcc->root,
-					NULL, lstart,
-					(struct rb_entry **)&prev_dc,
-					(struct rb_entry **)&next_dc,
-					&insert_p, &insert_parent, true);
-	if (dc)
-		prev_dc = dc;
-
-	if (!prev_dc) {
-		di.lstart = lstart;
-		di.len = next_dc ? next_dc->lstart - lstart : len;
-		di.len = min(di.len, len);
-		di.start = start;
-	}
-
-	while (1) {
-		struct rb_node *node;
-		bool merged = false;
-		struct discard_cmd *tdc = NULL;
-
-		if (prev_dc) {
-			di.lstart = prev_dc->lstart + prev_dc->len;
-			if (di.lstart < lstart)
-				di.lstart = lstart;
-			if (di.lstart >= end)
-				break;
-
-			if (!next_dc || next_dc->lstart > end)
-				di.len = end - di.lstart;
-			else
-				di.len = next_dc->lstart - di.lstart;
-			di.start = start + di.lstart - lstart;
-		}
-
-		if (!di.len)
-			goto next;
-
-		if (prev_dc && prev_dc->state == D_PREP &&
-			prev_dc->bdev == bdev &&
-			__is_discard_back_mergeable(&di, &prev_dc->di)) {
-			prev_dc->di.len += di.len;
-			dcc->undiscard_blks += di.len;
-			__relocate_discard_cmd(dcc, prev_dc);
-			f2fs_bug_on(sbi,
-				!__check_rb_tree_consistence(sbi, &dcc->root));
-			di = prev_dc->di;
-			tdc = prev_dc;
-			merged = true;
-		}
-
-		if (next_dc && next_dc->state == D_PREP &&
-			next_dc->bdev == bdev &&
-			__is_discard_front_mergeable(&di, &next_dc->di)) {
-			next_dc->di.lstart = di.lstart;
-			next_dc->di.len += di.len;
-			next_dc->di.start = di.start;
-			dcc->undiscard_blks += di.len;
-			__relocate_discard_cmd(dcc, next_dc);
-			if (tdc)
-				__remove_discard_cmd(sbi, tdc);
-			f2fs_bug_on(sbi,
-				!__check_rb_tree_consistence(sbi, &dcc->root));
-			merged = true;
-		}
-
-		if (!merged) {
-			__insert_discard_tree(sbi, bdev, di.lstart, di.start,
-							di.len, NULL, NULL);
-			f2fs_bug_on(sbi,
-				!__check_rb_tree_consistence(sbi, &dcc->root));
-		}
- next:
-		prev_dc = next_dc;
-		if (!prev_dc)
-			break;
-
-		node = rb_next(&prev_dc->rb_node);
-		next_dc = rb_entry_safe(node, struct discard_cmd, rb_node);
-	}
-
-	mutex_unlock(&dcc->cmd_lock);
-}
-
-static int __queue_discard_cmd(struct f2fs_sb_info *sbi,
-		struct block_device *bdev, block_t blkstart, block_t blklen)
-{
-	block_t lblkstart = blkstart;
-
-	trace_f2fs_queue_discard(bdev, blkstart, blklen);
-
-	if (sbi->s_ndevs) {
-		int devi = f2fs_target_device_index(sbi, blkstart);
-
-		blkstart -= FDEV(devi).start_blk;
-	}
-	__update_discard_tree_range(sbi, bdev, lblkstart, blkstart, blklen);
-	return 0;
-}
-
-static void __issue_discard_cmd(struct f2fs_sb_info *sbi, bool issue_cond)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct list_head *pend_list;
-	struct discard_cmd *dc, *tmp;
-	struct blk_plug plug;
-	int i, iter = 0;
-
-	mutex_lock(&dcc->cmd_lock);
-	blk_start_plug(&plug);
-	for (i = MAX_PLIST_NUM - 1; i >= 0; i--) {
-		pend_list = &dcc->pend_list[i];
-		list_for_each_entry_safe(dc, tmp, pend_list, list) {
-			f2fs_bug_on(sbi, dc->state != D_PREP);
-
-			if (!issue_cond || is_idle(sbi))
-				__submit_discard_cmd(sbi, dc);
-			if (issue_cond && iter++ > DISCARD_ISSUE_RATE)
-				goto out;
-		}
-	}
-out:
-	blk_finish_plug(&plug);
-	mutex_unlock(&dcc->cmd_lock);
-}
-
-static void __wait_discard_cmd(struct f2fs_sb_info *sbi, bool wait_cond)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct list_head *wait_list = &(dcc->wait_list);
-	struct discard_cmd *dc, *tmp;
-
-	mutex_lock(&dcc->cmd_lock);
-	list_for_each_entry_safe(dc, tmp, wait_list, list) {
-		if (!wait_cond || dc->state == D_DONE) {
-			if (dc->ref)
-				continue;
-			wait_for_completion_io(&dc->wait);
-			__remove_discard_cmd(sbi, dc);
-		}
-	}
-	mutex_unlock(&dcc->cmd_lock);
-}
-
-/* This should be covered by global mutex, &sit_i->sentry_lock */
-void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	struct discard_cmd *dc;
-	bool need_wait = false;
-
-	mutex_lock(&dcc->cmd_lock);
-	dc = (struct discard_cmd *)__lookup_rb_tree(&dcc->root, NULL, blkaddr);
-	if (dc) {
-		if (dc->state == D_PREP) {
-			__punch_discard_cmd(sbi, dc, blkaddr);
-		} else {
-			dc->ref++;
-			need_wait = true;
-		}
-	}
-	mutex_unlock(&dcc->cmd_lock);
-
-	if (need_wait) {
-		wait_for_completion_io(&dc->wait);
-		mutex_lock(&dcc->cmd_lock);
-		f2fs_bug_on(sbi, dc->state != D_DONE);
-		dc->ref--;
-		if (!dc->ref)
-			__remove_discard_cmd(sbi, dc);
-		mutex_unlock(&dcc->cmd_lock);
-	}
-}
-
-/* This comes from f2fs_put_super */
-void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)
-{
-	__issue_discard_cmd(sbi, false);
-	__wait_discard_cmd(sbi, false);
-}
-
-static int issue_discard_thread(void *data)
-{
-	struct f2fs_sb_info *sbi = data;
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-	wait_queue_head_t *q = &dcc->discard_wait_queue;
-repeat:
-	if (kthread_should_stop())
-		return 0;
-
-	sb_start_intwrite(sbi->sb);
-
-	__issue_discard_cmd(sbi, true);
-	__wait_discard_cmd(sbi, true);
-
-	sb_end_intwrite(sbi->sb);
-
-	congestion_wait(BLK_RW_SYNC, HZ/50);
-
-	wait_event_interruptible(*q, kthread_should_stop() ||
-				atomic_read(&dcc->discard_cmd_cnt));
-	goto repeat;
-}
-
-#ifdef CONFIG_BLK_DEV_ZONED
-static int __f2fs_issue_discard_zone(struct f2fs_sb_info *sbi,
-		struct block_device *bdev, block_t blkstart, block_t blklen)
-{
-	sector_t sector, nr_sects;
-	block_t lblkstart = blkstart;
-	int devi = 0;
-
-	if (sbi->s_ndevs) {
-		devi = f2fs_target_device_index(sbi, blkstart);
-		blkstart -= FDEV(devi).start_blk;
-	}
-
-	/*
-	 * We need to know the type of the zone: for conventional zones,
-	 * use regular discard if the drive supports it. For sequential
-	 * zones, reset the zone write pointer.
-	 */
-	switch (get_blkz_type(sbi, bdev, blkstart)) {
-
-	case BLK_ZONE_TYPE_CONVENTIONAL:
-		if (!blk_queue_discard(bdev_get_queue(bdev)))
-			return 0;
-		return __queue_discard_cmd(sbi, bdev, lblkstart, blklen);
-	case BLK_ZONE_TYPE_SEQWRITE_REQ:
-	case BLK_ZONE_TYPE_SEQWRITE_PREF:
-		sector = SECTOR_FROM_BLOCK(blkstart);
-		nr_sects = SECTOR_FROM_BLOCK(blklen);
-
-		if (sector & (bdev_zone_size(bdev) - 1) ||
-				nr_sects != bdev_zone_size(bdev)) {
-			f2fs_msg(sbi->sb, KERN_INFO,
-				"(%d) %s: Unaligned discard attempted (block %x + %x)",
-				devi, sbi->s_ndevs ? FDEV(devi).path: "",
-				blkstart, blklen);
-			return -EIO;
-		}
-		trace_f2fs_issue_reset_zone(bdev, blkstart);
-		return blkdev_reset_zones(bdev, sector,
-					  nr_sects, GFP_NOFS);
-	default:
-		/* Unknown zone type: broken device ? */
-		return -EIO;
-	}
-}
-#endif
-
-static int __issue_discard_async(struct f2fs_sb_info *sbi,
-		struct block_device *bdev, block_t blkstart, block_t blklen)
-{
-#ifdef CONFIG_BLK_DEV_ZONED
-	if (f2fs_sb_mounted_blkzoned(sbi->sb) &&
-				bdev_zoned_model(bdev) != BLK_ZONED_NONE)
-		return __f2fs_issue_discard_zone(sbi, bdev, blkstart, blklen);
-#endif
-	return __queue_discard_cmd(sbi, bdev, blkstart, blklen);
-}
-
-static int f2fs_issue_discard(struct f2fs_sb_info *sbi,
-				block_t blkstart, block_t blklen)
-{
-	sector_t start = blkstart, len = 0;
-	struct block_device *bdev;
-	struct seg_entry *se;
-	unsigned int offset;
-	block_t i;
-	int err = 0;
-
-	bdev = f2fs_target_device(sbi, blkstart, NULL);
-
-	for (i = blkstart; i < blkstart + blklen; i++, len++) {
-		if (i != start) {
-			struct block_device *bdev2 =
-				f2fs_target_device(sbi, i, NULL);
-
-			if (bdev2 != bdev) {
-				err = __issue_discard_async(sbi, bdev,
-						start, len);
-				if (err)
-					return err;
-				bdev = bdev2;
-				start = i;
-				len = 0;
-			}
-		}
-
-		se = get_seg_entry(sbi, GET_SEGNO(sbi, i));
-		offset = GET_BLKOFF_FROM_SEG0(sbi, i);
-
-		if (!f2fs_test_and_set_bit(offset, se->discard_map))
-			sbi->discard_blks--;
-	}
-
-	if (len)
-		err = __issue_discard_async(sbi, bdev, start, len);
-	return err;
-}
-
-static bool add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc,
-							bool check_only)
-{
-	int entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);
-	int max_blocks = sbi->blocks_per_seg;
-	struct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);
-	unsigned long *cur_map = (unsigned long *)se->cur_valid_map;
-	unsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;
-	unsigned long *discard_map = (unsigned long *)se->discard_map;
-	unsigned long *dmap = SIT_I(sbi)->tmp_map;
-	unsigned int start = 0, end = -1;
-	bool force = (cpc->reason & CP_DISCARD);
-	struct discard_entry *de = NULL;
-	struct list_head *head = &SM_I(sbi)->dcc_info->entry_list;
-	int i;
-
-	if (se->valid_blocks == max_blocks || !f2fs_discard_en(sbi))
-		return false;
-
-	if (!force) {
-		if (!test_opt(sbi, DISCARD) || !se->valid_blocks ||
-			SM_I(sbi)->dcc_info->nr_discards >=
-				SM_I(sbi)->dcc_info->max_discards)
-			return false;
-	}
-
-	/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */
-	for (i = 0; i < entries; i++)
-		dmap[i] = force ? ~ckpt_map[i] & ~discard_map[i] :
-				(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];
-
-	while (force || SM_I(sbi)->dcc_info->nr_discards <=
-				SM_I(sbi)->dcc_info->max_discards) {
-		start = __find_rev_next_bit(dmap, max_blocks, end + 1);
-		if (start >= max_blocks)
-			break;
-
-		end = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);
-		if (force && start && end != max_blocks
-					&& (end - start) < cpc->trim_minlen)
-			continue;
-
-		if (check_only)
-			return true;
-
-		if (!de) {
-			de = f2fs_kmem_cache_alloc(discard_entry_slab,
-								GFP_F2FS_ZERO);
-			de->start_blkaddr = START_BLOCK(sbi, cpc->trim_start);
-			list_add_tail(&de->list, head);
-		}
-
-		for (i = start; i < end; i++)
-			__set_bit_le(i, (void *)de->discard_map);
-
-		SM_I(sbi)->dcc_info->nr_discards += end - start;
-	}
-	return false;
-}
-
-void release_discard_addrs(struct f2fs_sb_info *sbi)
-{
-	struct list_head *head = &(SM_I(sbi)->dcc_info->entry_list);
-	struct discard_entry *entry, *this;
-
-	/* drop caches */
-	list_for_each_entry_safe(entry, this, head, list) {
-		list_del(&entry->list);
-		kmem_cache_free(discard_entry_slab, entry);
-	}
-}
-
-/*
- * Should call clear_prefree_segments after checkpoint is done.
- */
-static void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned int segno;
-
-	mutex_lock(&dirty_i->seglist_lock);
-	for_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))
-		__set_test_and_free(sbi, segno);
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	struct list_head *head = &(SM_I(sbi)->dcc_info->entry_list);
-	struct discard_entry *entry, *this;
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned long *prefree_map = dirty_i->dirty_segmap[PRE];
-	unsigned int start = 0, end = -1;
-	unsigned int secno, start_segno;
-	bool force = (cpc->reason & CP_DISCARD);
-
-	mutex_lock(&dirty_i->seglist_lock);
-
-	while (1) {
-		int i;
-		start = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);
-		if (start >= MAIN_SEGS(sbi))
-			break;
-		end = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),
-								start + 1);
-
-		for (i = start; i < end; i++)
-			clear_bit(i, prefree_map);
-
-		dirty_i->nr_dirty[PRE] -= end - start;
-
-		if (!test_opt(sbi, DISCARD))
-			continue;
-
-		if (force && start >= cpc->trim_start &&
-					(end - 1) <= cpc->trim_end)
-				continue;
-
-		if (!test_opt(sbi, LFS) || sbi->segs_per_sec == 1) {
-			f2fs_issue_discard(sbi, START_BLOCK(sbi, start),
-				(end - start) << sbi->log_blocks_per_seg);
-			continue;
-		}
-next:
-		secno = GET_SEC_FROM_SEG(sbi, start);
-		start_segno = GET_SEG_FROM_SEC(sbi, secno);
-		if (!IS_CURSEC(sbi, secno) &&
-			!get_valid_blocks(sbi, start, true))
-			f2fs_issue_discard(sbi, START_BLOCK(sbi, start_segno),
-				sbi->segs_per_sec << sbi->log_blocks_per_seg);
-
-		start = start_segno + sbi->segs_per_sec;
-		if (start < end)
-			goto next;
-		else
-			end = start - 1;
-	}
-	mutex_unlock(&dirty_i->seglist_lock);
-
-	/* send small discards */
-	list_for_each_entry_safe(entry, this, head, list) {
-		unsigned int cur_pos = 0, next_pos, len, total_len = 0;
-		bool is_valid = test_bit_le(0, entry->discard_map);
-
-find_next:
-		if (is_valid) {
-			next_pos = find_next_zero_bit_le(entry->discard_map,
-					sbi->blocks_per_seg, cur_pos);
-			len = next_pos - cur_pos;
-
-			if (force && len < cpc->trim_minlen)
-				goto skip;
-
-			f2fs_issue_discard(sbi, entry->start_blkaddr + cur_pos,
-									len);
-			cpc->trimmed += len;
-			total_len += len;
-		} else {
-			next_pos = find_next_bit_le(entry->discard_map,
-					sbi->blocks_per_seg, cur_pos);
-		}
-skip:
-		cur_pos = next_pos;
-		is_valid = !is_valid;
-
-		if (cur_pos < sbi->blocks_per_seg)
-			goto find_next;
-
-		list_del(&entry->list);
-		SM_I(sbi)->dcc_info->nr_discards -= total_len;
-		kmem_cache_free(discard_entry_slab, entry);
-	}
-
-	wake_up(&SM_I(sbi)->dcc_info->discard_wait_queue);
-}
-
-static int create_discard_cmd_control(struct f2fs_sb_info *sbi)
-{
-	dev_t dev = sbi->sb->s_bdev->bd_dev;
-	struct discard_cmd_control *dcc;
-	int err = 0, i;
-
-	if (SM_I(sbi)->dcc_info) {
-		dcc = SM_I(sbi)->dcc_info;
-		goto init_thread;
-	}
-
-	dcc = kzalloc(sizeof(struct discard_cmd_control), GFP_KERNEL);
-	if (!dcc)
-		return -ENOMEM;
-
-	INIT_LIST_HEAD(&dcc->entry_list);
-	for (i = 0; i < MAX_PLIST_NUM; i++)
-		INIT_LIST_HEAD(&dcc->pend_list[i]);
-	INIT_LIST_HEAD(&dcc->wait_list);
-	mutex_init(&dcc->cmd_lock);
-	atomic_set(&dcc->issued_discard, 0);
-	atomic_set(&dcc->issing_discard, 0);
-	atomic_set(&dcc->discard_cmd_cnt, 0);
-	dcc->nr_discards = 0;
-	dcc->max_discards = MAIN_SEGS(sbi) << sbi->log_blocks_per_seg;
-	dcc->undiscard_blks = 0;
-	dcc->root = RB_ROOT;
-
-	init_waitqueue_head(&dcc->discard_wait_queue);
-	SM_I(sbi)->dcc_info = dcc;
-init_thread:
-	dcc->f2fs_issue_discard = kthread_run(issue_discard_thread, sbi,
-				"f2fs_discard-%u:%u", MAJOR(dev), MINOR(dev));
-	if (IS_ERR(dcc->f2fs_issue_discard)) {
-		err = PTR_ERR(dcc->f2fs_issue_discard);
-		kfree(dcc);
-		SM_I(sbi)->dcc_info = NULL;
-		return err;
-	}
-
-	return err;
-}
-
-static void destroy_discard_cmd_control(struct f2fs_sb_info *sbi)
-{
-	struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;
-
-	if (!dcc)
-		return;
-
-	if (dcc->f2fs_issue_discard) {
-		struct task_struct *discard_thread = dcc->f2fs_issue_discard;
-
-		dcc->f2fs_issue_discard = NULL;
-		kthread_stop(discard_thread);
-	}
-
-	kfree(dcc);
-	SM_I(sbi)->dcc_info = NULL;
-}
-
-static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-
-	if (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {
-		sit_i->dirty_sentries++;
-		return false;
-	}
-
-	return true;
-}
-
-static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,
-					unsigned int segno, int modified)
-{
-	struct seg_entry *se = get_seg_entry(sbi, segno);
-	se->type = type;
-	if (modified)
-		__mark_sit_entry_dirty(sbi, segno);
-}
-
-static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)
-{
-	struct seg_entry *se;
-	unsigned int segno, offset;
-	long int new_vblocks;
-
-	segno = GET_SEGNO(sbi, blkaddr);
-
-	se = get_seg_entry(sbi, segno);
-	new_vblocks = se->valid_blocks + del;
-	offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);
-
-	f2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||
-				(new_vblocks > sbi->blocks_per_seg)));
-
-	se->valid_blocks = new_vblocks;
-	se->mtime = get_mtime(sbi);
-	SIT_I(sbi)->max_mtime = se->mtime;
-
-	/* Update valid block bitmap */
-	if (del > 0) {
-		if (f2fs_test_and_set_bit(offset, se->cur_valid_map)) {
-#ifdef CONFIG_F2FS_CHECK_FS
-			if (f2fs_test_and_set_bit(offset,
-						se->cur_valid_map_mir))
-				f2fs_bug_on(sbi, 1);
-			else
-				WARN_ON(1);
-#else
-			f2fs_bug_on(sbi, 1);
-#endif
-		}
-		if (f2fs_discard_en(sbi) &&
-			!f2fs_test_and_set_bit(offset, se->discard_map))
-			sbi->discard_blks--;
-
-		/* don't overwrite by SSR to keep node chain */
-		if (se->type == CURSEG_WARM_NODE) {
-			if (!f2fs_test_and_set_bit(offset, se->ckpt_valid_map))
-				se->ckpt_valid_blocks++;
-		}
-	} else {
-		if (!f2fs_test_and_clear_bit(offset, se->cur_valid_map)) {
-#ifdef CONFIG_F2FS_CHECK_FS
-			if (!f2fs_test_and_clear_bit(offset,
-						se->cur_valid_map_mir))
-				f2fs_bug_on(sbi, 1);
-			else
-				WARN_ON(1);
-#else
-			f2fs_bug_on(sbi, 1);
-#endif
-		}
-		if (f2fs_discard_en(sbi) &&
-			f2fs_test_and_clear_bit(offset, se->discard_map))
-			sbi->discard_blks++;
-	}
-	if (!f2fs_test_bit(offset, se->ckpt_valid_map))
-		se->ckpt_valid_blocks += del;
-
-	__mark_sit_entry_dirty(sbi, segno);
-
-	/* update total number of valid blocks to be written in ckpt area */
-	SIT_I(sbi)->written_valid_blocks += del;
-
-	if (sbi->segs_per_sec > 1)
-		get_sec_entry(sbi, segno)->valid_blocks += del;
-}
-
-void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)
-{
-	update_sit_entry(sbi, new, 1);
-	if (GET_SEGNO(sbi, old) != NULL_SEGNO)
-		update_sit_entry(sbi, old, -1);
-
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, old));
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, new));
-}
-
-void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)
-{
-	unsigned int segno = GET_SEGNO(sbi, addr);
-	struct sit_info *sit_i = SIT_I(sbi);
-
-	f2fs_bug_on(sbi, addr == NULL_ADDR);
-	if (addr == NEW_ADDR)
-		return;
-
-	/* add it into sit main buffer */
-	mutex_lock(&sit_i->sentry_lock);
-
-	update_sit_entry(sbi, addr, -1);
-
-	/* add it into dirty seglist */
-	locate_dirty_segment(sbi, segno);
-
-	mutex_unlock(&sit_i->sentry_lock);
-}
-
-bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int segno, offset;
-	struct seg_entry *se;
-	bool is_cp = false;
-
-	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
-		return true;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	segno = GET_SEGNO(sbi, blkaddr);
-	se = get_seg_entry(sbi, segno);
-	offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);
-
-	if (f2fs_test_bit(offset, se->ckpt_valid_map))
-		is_cp = true;
-
-	mutex_unlock(&sit_i->sentry_lock);
-
-	return is_cp;
-}
-
-/*
- * This function should be resided under the curseg_mutex lock
- */
-static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,
-					struct f2fs_summary *sum)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	void *addr = curseg->sum_blk;
-	addr += curseg->next_blkoff * sizeof(struct f2fs_summary);
-	memcpy(addr, sum, sizeof(struct f2fs_summary));
-}
-
-/*
- * Calculate the number of current summary pages for writing
- */
-int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)
-{
-	int valid_sum_count = 0;
-	int i, sum_in_page;
-
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		if (sbi->ckpt->alloc_type[i] == SSR)
-			valid_sum_count += sbi->blocks_per_seg;
-		else {
-			if (for_ra)
-				valid_sum_count += le16_to_cpu(
-					F2FS_CKPT(sbi)->cur_data_blkoff[i]);
-			else
-				valid_sum_count += curseg_blkoff(sbi, i);
-		}
-	}
-
-	sum_in_page = (PAGE_SIZE - 2 * SUM_JOURNAL_SIZE -
-			SUM_FOOTER_SIZE) / SUMMARY_SIZE;
-	if (valid_sum_count <= sum_in_page)
-		return 1;
-	else if ((valid_sum_count - sum_in_page) <=
-		(PAGE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)
-		return 2;
-	return 3;
-}
-
-/*
- * Caller should put this summary page
- */
-struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	return get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));
-}
-
-void update_meta_page(struct f2fs_sb_info *sbi, void *src, block_t blk_addr)
-{
-	struct page *page = grab_meta_page(sbi, blk_addr);
-	void *dst = page_address(page);
-
-	if (src)
-		memcpy(dst, src, PAGE_SIZE);
-	else
-		memset(dst, 0, PAGE_SIZE);
-	set_page_dirty(page);
-	f2fs_put_page(page, 1);
-}
-
-static void write_sum_page(struct f2fs_sb_info *sbi,
-			struct f2fs_summary_block *sum_blk, block_t blk_addr)
-{
-	update_meta_page(sbi, (void *)sum_blk, blk_addr);
-}
-
-static void write_current_sum_page(struct f2fs_sb_info *sbi,
-						int type, block_t blk_addr)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	struct page *page = grab_meta_page(sbi, blk_addr);
-	struct f2fs_summary_block *src = curseg->sum_blk;
-	struct f2fs_summary_block *dst;
-
-	dst = (struct f2fs_summary_block *)page_address(page);
-
-	mutex_lock(&curseg->curseg_mutex);
-
-	down_read(&curseg->journal_rwsem);
-	memcpy(&dst->journal, curseg->journal, SUM_JOURNAL_SIZE);
-	up_read(&curseg->journal_rwsem);
-
-	memcpy(dst->entries, src->entries, SUM_ENTRY_SIZE);
-	memcpy(&dst->footer, &src->footer, SUM_FOOTER_SIZE);
-
-	mutex_unlock(&curseg->curseg_mutex);
-
-	set_page_dirty(page);
-	f2fs_put_page(page, 1);
-}
-
-static int is_next_segment_free(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int segno = curseg->segno + 1;
-	struct free_segmap_info *free_i = FREE_I(sbi);
-
-	if (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)
-		return !test_bit(segno, free_i->free_segmap);
-	return 0;
-}
-
-/*
- * Find a new segment from the free segments bitmap to right order
- * This function should be returned with success, otherwise BUG
- */
-static void get_new_segment(struct f2fs_sb_info *sbi,
-			unsigned int *newseg, bool new_sec, int dir)
-{
-	struct free_segmap_info *free_i = FREE_I(sbi);
-	unsigned int segno, secno, zoneno;
-	unsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;
-	unsigned int hint = GET_SEC_FROM_SEG(sbi, *newseg);
-	unsigned int old_zoneno = GET_ZONE_FROM_SEG(sbi, *newseg);
-	unsigned int left_start = hint;
-	bool init = true;
-	int go_left = 0;
-	int i;
-
-	spin_lock(&free_i->segmap_lock);
-
-	if (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {
-		segno = find_next_zero_bit(free_i->free_segmap,
-			GET_SEG_FROM_SEC(sbi, hint + 1), *newseg + 1);
-		if (segno < GET_SEG_FROM_SEC(sbi, hint + 1))
-			goto got_it;
-	}
-find_other_zone:
-	secno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);
-	if (secno >= MAIN_SECS(sbi)) {
-		if (dir == ALLOC_RIGHT) {
-			secno = find_next_zero_bit(free_i->free_secmap,
-							MAIN_SECS(sbi), 0);
-			f2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));
-		} else {
-			go_left = 1;
-			left_start = hint - 1;
-		}
-	}
-	if (go_left == 0)
-		goto skip_left;
-
-	while (test_bit(left_start, free_i->free_secmap)) {
-		if (left_start > 0) {
-			left_start--;
-			continue;
-		}
-		left_start = find_next_zero_bit(free_i->free_secmap,
-							MAIN_SECS(sbi), 0);
-		f2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));
-		break;
-	}
-	secno = left_start;
-skip_left:
-	hint = secno;
-	segno = GET_SEG_FROM_SEC(sbi, secno);
-	zoneno = GET_ZONE_FROM_SEC(sbi, secno);
-
-	/* give up on finding another zone */
-	if (!init)
-		goto got_it;
-	if (sbi->secs_per_zone == 1)
-		goto got_it;
-	if (zoneno == old_zoneno)
-		goto got_it;
-	if (dir == ALLOC_LEFT) {
-		if (!go_left && zoneno + 1 >= total_zones)
-			goto got_it;
-		if (go_left && zoneno == 0)
-			goto got_it;
-	}
-	for (i = 0; i < NR_CURSEG_TYPE; i++)
-		if (CURSEG_I(sbi, i)->zone == zoneno)
-			break;
-
-	if (i < NR_CURSEG_TYPE) {
-		/* zone is in user, try another */
-		if (go_left)
-			hint = zoneno * sbi->secs_per_zone - 1;
-		else if (zoneno + 1 >= total_zones)
-			hint = 0;
-		else
-			hint = (zoneno + 1) * sbi->secs_per_zone;
-		init = false;
-		goto find_other_zone;
-	}
-got_it:
-	/* set it as dirty segment in free segmap */
-	f2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));
-	__set_inuse(sbi, segno);
-	*newseg = segno;
-	spin_unlock(&free_i->segmap_lock);
-}
-
-static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	struct summary_footer *sum_footer;
-
-	curseg->segno = curseg->next_segno;
-	curseg->zone = GET_ZONE_FROM_SEG(sbi, curseg->segno);
-	curseg->next_blkoff = 0;
-	curseg->next_segno = NULL_SEGNO;
-
-	sum_footer = &(curseg->sum_blk->footer);
-	memset(sum_footer, 0, sizeof(struct summary_footer));
-	if (IS_DATASEG(type))
-		SET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);
-	if (IS_NODESEG(type))
-		SET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);
-	__set_sit_entry_type(sbi, type, curseg->segno, modified);
-}
-
-static unsigned int __get_next_segno(struct f2fs_sb_info *sbi, int type)
-{
-	/* if segs_per_sec is large than 1, we need to keep original policy. */
-	if (sbi->segs_per_sec != 1)
-		return CURSEG_I(sbi, type)->segno;
-
-	if (type == CURSEG_HOT_DATA || IS_NODESEG(type))
-		return 0;
-
-	if (SIT_I(sbi)->last_victim[ALLOC_NEXT])
-		return SIT_I(sbi)->last_victim[ALLOC_NEXT];
-	return CURSEG_I(sbi, type)->segno;
-}
-
-/*
- * Allocate a current working segment.
- * This function always allocates a free segment in LFS manner.
- */
-static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int segno = curseg->segno;
-	int dir = ALLOC_LEFT;
-
-	write_sum_page(sbi, curseg->sum_blk,
-				GET_SUM_BLOCK(sbi, segno));
-	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
-		dir = ALLOC_RIGHT;
-
-	if (test_opt(sbi, NOHEAP))
-		dir = ALLOC_RIGHT;
-
-	segno = __get_next_segno(sbi, type);
-	get_new_segment(sbi, &segno, new_sec, dir);
-	curseg->next_segno = segno;
-	reset_curseg(sbi, type, 1);
-	curseg->alloc_type = LFS;
-}
-
-static void __next_free_blkoff(struct f2fs_sb_info *sbi,
-			struct curseg_info *seg, block_t start)
-{
-	struct seg_entry *se = get_seg_entry(sbi, seg->segno);
-	int entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);
-	unsigned long *target_map = SIT_I(sbi)->tmp_map;
-	unsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;
-	unsigned long *cur_map = (unsigned long *)se->cur_valid_map;
-	int i, pos;
-
-	for (i = 0; i < entries; i++)
-		target_map[i] = ckpt_map[i] | cur_map[i];
-
-	pos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);
-
-	seg->next_blkoff = pos;
-}
-
-/*
- * If a segment is written by LFS manner, next block offset is just obtained
- * by increasing the current block offset. However, if a segment is written by
- * SSR manner, next block offset obtained by calling __next_free_blkoff
- */
-static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,
-				struct curseg_info *seg)
-{
-	if (seg->alloc_type == SSR)
-		__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);
-	else
-		seg->next_blkoff++;
-}
-
-/*
- * This function always allocates a used segment(from dirty seglist) by SSR
- * manner, so it should recover the existing segment information of valid blocks
- */
-static void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int new_segno = curseg->next_segno;
-	struct f2fs_summary_block *sum_node;
-	struct page *sum_page;
-
-	write_sum_page(sbi, curseg->sum_blk,
-				GET_SUM_BLOCK(sbi, curseg->segno));
-	__set_test_and_inuse(sbi, new_segno);
-
-	mutex_lock(&dirty_i->seglist_lock);
-	__remove_dirty_segment(sbi, new_segno, PRE);
-	__remove_dirty_segment(sbi, new_segno, DIRTY);
-	mutex_unlock(&dirty_i->seglist_lock);
-
-	reset_curseg(sbi, type, 1);
-	curseg->alloc_type = SSR;
-	__next_free_blkoff(sbi, curseg, 0);
-
-	if (reuse) {
-		sum_page = get_sum_page(sbi, new_segno);
-		sum_node = (struct f2fs_summary_block *)page_address(sum_page);
-		memcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);
-		f2fs_put_page(sum_page, 1);
-	}
-}
-
-static int get_ssr_segment(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	const struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;
-	unsigned segno = NULL_SEGNO;
-	int i, cnt;
-	bool reversed = false;
-
-	/* need_SSR() already forces to do this */
-	if (v_ops->get_victim(sbi, &segno, BG_GC, type, SSR)) {
-		curseg->next_segno = segno;
-		return 1;
-	}
-
-	/* For node segments, let's do SSR more intensively */
-	if (IS_NODESEG(type)) {
-		if (type >= CURSEG_WARM_NODE) {
-			reversed = true;
-			i = CURSEG_COLD_NODE;
-		} else {
-			i = CURSEG_HOT_NODE;
-		}
-		cnt = NR_CURSEG_NODE_TYPE;
-	} else {
-		if (type >= CURSEG_WARM_DATA) {
-			reversed = true;
-			i = CURSEG_COLD_DATA;
-		} else {
-			i = CURSEG_HOT_DATA;
-		}
-		cnt = NR_CURSEG_DATA_TYPE;
-	}
-
-	for (; cnt-- > 0; reversed ? i-- : i++) {
-		if (i == type)
-			continue;
-		if (v_ops->get_victim(sbi, &segno, BG_GC, i, SSR)) {
-			curseg->next_segno = segno;
-			return 1;
-		}
-	}
-	return 0;
-}
-
-/*
- * flush out current segment and replace it with new segment
- * This function should be returned with success, otherwise BUG
- */
-static void allocate_segment_by_default(struct f2fs_sb_info *sbi,
-						int type, bool force)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-
-	if (force)
-		new_curseg(sbi, type, true);
-	else if (!is_set_ckpt_flags(sbi, CP_CRC_RECOVERY_FLAG) &&
-					type == CURSEG_WARM_NODE)
-		new_curseg(sbi, type, false);
-	else if (curseg->alloc_type == LFS && is_next_segment_free(sbi, type))
-		new_curseg(sbi, type, false);
-	else if (need_SSR(sbi) && get_ssr_segment(sbi, type))
-		change_curseg(sbi, type, true);
-	else
-		new_curseg(sbi, type, false);
-
-	stat_inc_seg_type(sbi, curseg);
-}
-
-void allocate_new_segments(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *curseg;
-	unsigned int old_segno;
-	int i;
-
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		curseg = CURSEG_I(sbi, i);
-		old_segno = curseg->segno;
-		SIT_I(sbi)->s_ops->allocate_segment(sbi, i, true);
-		locate_dirty_segment(sbi, old_segno);
-	}
-}
-
-static const struct segment_allocation default_salloc_ops = {
-	.allocate_segment = allocate_segment_by_default,
-};
-
-bool exist_trim_candidates(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	__u64 trim_start = cpc->trim_start;
-	bool has_candidate = false;
-
-	mutex_lock(&SIT_I(sbi)->sentry_lock);
-	for (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++) {
-		if (add_discard_addrs(sbi, cpc, true)) {
-			has_candidate = true;
-			break;
-		}
-	}
-	mutex_unlock(&SIT_I(sbi)->sentry_lock);
-
-	cpc->trim_start = trim_start;
-	return has_candidate;
-}
-
-int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)
-{
-	__u64 start = F2FS_BYTES_TO_BLK(range->start);
-	__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;
-	unsigned int start_segno, end_segno;
-	struct cp_control cpc;
-	int err = 0;
-
-	if (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)
-		return -EINVAL;
-
-	cpc.trimmed = 0;
-	if (end <= MAIN_BLKADDR(sbi))
-		goto out;
-
-	if (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {
-		f2fs_msg(sbi->sb, KERN_WARNING,
-			"Found FS corruption, run fsck to fix.");
-		goto out;
-	}
-
-	/* start/end segment number in main_area */
-	start_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);
-	end_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :
-						GET_SEGNO(sbi, end);
-	cpc.reason = CP_DISCARD;
-	cpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));
-
-	/* do checkpoint to issue discard commands safely */
-	for (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {
-		cpc.trim_start = start_segno;
-
-		if (sbi->discard_blks == 0)
-			break;
-		else if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))
-			cpc.trim_end = end_segno;
-		else
-			cpc.trim_end = min_t(unsigned int,
-				rounddown(start_segno +
-				BATCHED_TRIM_SEGMENTS(sbi),
-				sbi->segs_per_sec) - 1, end_segno);
-
-		mutex_lock(&sbi->gc_mutex);
-		err = write_checkpoint(sbi, &cpc);
-		mutex_unlock(&sbi->gc_mutex);
-		if (err)
-			break;
-
-		schedule();
-	}
-out:
-	range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);
-	return err;
-}
-
-static bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	if (curseg->next_blkoff < sbi->blocks_per_seg)
-		return true;
-	return false;
-}
-
-static int __get_segment_type_2(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA)
-		return CURSEG_HOT_DATA;
-	else
-		return CURSEG_HOT_NODE;
-}
-
-static int __get_segment_type_4(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA) {
-		struct inode *inode = page->mapping->host;
-
-		if (S_ISDIR(inode->i_mode))
-			return CURSEG_HOT_DATA;
-		else
-			return CURSEG_COLD_DATA;
-	} else {
-		if (IS_DNODE(page) && is_cold_node(page))
-			return CURSEG_WARM_NODE;
-		else
-			return CURSEG_COLD_NODE;
-	}
-}
-
-static int __get_segment_type_6(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA) {
-		struct inode *inode = page->mapping->host;
-
-		if (is_cold_data(page) || file_is_cold(inode))
-			return CURSEG_COLD_DATA;
-		if (is_inode_flag_set(inode, FI_HOT_DATA))
-			return CURSEG_HOT_DATA;
-		return CURSEG_WARM_DATA;
-	} else {
-		if (IS_DNODE(page))
-			return is_cold_node(page) ? CURSEG_WARM_NODE :
-						CURSEG_HOT_NODE;
-		return CURSEG_COLD_NODE;
-	}
-}
-
-static int __get_segment_type(struct page *page, enum page_type p_type)
-{
-	switch (F2FS_P_SB(page)->active_logs) {
-	case 2:
-		return __get_segment_type_2(page, p_type);
-	case 4:
-		return __get_segment_type_4(page, p_type);
-	}
-	/* NR_CURSEG_TYPE(6) logs by default */
-	f2fs_bug_on(F2FS_P_SB(page),
-		F2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE);
-	return __get_segment_type_6(page, p_type);
-}
-
-void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,
-		block_t old_blkaddr, block_t *new_blkaddr,
-		struct f2fs_summary *sum, int type)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-
-	mutex_lock(&curseg->curseg_mutex);
-	mutex_lock(&sit_i->sentry_lock);
-
-	*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);
-
-	f2fs_wait_discard_bio(sbi, *new_blkaddr);
-
-	/*
-	 * __add_sum_entry should be resided under the curseg_mutex
-	 * because, this function updates a summary entry in the
-	 * current summary block.
-	 */
-	__add_sum_entry(sbi, type, sum);
-
-	__refresh_next_blkoff(sbi, curseg);
-
-	stat_inc_block_count(sbi, curseg);
-
-	if (!__has_curseg_space(sbi, type))
-		sit_i->s_ops->allocate_segment(sbi, type, false);
-	/*
-	 * SIT information should be updated after segment allocation,
-	 * since we need to keep dirty segments precisely under SSR.
-	 */
-	refresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);
-
-	mutex_unlock(&sit_i->sentry_lock);
-
-	if (page && IS_NODESEG(type))
-		fill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));
-
-	mutex_unlock(&curseg->curseg_mutex);
-}
-
-static void do_write_page(struct f2fs_summary *sum, struct f2fs_io_info *fio)
-{
-	int type = __get_segment_type(fio->page, fio->type);
-	int err;
-
-	if (fio->type == NODE || fio->type == DATA)
-		mutex_lock(&fio->sbi->wio_mutex[fio->type]);
-reallocate:
-	allocate_data_block(fio->sbi, fio->page, fio->old_blkaddr,
-					&fio->new_blkaddr, sum, type);
-
-	/* writeout dirty page into bdev */
-	err = f2fs_submit_page_mbio(fio);
-	if (err == -EAGAIN) {
-		fio->old_blkaddr = fio->new_blkaddr;
-		goto reallocate;
-	}
-
-	if (fio->type == NODE || fio->type == DATA)
-		mutex_unlock(&fio->sbi->wio_mutex[fio->type]);
-}
-
-void write_meta_page(struct f2fs_sb_info *sbi, struct page *page)
-{
-	struct f2fs_io_info fio = {
-		.sbi = sbi,
-		.type = META,
-		.op = REQ_OP_WRITE,
-		.op_flags = REQ_SYNC | REQ_NOIDLE | REQ_META | REQ_PRIO,
-		.old_blkaddr = page->index,
-		.new_blkaddr = page->index,
-		.page = page,
-		.encrypted_page = NULL,
-	};
-
-	if (unlikely(page->index >= MAIN_BLKADDR(sbi)))
-		fio.op_flags &= ~REQ_META;
-
-	set_page_writeback(page);
-	f2fs_submit_page_mbio(&fio);
-}
-
-void write_node_page(unsigned int nid, struct f2fs_io_info *fio)
-{
-	struct f2fs_summary sum;
-
-	set_summary(&sum, nid, 0, 0);
-	do_write_page(&sum, fio);
-}
-
-void write_data_page(struct dnode_of_data *dn, struct f2fs_io_info *fio)
-{
-	struct f2fs_sb_info *sbi = fio->sbi;
-	struct f2fs_summary sum;
-	struct node_info ni;
-
-	f2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);
-	get_node_info(sbi, dn->nid, &ni);
-	set_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);
-	do_write_page(&sum, fio);
-	f2fs_update_data_blkaddr(dn, fio->new_blkaddr);
-}
-
-int rewrite_data_page(struct f2fs_io_info *fio)
-{
-	fio->new_blkaddr = fio->old_blkaddr;
-	stat_inc_inplace_blocks(fio->sbi);
-	return f2fs_submit_page_bio(fio);
-}
-
-void __f2fs_replace_block(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,
-				block_t old_blkaddr, block_t new_blkaddr,
-				bool recover_curseg, bool recover_newaddr)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg;
-	unsigned int segno, old_cursegno;
-	struct seg_entry *se;
-	int type;
-	unsigned short old_blkoff;
-
-	segno = GET_SEGNO(sbi, new_blkaddr);
-	se = get_seg_entry(sbi, segno);
-	type = se->type;
-
-	if (!recover_curseg) {
-		/* for recovery flow */
-		if (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {
-			if (old_blkaddr == NULL_ADDR)
-				type = CURSEG_COLD_DATA;
-			else
-				type = CURSEG_WARM_DATA;
-		}
-	} else {
-		if (!IS_CURSEG(sbi, segno))
-			type = CURSEG_WARM_DATA;
-	}
-
-	curseg = CURSEG_I(sbi, type);
-
-	mutex_lock(&curseg->curseg_mutex);
-	mutex_lock(&sit_i->sentry_lock);
-
-	old_cursegno = curseg->segno;
-	old_blkoff = curseg->next_blkoff;
-
-	/* change the current segment */
-	if (segno != curseg->segno) {
-		curseg->next_segno = segno;
-		change_curseg(sbi, type, true);
-	}
-
-	curseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);
-	__add_sum_entry(sbi, type, sum);
-
-	if (!recover_curseg || recover_newaddr)
-		update_sit_entry(sbi, new_blkaddr, 1);
-	if (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)
-		update_sit_entry(sbi, old_blkaddr, -1);
-
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, new_blkaddr));
-
-	locate_dirty_segment(sbi, old_cursegno);
-
-	if (recover_curseg) {
-		if (old_cursegno != curseg->segno) {
-			curseg->next_segno = old_cursegno;
-			change_curseg(sbi, type, true);
-		}
-		curseg->next_blkoff = old_blkoff;
-	}
-
-	mutex_unlock(&sit_i->sentry_lock);
-	mutex_unlock(&curseg->curseg_mutex);
-}
-
-void f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,
-				block_t old_addr, block_t new_addr,
-				unsigned char version, bool recover_curseg,
-				bool recover_newaddr)
-{
-	struct f2fs_summary sum;
-
-	set_summary(&sum, dn->nid, dn->ofs_in_node, version);
-
-	__f2fs_replace_block(sbi, &sum, old_addr, new_addr,
-					recover_curseg, recover_newaddr);
-
-	f2fs_update_data_blkaddr(dn, new_addr);
-}
-
-void f2fs_wait_on_page_writeback(struct page *page,
-				enum page_type type, bool ordered)
-{
-	if (PageWriteback(page)) {
-		struct f2fs_sb_info *sbi = F2FS_P_SB(page);
-
-		f2fs_submit_merged_bio_cond(sbi, page->mapping->host,
-						0, page->index, type, WRITE);
-		if (ordered)
-			wait_on_page_writeback(page);
-		else
-			/* wait_for_stable_page(page) doesn't support */
-			wait_on_page_writeback(page);
-	}
-}
-
-void f2fs_wait_on_encrypted_page_writeback(struct f2fs_sb_info *sbi,
-							block_t blkaddr)
-{
-	struct page *cpage;
-
-	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
-		return;
-
-	cpage = find_lock_page(META_MAPPING(sbi), blkaddr);
-	if (cpage) {
-		f2fs_wait_on_page_writeback(cpage, DATA, true);
-		f2fs_put_page(cpage, 1);
-	}
-}
-
-static int read_compacted_summaries(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct curseg_info *seg_i;
-	unsigned char *kaddr;
-	struct page *page;
-	block_t start;
-	int i, j, offset;
-
-	start = start_sum_block(sbi);
-
-	page = get_meta_page(sbi, start++);
-	kaddr = (unsigned char *)page_address(page);
-
-	/* Step 1: restore nat cache */
-	seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);
-	memcpy(seg_i->journal, kaddr, SUM_JOURNAL_SIZE);
-
-	/* Step 2: restore sit cache */
-	seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	memcpy(seg_i->journal, kaddr + SUM_JOURNAL_SIZE, SUM_JOURNAL_SIZE);
-	offset = 2 * SUM_JOURNAL_SIZE;
-
-	/* Step 3: restore summary entries */
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		unsigned short blk_off;
-		unsigned int segno;
-
-		seg_i = CURSEG_I(sbi, i);
-		segno = le32_to_cpu(ckpt->cur_data_segno[i]);
-		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);
-		seg_i->next_segno = segno;
-		reset_curseg(sbi, i, 0);
-		seg_i->alloc_type = ckpt->alloc_type[i];
-		seg_i->next_blkoff = blk_off;
-
-		if (seg_i->alloc_type == SSR)
-			blk_off = sbi->blocks_per_seg;
-
-		for (j = 0; j < blk_off; j++) {
-			struct f2fs_summary *s;
-			s = (struct f2fs_summary *)(kaddr + offset);
-			seg_i->sum_blk->entries[j] = *s;
-			offset += SUMMARY_SIZE;
-			if (offset + SUMMARY_SIZE <= PAGE_SIZE -
-						SUM_FOOTER_SIZE)
-				continue;
-
-			f2fs_put_page(page, 1);
-			page = NULL;
-
-			page = get_meta_page(sbi, start++);
-			kaddr = (unsigned char *)page_address(page);
-			offset = 0;
-		}
-	}
-	f2fs_put_page(page, 1);
-	return 0;
-}
-
-static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)
-{
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct f2fs_summary_block *sum;
-	struct curseg_info *curseg;
-	struct page *new;
-	unsigned short blk_off;
-	unsigned int segno = 0;
-	block_t blk_addr = 0;
-
-	/* get segment number and block addr */
-	if (IS_DATASEG(type)) {
-		segno = le32_to_cpu(ckpt->cur_data_segno[type]);
-		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -
-							CURSEG_HOT_DATA]);
-		if (__exist_node_summaries(sbi))
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);
-		else
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);
-	} else {
-		segno = le32_to_cpu(ckpt->cur_node_segno[type -
-							CURSEG_HOT_NODE]);
-		blk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -
-							CURSEG_HOT_NODE]);
-		if (__exist_node_summaries(sbi))
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,
-							type - CURSEG_HOT_NODE);
-		else
-			blk_addr = GET_SUM_BLOCK(sbi, segno);
-	}
-
-	new = get_meta_page(sbi, blk_addr);
-	sum = (struct f2fs_summary_block *)page_address(new);
-
-	if (IS_NODESEG(type)) {
-		if (__exist_node_summaries(sbi)) {
-			struct f2fs_summary *ns = &sum->entries[0];
-			int i;
-			for (i = 0; i < sbi->blocks_per_seg; i++, ns++) {
-				ns->version = 0;
-				ns->ofs_in_node = 0;
-			}
-		} else {
-			int err;
-
-			err = restore_node_summary(sbi, segno, sum);
-			if (err) {
-				f2fs_put_page(new, 1);
-				return err;
-			}
-		}
-	}
-
-	/* set uncompleted segment to curseg */
-	curseg = CURSEG_I(sbi, type);
-	mutex_lock(&curseg->curseg_mutex);
-
-	/* update journal info */
-	down_write(&curseg->journal_rwsem);
-	memcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);
-	up_write(&curseg->journal_rwsem);
-
-	memcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);
-	memcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);
-	curseg->next_segno = segno;
-	reset_curseg(sbi, type, 0);
-	curseg->alloc_type = ckpt->alloc_type[type];
-	curseg->next_blkoff = blk_off;
-	mutex_unlock(&curseg->curseg_mutex);
-	f2fs_put_page(new, 1);
-	return 0;
-}
-
-static int restore_curseg_summaries(struct f2fs_sb_info *sbi)
-{
-	int type = CURSEG_HOT_DATA;
-	int err;
-
-	if (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG)) {
-		int npages = npages_for_summary_flush(sbi, true);
-
-		if (npages >= 2)
-			ra_meta_pages(sbi, start_sum_block(sbi), npages,
-							META_CP, true);
-
-		/* restore for compacted data summary */
-		if (read_compacted_summaries(sbi))
-			return -EINVAL;
-		type = CURSEG_HOT_NODE;
-	}
-
-	if (__exist_node_summaries(sbi))
-		ra_meta_pages(sbi, sum_blk_addr(sbi, NR_CURSEG_TYPE, type),
-					NR_CURSEG_TYPE - type, META_CP, true);
-
-	for (; type <= CURSEG_COLD_NODE; type++) {
-		err = read_normal_summaries(sbi, type);
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
-static void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)
-{
-	struct page *page;
-	unsigned char *kaddr;
-	struct f2fs_summary *summary;
-	struct curseg_info *seg_i;
-	int written_size = 0;
-	int i, j;
-
-	page = grab_meta_page(sbi, blkaddr++);
-	kaddr = (unsigned char *)page_address(page);
-
-	/* Step 1: write nat cache */
-	seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);
-	memcpy(kaddr, seg_i->journal, SUM_JOURNAL_SIZE);
-	written_size += SUM_JOURNAL_SIZE;
-
-	/* Step 2: write sit cache */
-	seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	memcpy(kaddr + written_size, seg_i->journal, SUM_JOURNAL_SIZE);
-	written_size += SUM_JOURNAL_SIZE;
-
-	/* Step 3: write summary entries */
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		unsigned short blkoff;
-		seg_i = CURSEG_I(sbi, i);
-		if (sbi->ckpt->alloc_type[i] == SSR)
-			blkoff = sbi->blocks_per_seg;
-		else
-			blkoff = curseg_blkoff(sbi, i);
-
-		for (j = 0; j < blkoff; j++) {
-			if (!page) {
-				page = grab_meta_page(sbi, blkaddr++);
-				kaddr = (unsigned char *)page_address(page);
-				written_size = 0;
-			}
-			summary = (struct f2fs_summary *)(kaddr + written_size);
-			*summary = seg_i->sum_blk->entries[j];
-			written_size += SUMMARY_SIZE;
-
-			if (written_size + SUMMARY_SIZE <= PAGE_SIZE -
-							SUM_FOOTER_SIZE)
-				continue;
-
-			set_page_dirty(page);
-			f2fs_put_page(page, 1);
-			page = NULL;
-		}
-	}
-	if (page) {
-		set_page_dirty(page);
-		f2fs_put_page(page, 1);
-	}
-}
-
-static void write_normal_summaries(struct f2fs_sb_info *sbi,
-					block_t blkaddr, int type)
-{
-	int i, end;
-	if (IS_DATASEG(type))
-		end = type + NR_CURSEG_DATA_TYPE;
-	else
-		end = type + NR_CURSEG_NODE_TYPE;
-
-	for (i = type; i < end; i++)
-		write_current_sum_page(sbi, i, blkaddr + (i - type));
-}
-
-void write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)
-{
-	if (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG))
-		write_compacted_summaries(sbi, start_blk);
-	else
-		write_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);
-}
-
-void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)
-{
-	write_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);
-}
-
-int lookup_journal_in_cursum(struct f2fs_journal *journal, int type,
-					unsigned int val, int alloc)
-{
-	int i;
-
-	if (type == NAT_JOURNAL) {
-		for (i = 0; i < nats_in_cursum(journal); i++) {
-			if (le32_to_cpu(nid_in_journal(journal, i)) == val)
-				return i;
-		}
-		if (alloc && __has_cursum_space(journal, 1, NAT_JOURNAL))
-			return update_nats_in_cursum(journal, 1);
-	} else if (type == SIT_JOURNAL) {
-		for (i = 0; i < sits_in_cursum(journal); i++)
-			if (le32_to_cpu(segno_in_journal(journal, i)) == val)
-				return i;
-		if (alloc && __has_cursum_space(journal, 1, SIT_JOURNAL))
-			return update_sits_in_cursum(journal, 1);
-	}
-	return -1;
-}
-
-static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,
-					unsigned int segno)
-{
-	return get_meta_page(sbi, current_sit_addr(sbi, segno));
-}
-
-static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,
-					unsigned int start)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct page *src_page, *dst_page;
-	pgoff_t src_off, dst_off;
-	void *src_addr, *dst_addr;
-
-	src_off = current_sit_addr(sbi, start);
-	dst_off = next_sit_addr(sbi, src_off);
-
-	/* get current sit block page without lock */
-	src_page = get_meta_page(sbi, src_off);
-	dst_page = grab_meta_page(sbi, dst_off);
-	f2fs_bug_on(sbi, PageDirty(src_page));
-
-	src_addr = page_address(src_page);
-	dst_addr = page_address(dst_page);
-	memcpy(dst_addr, src_addr, PAGE_SIZE);
-
-	set_page_dirty(dst_page);
-	f2fs_put_page(src_page, 1);
-
-	set_to_next_sit(sit_i, start);
-
-	return dst_page;
-}
-
-static struct sit_entry_set *grab_sit_entry_set(void)
-{
-	struct sit_entry_set *ses =
-			f2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_NOFS);
-
-	ses->entry_cnt = 0;
-	INIT_LIST_HEAD(&ses->set_list);
-	return ses;
-}
-
-static void release_sit_entry_set(struct sit_entry_set *ses)
-{
-	list_del(&ses->set_list);
-	kmem_cache_free(sit_entry_set_slab, ses);
-}
-
-static void adjust_sit_entry_set(struct sit_entry_set *ses,
-						struct list_head *head)
-{
-	struct sit_entry_set *next = ses;
-
-	if (list_is_last(&ses->set_list, head))
-		return;
-
-	list_for_each_entry_continue(next, head, set_list)
-		if (ses->entry_cnt <= next->entry_cnt)
-			break;
-
-	list_move_tail(&ses->set_list, &next->set_list);
-}
-
-static void add_sit_entry(unsigned int segno, struct list_head *head)
-{
-	struct sit_entry_set *ses;
-	unsigned int start_segno = START_SEGNO(segno);
-
-	list_for_each_entry(ses, head, set_list) {
-		if (ses->start_segno == start_segno) {
-			ses->entry_cnt++;
-			adjust_sit_entry_set(ses, head);
-			return;
-		}
-	}
-
-	ses = grab_sit_entry_set();
-
-	ses->start_segno = start_segno;
-	ses->entry_cnt++;
-	list_add(&ses->set_list, head);
-}
-
-static void add_sits_in_set(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_sm_info *sm_info = SM_I(sbi);
-	struct list_head *set_list = &sm_info->sit_entry_set;
-	unsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;
-	unsigned int segno;
-
-	for_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))
-		add_sit_entry(segno, set_list);
-}
-
-static void remove_sits_in_journal(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	int i;
-
-	down_write(&curseg->journal_rwsem);
-	for (i = 0; i < sits_in_cursum(journal); i++) {
-		unsigned int segno;
-		bool dirtied;
-
-		segno = le32_to_cpu(segno_in_journal(journal, i));
-		dirtied = __mark_sit_entry_dirty(sbi, segno);
-
-		if (!dirtied)
-			add_sit_entry(segno, &SM_I(sbi)->sit_entry_set);
-	}
-	update_sits_in_cursum(journal, -i);
-	up_write(&curseg->journal_rwsem);
-}
-
-/*
- * CP calls this function, which flushes SIT entries including sit_journal,
- * and moves prefree segs to free segs.
- */
-void flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned long *bitmap = sit_i->dirty_sentries_bitmap;
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	struct sit_entry_set *ses, *tmp;
-	struct list_head *head = &SM_I(sbi)->sit_entry_set;
-	bool to_journal = true;
-	struct seg_entry *se;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	if (!sit_i->dirty_sentries)
-		goto out;
-
-	/*
-	 * add and account sit entries of dirty bitmap in sit entry
-	 * set temporarily
-	 */
-	add_sits_in_set(sbi);
-
-	/*
-	 * if there are no enough space in journal to store dirty sit
-	 * entries, remove all entries from journal and add and account
-	 * them in sit entry set.
-	 */
-	if (!__has_cursum_space(journal, sit_i->dirty_sentries, SIT_JOURNAL))
-		remove_sits_in_journal(sbi);
-
-	/*
-	 * there are two steps to flush sit entries:
-	 * #1, flush sit entries to journal in current cold data summary block.
-	 * #2, flush sit entries to sit page.
-	 */
-	list_for_each_entry_safe(ses, tmp, head, set_list) {
-		struct page *page = NULL;
-		struct f2fs_sit_block *raw_sit = NULL;
-		unsigned int start_segno = ses->start_segno;
-		unsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,
-						(unsigned long)MAIN_SEGS(sbi));
-		unsigned int segno = start_segno;
-
-		if (to_journal &&
-			!__has_cursum_space(journal, ses->entry_cnt, SIT_JOURNAL))
-			to_journal = false;
-
-		if (to_journal) {
-			down_write(&curseg->journal_rwsem);
-		} else {
-			page = get_next_sit_page(sbi, start_segno);
-			raw_sit = page_address(page);
-		}
-
-		/* flush dirty sit entries in region of current sit set */
-		for_each_set_bit_from(segno, bitmap, end) {
-			int offset, sit_offset;
-
-			se = get_seg_entry(sbi, segno);
-
-			/* add discard candidates */
-			if (!(cpc->reason & CP_DISCARD)) {
-				cpc->trim_start = segno;
-				add_discard_addrs(sbi, cpc, false);
-			}
-
-			if (to_journal) {
-				offset = lookup_journal_in_cursum(journal,
-							SIT_JOURNAL, segno, 1);
-				f2fs_bug_on(sbi, offset < 0);
-				segno_in_journal(journal, offset) =
-							cpu_to_le32(segno);
-				seg_info_to_raw_sit(se,
-					&sit_in_journal(journal, offset));
-			} else {
-				sit_offset = SIT_ENTRY_OFFSET(sit_i, segno);
-				seg_info_to_raw_sit(se,
-						&raw_sit->entries[sit_offset]);
-			}
-
-			__clear_bit(segno, bitmap);
-			sit_i->dirty_sentries--;
-			ses->entry_cnt--;
-		}
-
-		if (to_journal)
-			up_write(&curseg->journal_rwsem);
-		else
-			f2fs_put_page(page, 1);
-
-		f2fs_bug_on(sbi, ses->entry_cnt);
-		release_sit_entry_set(ses);
-	}
-
-	f2fs_bug_on(sbi, !list_empty(head));
-	f2fs_bug_on(sbi, sit_i->dirty_sentries);
-out:
-	if (cpc->reason & CP_DISCARD) {
-		__u64 trim_start = cpc->trim_start;
-
-		for (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)
-			add_discard_addrs(sbi, cpc, false);
-
-		cpc->trim_start = trim_start;
-	}
-	mutex_unlock(&sit_i->sentry_lock);
-
-	set_prefree_as_free_segments(sbi);
-}
-
-static int build_sit_info(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
-	struct sit_info *sit_i;
-	unsigned int sit_segs, start;
-	char *src_bitmap;
-	unsigned int bitmap_size;
-
-	/* allocate memory for SIT information */
-	sit_i = kzalloc(sizeof(struct sit_info), GFP_KERNEL);
-	if (!sit_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->sit_info = sit_i;
-
-	sit_i->sentries = f2fs_kvzalloc(MAIN_SEGS(sbi) *
-					sizeof(struct seg_entry), GFP_KERNEL);
-	if (!sit_i->sentries)
-		return -ENOMEM;
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-	sit_i->dirty_sentries_bitmap = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-	if (!sit_i->dirty_sentries_bitmap)
-		return -ENOMEM;
-
-	for (start = 0; start < MAIN_SEGS(sbi); start++) {
-		sit_i->sentries[start].cur_valid_map
-			= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-		sit_i->sentries[start].ckpt_valid_map
-			= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-		if (!sit_i->sentries[start].cur_valid_map ||
-				!sit_i->sentries[start].ckpt_valid_map)
-			return -ENOMEM;
-
-#ifdef CONFIG_F2FS_CHECK_FS
-		sit_i->sentries[start].cur_valid_map_mir
-			= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-		if (!sit_i->sentries[start].cur_valid_map_mir)
-			return -ENOMEM;
-#endif
-
-		if (f2fs_discard_en(sbi)) {
-			sit_i->sentries[start].discard_map
-				= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-			if (!sit_i->sentries[start].discard_map)
-				return -ENOMEM;
-		}
-	}
-
-	sit_i->tmp_map = kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-	if (!sit_i->tmp_map)
-		return -ENOMEM;
-
-	if (sbi->segs_per_sec > 1) {
-		sit_i->sec_entries = f2fs_kvzalloc(MAIN_SECS(sbi) *
-					sizeof(struct sec_entry), GFP_KERNEL);
-		if (!sit_i->sec_entries)
-			return -ENOMEM;
-	}
-
-	/* get information related with SIT */
-	sit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;
-
-	/* setup SIT bitmap from ckeckpoint pack */
-	bitmap_size = __bitmap_size(sbi, SIT_BITMAP);
-	src_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);
-
-	sit_i->sit_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);
-	if (!sit_i->sit_bitmap)
-		return -ENOMEM;
-
-#ifdef CONFIG_F2FS_CHECK_FS
-	sit_i->sit_bitmap_mir = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);
-	if (!sit_i->sit_bitmap_mir)
-		return -ENOMEM;
-#endif
-
-	/* init SIT information */
-	sit_i->s_ops = &default_salloc_ops;
-
-	sit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);
-	sit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;
-	sit_i->written_valid_blocks = 0;
-	sit_i->bitmap_size = bitmap_size;
-	sit_i->dirty_sentries = 0;
-	sit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;
-	sit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);
-	sit_i->mounted_time = CURRENT_TIME_SEC.tv_sec;
-	mutex_init(&sit_i->sentry_lock);
-	return 0;
-}
-
-static int build_free_segmap(struct f2fs_sb_info *sbi)
-{
-	struct free_segmap_info *free_i;
-	unsigned int bitmap_size, sec_bitmap_size;
-
-	/* allocate memory for free segmap information */
-	free_i = kzalloc(sizeof(struct free_segmap_info), GFP_KERNEL);
-	if (!free_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->free_info = free_i;
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-	free_i->free_segmap = f2fs_kvmalloc(bitmap_size, GFP_KERNEL);
-	if (!free_i->free_segmap)
-		return -ENOMEM;
-
-	sec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));
-	free_i->free_secmap = f2fs_kvmalloc(sec_bitmap_size, GFP_KERNEL);
-	if (!free_i->free_secmap)
-		return -ENOMEM;
-
-	/* set all segments as dirty temporarily */
-	memset(free_i->free_segmap, 0xff, bitmap_size);
-	memset(free_i->free_secmap, 0xff, sec_bitmap_size);
-
-	/* init free segmap information */
-	free_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));
-	free_i->free_segments = 0;
-	free_i->free_sections = 0;
-	spin_lock_init(&free_i->segmap_lock);
-	return 0;
-}
-
-static int build_curseg(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *array;
-	int i;
-
-	array = kcalloc(NR_CURSEG_TYPE, sizeof(*array), GFP_KERNEL);
-	if (!array)
-		return -ENOMEM;
-
-	SM_I(sbi)->curseg_array = array;
-
-	for (i = 0; i < NR_CURSEG_TYPE; i++) {
-		mutex_init(&array[i].curseg_mutex);
-		array[i].sum_blk = kzalloc(PAGE_SIZE, GFP_KERNEL);
-		if (!array[i].sum_blk)
-			return -ENOMEM;
-		init_rwsem(&array[i].journal_rwsem);
-		array[i].journal = kzalloc(sizeof(struct f2fs_journal),
-							GFP_KERNEL);
-		if (!array[i].journal)
-			return -ENOMEM;
-		array[i].segno = NULL_SEGNO;
-		array[i].next_blkoff = 0;
-	}
-	return restore_curseg_summaries(sbi);
-}
-
-static void build_sit_entries(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	struct seg_entry *se;
-	struct f2fs_sit_entry sit;
-	int sit_blk_cnt = SIT_BLK_CNT(sbi);
-	unsigned int i, start, end;
-	unsigned int readed, start_blk = 0;
-
-	do {
-		readed = ra_meta_pages(sbi, start_blk, BIO_MAX_PAGES,
-							META_SIT, true);
-
-		start = start_blk * sit_i->sents_per_block;
-		end = (start_blk + readed) * sit_i->sents_per_block;
-
-		for (; start < end && start < MAIN_SEGS(sbi); start++) {
-			struct f2fs_sit_block *sit_blk;
-			struct page *page;
-
-			se = &sit_i->sentries[start];
-			page = get_current_sit_page(sbi, start);
-			sit_blk = (struct f2fs_sit_block *)page_address(page);
-			sit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];
-			f2fs_put_page(page, 1);
-
-			check_block_count(sbi, start, &sit);
-			seg_info_from_raw_sit(se, &sit);
-
-			/* build discard map only one time */
-			if (f2fs_discard_en(sbi)) {
-				if (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {
-					memset(se->discard_map, 0xff,
-						SIT_VBLOCK_MAP_SIZE);
-				} else {
-					memcpy(se->discard_map,
-						se->cur_valid_map,
-						SIT_VBLOCK_MAP_SIZE);
-					sbi->discard_blks +=
-						sbi->blocks_per_seg -
-						se->valid_blocks;
-				}
-			}
-
-			if (sbi->segs_per_sec > 1)
-				get_sec_entry(sbi, start)->valid_blocks +=
-							se->valid_blocks;
-		}
-		start_blk += readed;
-	} while (start_blk < sit_blk_cnt);
-
-	down_read(&curseg->journal_rwsem);
-	for (i = 0; i < sits_in_cursum(journal); i++) {
-		unsigned int old_valid_blocks;
-
-		start = le32_to_cpu(segno_in_journal(journal, i));
-		se = &sit_i->sentries[start];
-		sit = sit_in_journal(journal, i);
-
-		old_valid_blocks = se->valid_blocks;
-
-		check_block_count(sbi, start, &sit);
-		seg_info_from_raw_sit(se, &sit);
-
-		if (f2fs_discard_en(sbi)) {
-			if (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {
-				memset(se->discard_map, 0xff,
-							SIT_VBLOCK_MAP_SIZE);
-			} else {
-				memcpy(se->discard_map, se->cur_valid_map,
-							SIT_VBLOCK_MAP_SIZE);
-				sbi->discard_blks += old_valid_blocks -
-							se->valid_blocks;
-			}
-		}
-
-		if (sbi->segs_per_sec > 1)
-			get_sec_entry(sbi, start)->valid_blocks +=
-				se->valid_blocks - old_valid_blocks;
-	}
-	up_read(&curseg->journal_rwsem);
-}
-
-static void init_free_segmap(struct f2fs_sb_info *sbi)
-{
-	unsigned int start;
-	int type;
-
-	for (start = 0; start < MAIN_SEGS(sbi); start++) {
-		struct seg_entry *sentry = get_seg_entry(sbi, start);
-		if (!sentry->valid_blocks)
-			__set_free(sbi, start);
-		else
-			SIT_I(sbi)->written_valid_blocks +=
-						sentry->valid_blocks;
-	}
-
-	/* set use the current segments */
-	for (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {
-		struct curseg_info *curseg_t = CURSEG_I(sbi, type);
-		__set_test_and_inuse(sbi, curseg_t->segno);
-	}
-}
-
-static void init_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	struct free_segmap_info *free_i = FREE_I(sbi);
-	unsigned int segno = 0, offset = 0;
-	unsigned short valid_blocks;
-
-	while (1) {
-		/* find dirty segment based on free segmap */
-		segno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);
-		if (segno >= MAIN_SEGS(sbi))
-			break;
-		offset = segno + 1;
-		valid_blocks = get_valid_blocks(sbi, segno, false);
-		if (valid_blocks == sbi->blocks_per_seg || !valid_blocks)
-			continue;
-		if (valid_blocks > sbi->blocks_per_seg) {
-			f2fs_bug_on(sbi, 1);
-			continue;
-		}
-		mutex_lock(&dirty_i->seglist_lock);
-		__locate_dirty_segment(sbi, segno, DIRTY);
-		mutex_unlock(&dirty_i->seglist_lock);
-	}
-}
-
-static int init_victim_secmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));
-
-	dirty_i->victim_secmap = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-	if (!dirty_i->victim_secmap)
-		return -ENOMEM;
-	return 0;
-}
-
-static int build_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i;
-	unsigned int bitmap_size, i;
-
-	/* allocate memory for dirty segments list information */
-	dirty_i = kzalloc(sizeof(struct dirty_seglist_info), GFP_KERNEL);
-	if (!dirty_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->dirty_info = dirty_i;
-	mutex_init(&dirty_i->seglist_lock);
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-
-	for (i = 0; i < NR_DIRTY_TYPE; i++) {
-		dirty_i->dirty_segmap[i] = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-		if (!dirty_i->dirty_segmap[i])
-			return -ENOMEM;
-	}
-
-	init_dirty_segmap(sbi);
-	return init_victim_secmap(sbi);
-}
-
-/*
- * Update min, max modified time for cost-benefit GC algorithm
- */
-static void init_min_max_mtime(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int segno;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	sit_i->min_mtime = LLONG_MAX;
-
-	for (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {
-		unsigned int i;
-		unsigned long long mtime = 0;
-
-		for (i = 0; i < sbi->segs_per_sec; i++)
-			mtime += get_seg_entry(sbi, segno + i)->mtime;
-
-		mtime = div_u64(mtime, sbi->segs_per_sec);
-
-		if (sit_i->min_mtime > mtime)
-			sit_i->min_mtime = mtime;
-	}
-	sit_i->max_mtime = get_mtime(sbi);
-	mutex_unlock(&sit_i->sentry_lock);
-}
-
-int build_segment_manager(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct f2fs_sm_info *sm_info;
-	int err;
-
-	sm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);
-	if (!sm_info)
-		return -ENOMEM;
-
-	/* init sm info */
-	sbi->sm_info = sm_info;
-	sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);
-	sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);
-	sm_info->segment_count = le32_to_cpu(raw_super->segment_count);
-	sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
-	sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
-	sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);
-	sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);
-	sm_info->rec_prefree_segments = sm_info->main_segments *
-					DEF_RECLAIM_PREFREE_SEGMENTS / 100;
-	if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)
-		sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;
-
-	if (!test_opt(sbi, LFS))
-		sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;
-	sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;
-	sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;
-	sm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;
-
-	sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;
-
-	INIT_LIST_HEAD(&sm_info->sit_entry_set);
-
-	if (!f2fs_readonly(sbi->sb)) {
-		err = create_flush_cmd_control(sbi);
-		if (err)
-			return err;
-	}
-
-	err = create_discard_cmd_control(sbi);
-	if (err)
-		return err;
-
-	err = build_sit_info(sbi);
-	if (err)
-		return err;
-	err = build_free_segmap(sbi);
-	if (err)
-		return err;
-	err = build_curseg(sbi);
-	if (err)
-		return err;
-
-	/* reinit free segmap based on SIT */
-	build_sit_entries(sbi);
-
-	init_free_segmap(sbi);
-	err = build_dirty_segmap(sbi);
-	if (err)
-		return err;
-
-	init_min_max_mtime(sbi);
-	return 0;
-}
-
-static void discard_dirty_segmap(struct f2fs_sb_info *sbi,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	mutex_lock(&dirty_i->seglist_lock);
-	f2fs_kvfree(dirty_i->dirty_segmap[dirty_type]);
-	dirty_i->nr_dirty[dirty_type] = 0;
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-static void destroy_victim_secmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	f2fs_kvfree(dirty_i->victim_secmap);
-}
-
-static void destroy_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	int i;
-
-	if (!dirty_i)
-		return;
-
-	/* discard pre-free/dirty segments list */
-	for (i = 0; i < NR_DIRTY_TYPE; i++)
-		discard_dirty_segmap(sbi, i);
-
-	destroy_victim_secmap(sbi);
-	SM_I(sbi)->dirty_info = NULL;
-	kfree(dirty_i);
-}
-
-static void destroy_curseg(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *array = SM_I(sbi)->curseg_array;
-	int i;
-
-	if (!array)
-		return;
-	SM_I(sbi)->curseg_array = NULL;
-	for (i = 0; i < NR_CURSEG_TYPE; i++) {
-		kfree(array[i].sum_blk);
-		kfree(array[i].journal);
-	}
-	kfree(array);
-}
-
-static void destroy_free_segmap(struct f2fs_sb_info *sbi)
-{
-	struct free_segmap_info *free_i = SM_I(sbi)->free_info;
-	if (!free_i)
-		return;
-	SM_I(sbi)->free_info = NULL;
-	f2fs_kvfree(free_i->free_segmap);
-	f2fs_kvfree(free_i->free_secmap);
-	kfree(free_i);
-}
-
-static void destroy_sit_info(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int start;
-
-	if (!sit_i)
-		return;
-
-	if (sit_i->sentries) {
-		for (start = 0; start < MAIN_SEGS(sbi); start++) {
-			kfree(sit_i->sentries[start].cur_valid_map);
-#ifdef CONFIG_F2FS_CHECK_FS
-			kfree(sit_i->sentries[start].cur_valid_map_mir);
-#endif
-			kfree(sit_i->sentries[start].ckpt_valid_map);
-			kfree(sit_i->sentries[start].discard_map);
-		}
-	}
-	kfree(sit_i->tmp_map);
-
-	f2fs_kvfree(sit_i->sentries);
-	f2fs_kvfree(sit_i->sec_entries);
-	f2fs_kvfree(sit_i->dirty_sentries_bitmap);
-
-	SM_I(sbi)->sit_info = NULL;
-	kfree(sit_i->sit_bitmap);
-#ifdef CONFIG_F2FS_CHECK_FS
-	kfree(sit_i->sit_bitmap_mir);
-#endif
-	kfree(sit_i);
-}
-
-void destroy_segment_manager(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_sm_info *sm_info = SM_I(sbi);
-
-	if (!sm_info)
-		return;
-	destroy_flush_cmd_control(sbi, true);
-	destroy_discard_cmd_control(sbi);
-	destroy_dirty_segmap(sbi);
-	destroy_curseg(sbi);
-	destroy_free_segmap(sbi);
-	destroy_sit_info(sbi);
-	sbi->sm_info = NULL;
-	kfree(sm_info);
-}
-
-int __init create_segment_manager_caches(void)
-{
-	discard_entry_slab = f2fs_kmem_cache_create("discard_entry",
-			sizeof(struct discard_entry));
-	if (!discard_entry_slab)
-		goto fail;
-
-	discard_cmd_slab = f2fs_kmem_cache_create("discard_cmd",
-			sizeof(struct discard_cmd));
-	if (!discard_cmd_slab)
-		goto destroy_discard_entry;
-
-	sit_entry_set_slab = f2fs_kmem_cache_create("sit_entry_set",
-			sizeof(struct sit_entry_set));
-	if (!sit_entry_set_slab)
-		goto destroy_discard_cmd;
-
-	inmem_entry_slab = f2fs_kmem_cache_create("inmem_page_entry",
-			sizeof(struct inmem_pages));
-	if (!inmem_entry_slab)
-		goto destroy_sit_entry_set;
-	return 0;
-
-destroy_sit_entry_set:
-	kmem_cache_destroy(sit_entry_set_slab);
-destroy_discard_cmd:
-	kmem_cache_destroy(discard_cmd_slab);
-destroy_discard_entry:
-	kmem_cache_destroy(discard_entry_slab);
-fail:
-	return -ENOMEM;
-}
-
-void destroy_segment_manager_caches(void)
-{
-	kmem_cache_destroy(sit_entry_set_slab);
-	kmem_cache_destroy(discard_cmd_slab);
-	kmem_cache_destroy(discard_entry_slab);
-	kmem_cache_destroy(inmem_entry_slab);
-}
diff --git a/fs/f2fs/segment.o_shipped b/fs/f2fs/segment.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..0b036bd0e31d8d2263c91757daa107e133d2a4f7
GIT binary patch
literal 44068
zcmb@v4`5YSmG8gLy*DI;v>uXRGnke`Nfj$?50JK4GwnstGK%%`rxvxE1PBF7;R-?9
zdA{*N!k;2^E`(5^)Lv~ngHC76v>AtSa3-aHtiE<cTOFo$p6A}%Gok3bL9N=EcI17&
z=T8!DasIsD?`pcv+Gqb=YwfkxUVHDu=ij&R{g!2!_-C2vW)w4K@JR5csx<)9&0EbR
zW4n9&rlHNHly`;S<n8gBojrb{Zb>=OR+!c^vrtSq_xQ%!;wQbFmvVbbHO?3Pq?_|<
zhVJp3+|A_Q?3<x2e(KEqFWc!WUNO$6OU-WHpW-A+Q_SX)8S3+=xK_!y%NHB7sBAff
zvat()UO&4~e7wF;Z1xWOmi5J9lkO=R)8HjcVWKtno?*v5T$ONpjN|UAvUA@&m8I@$
zGn7s5@$Fx_!~Lepv&_<By)lyq-3R=P&AX01f1D{4e{=TiPmIZw6TI7cNueC4SuS}@
z&Yx;>uhh9Y-?;nyl<D!COzxC1y?&N<jI+<LA-&2hDNdq%o!RFn%%Wn#rC%mjstfbg
zBuT60eTw%fv&A<~&QCdgek$EVA9_!j^p>E$I>ujTGDYL|ZT;EVvpbV^p$I&kNEeEK
z2NWyL+<3(+i5#?mZYED3Glim+Efnk0eZDoX*Q;V|jUD^^Hu~kdz5cOF^M1q6XAchn
z&tAB#G=Y8%_B~lt+8o{+*DJRHMTdmBrOddWc>RH=fAIPZPe0Y{_WQ;xE4%hS^7Z*`
z^tlPT^jS$SX}&*vk$Gx3X^sz{+5XL%DrkA;#&4e5K|jyTz2cSTp}b$`9`;?2ewj}e
z&uso?O?J%lz?kPVW1ijOnEW&Kyd)@FlY#fp!E`WQ+Db6y#OAGD%03YET|AuQ9;mY1
zp2Qq?N7XpSLYqy^?*4Q8o}%yW_lIwAlO^~Dzs;eq)SGgvc_66Awzrj#tMZw--#i6P
zPA3=92JNNn{xR+JN9}B_q7CH1m|wt`fET$!(WX3dTMlF^ohc>7dw99|!Z?jFKu4w3
z<$C>zwWiz{@xU-HwWqQ>><9c5bI#DuW@BnEa0|tbY5o4^KlDWThV+x=6g+0Ur4(iD
zjPl)Fo<Kh9zC<Z;d!l5ryZ!N$F@=8QuHPT$6pA&pdEMEoiZ$+E1oi&%?Agg-J@bNk
zB<Bg!fb5%E^`V-+)STE|g2%x)gL#`S6x&SRN6yRFxI?~!Of}iLfIjNGoepWId1z%q
zS<R&T{5g!J-E1ryw~(CUZmtrpu|c2O!_EW#Va98ySM6To{(yc2{FyxWcYEnuPw9cH
z`ihqG-qPMFn*TG)|3=?WPJOC4_u^i72`z1OldJjF<6AQd(o5ync(3}b%X>>UJZy9K
zLbG|AC&f1M&OjfeOkdEZ+Nt?1?P$KEKa4A8^V2*OuQU&>T%oA(S)b}HS%-Q{PRF*A
z^?}}!bV*(Q?vmQCgRUmS{7KI%HD%scYI1v#i;otica%?ahkVTOWzt2p*SIeP<CoqT
zoc#jhT~bc*?3mu5KFN-F^DuQcF;A<~g<?}?Ug?zP--po=dHUv{Bb1&)C!F|D$<FNc
ztK7MsWzVJUPgCFCev|cj2J83r8)vU?vibhD!e0OArThHZpS~@Bpt{DhGVd)VGgaQv
zfkVZbj-B4S9=qFn*PH?7pqV_uEG||VbNPGTYRc(EJb!wF`J*u(bq^KaHv7B7N8O#!
ziSZBg`3v0p{Dsba{%g*20berqef~+Fmk!+rUzT{r-HqNjj{Vr}pCFxnc|$imC|wWl
z3*{u^PC&Oa*3)5~=%q8`o+wtiUa^`vEnAUt_WK(LzV=TKPyGJy0{Us0FBFqzV)0??
z_%QUW{UH6#TgV!1sGqhy+Gpe5kNoWOPuP3?W%eHb)rouj8TEU7Yy8B3{;MzD>(@Z5
z-syYcPkmYS)!F;~ho^pTI1#i{PdkqfpSpBk6|$N*b!l%^jq~F04cNGpSzNB6KQ(dw
z0riXgfByLJqs|X4%ifZh=zP2SQRiu^hA~t#R?Vk}r+yzjTVH(C{h_tQd8Inx+->Sz
z^0`l2Gk$aSCjo68YzMME-tF<~kn3Z!&<)}IIn>N}F8al_!{Tw8zv`KLhsWo8yy`t$
zh8s1v|L~iqCJcB1jVv?4i|90Y74~p7dh!1cI(_Ht*-<(TOu&AG<AzR?EN4qSbei;d
zApguQ?8nI5%0&9U13i@M^AmG-p!4?yd<%6x<=uJp*s@9E%ts=ff3M%vQ7B6%?5`S!
zOkunD8<&25_=a?<l==_qXm;=Qk0tI!24s6O<w<8|Z%1eJL$|G8cl-7vXYSoTZFXUg
z=A-P(q%-dDGHg(6FD&NOC1<a)H21_0cS!ZzT2xwg%=5sQ=QCrT-N(n|kL+JiR{l~N
z8g!t)ph*ilCiYbV{%ed*WS^^&-ed0G;<VWVMaf$=^G5nkvUCyhf*lyaA4LAKfu}X+
z<2*^`wetM>?Ab#Tl%I0hNT&yW$IxEJMn4;RyusPuD>j-ve$UJmUeeBa$)Vivp!@ye
zp!;}nocn!$ocp*>|BHc7fUb=Flmz|J+><?T%<S`<a-m)m-(&k%L%YiJ`czY%4$m*F
z+aBn?IQ>F&y!tFX805P_cCJu-{f6!S*&BYq-?sueiRolQ`KU4Y1Qs@KJhXWZUEoHx
zKServ2K&_KH}ki;zR$O@DXKfJLonvGd}G--@x?H<6Lz2f#=oEaNo$MzrF;n+-(Z;Y
zKup|{GJH#BItoc_NmFa<K0j%0mLC0vp-tJBIh5NE?=*&_y?6K(>XM8rzm?fqk}oLT
zo-9OmX8?#^Pvp??&hAn=i|(Q?8Tx^ZEvMW|@lOlb$IT_#MvbFU`VHU6<e@YAPqLHg
z==0IzlmB{3q1=RCRKBq~F;RC*Sw3@hrZ6*cYhl{fMJl_slytXwHPmrRHWYd#>33bE
zQw@Gk9c{_?kzcKMs#pD!?UUbQa_}#+&3gpf--2B`g8jF%y?$e%7eBL?zV-SJ`P_kC
zf3WAt;x)M^{W;)q8#PY9Ut`}7em~>f>NnYxai|ylH}`k9jj`oh&hZ(n%eR&0Uc9X&
zUqG}LZK|_9*qr<Qw(J(a#_By)LpvsYcR&l}X^!+{VEp+H^UBQQFR-=QLh;D72mB;s
zYlR=C1DyqLQq(WLH(?{>yM6u>_-&b|;7fnxw{7+9oboJ_U8qfw$K((A)sE)C0e^yB
zD84)J)s6=B;H#Yu%gR^V$~gOx*HK@swH05N_U!ELD%B_ZA$b+u=d|qiGsr}r<9G{@
z)uel)X9xVJOr}tFGQ0g2{xW&iCGK{wk$2O<t?TYC%>d5*)4NL!zENFaC%%Jt7}`$x
zvB4aq&$XnBH#6Mb(4O)@$yf_eHpBr2GJs4wX7?lqdaJ+4K|@WtFtH}XAM#@7?)Q<k
zVoUTMT{8*VSk>-4JIOi@I!}$u-X{B-VV<J<5}B=DqeEHd73F7Ep~pUtf8Roy<{|!5
zZC!e=uRPe|VpV#+!~DBkcvbqno*m>{TCUE$&r9TXcnipXjr}}j7nK*$FIR1tj~6pM
z*O{<QW43rztl2(DTFTktS(EQBjfW04K4=^3<5YT!*OuPwC*j4FZ=C%}?HHbDZdXz6
zU5%!^c4Xd#>krXMW0cPmj4$2iH|F~M7F%OkRDQquX1>RBrhKLPh7LCL?Op2I&>rS<
zucx)-JHT!FVb$JUs>^Jq4%XrDLVdMakGEl`^xVdpRQ;}^kIfO?<%g=@lA#IcqRPIv
zHJaol<ca&_*t`8{;1>DS{}!{`-xt{QrDbHdHt9s`SY+mP(vh9wzXtCYmnl2x4F0_I
zRTcS6dUqiIYWs0)P-WXi^3I2DmFqUO`(jk*PiRwpYBKjn{z9SLdLs09;(4t3D_tr7
zI580Tm_@5V`#JtPSO*3^C^jJ*t=;m_!rkfBrg@)%H_%f0Cq<bQYgKH@&T4mm5uKjA
z0a_SjY8+!4Z)3X+wodJT_?xHB{O0Uw`L~K4AdA-cfr4cR`NMT#Y~u{RuAyJlTN~G-
zI`#g?&_(>e3?8em>f@R8bH!%q4*F?pp4%VrtilJFv%g<XIeGki{QX%6<nQ;-oVGlF
zbk+fM(L8Kb(ld4*S{2G|_`Ui1OOc<we$v6Owi6}EVg1xX@xh5Fh7&`Z@xdn+AAEdh
z_|z<|x#uNL&Dv3Ab?j%&`Nt(Iy{}|450{R@huFUqox7oN;6Fes7rq2*rt4TUeS<ZV
z*0BR$2y{y;G!-A0nNVM_zAY^zO?*P90Pn-Un}<%3zca6degP`Bv7|VMXW8|I@WdVn
z(|(Su#C5esvd|sL!8Ps=nK!I6EmON5dFn{T_HXCNI>wFW0|BzhasK;gquD)#PE{Y!
zd99%hR9%<DE9rYXyFXZ~H|F>ITCcmg{pi-wHT!F`v3KY$t=r#9nQF?Ip?-h7BUzGd
zV~u+5TK%+5durol+J9*(?L(t8mxXJoN2pJJ>kBgv`3csz#%wHp|LoZh`~&{of3(JL
z#P4zG<AYZgiao^fr2B2snw{MvY0}@z+=J+f-Ttdn)rZC9M5bU>rM)Ejr*_6-{L+t3
zDt!`M<3E1GmXd+i1Mc(1MmyB=tjCiE*-4S!OxlC3%s2S=L_7XYTDAijG@FZQ+Je`t
z>5|@jo=>EnBVS(gtzlByYfv1|Y{YId|K`)DKkn8Vf!I~HFk5Tth3>&gso8t0ny?#B
z&_=_rXAR#wYlYWFT?<qn^Dc>hEWK&c%p0?`JSV-)|1`Ml*){Id@brFsh&bkOuKy6f
z8;wbv`(FIS@vC)aJ>XZtL&byUV6WRcwgz&2a_ZB?IgCG!Rj5Aex}K73m~9hd1aEe>
z1!;B63uN0j_7>uKAsuh0?v?OV<4B+fw3a?P75{^_G)EL~Oqh&C`sNzS)Sxd;n&*nx
zWncbZGPl>OBTaff>3-S6E(bJGtPQ?eiiuUj59t`k4s~Z6dG&sVXvX-6M@_cuLRn+e
zTs4_6&ZV@GI9EopbiY4?It=4idv*D(jC-rUnSM3`XOPwdj~t#g9?Mzm8TX0O8J<<I
zY+z$fe(G*Nk3JDS(XCNz4H==2LHqC!y<aPt*h#)|<g4Y~Ctg4MlL7Dr)MFgcW*OtX
z-%r?2cq(^qVzYN|!&H1C(IrpYUqTl}baEGXqS<lE$F#T92J`*|^Kcn|ud+sKgm0P;
z7x8X7be&FJHG$vXQ=*aYNN35HY3aBh-uC(5L-)t_Cx&Owem+?DHpMy;`e(9ze&9FW
zf#2BiblLjY_EID3fN;E-^3~#j#stj`v1O%;{wc=&Wo$$IyaXDI&66OH711!R>lJjQ
zwR3xE0c%<L7e06+b*Ca7T!%iWVH|7m^=0$$9ZT{br7P5jl)bwY^CGTOdU%1W`ocJ#
z>d-ntdRyx+i}%X=f1vN!@=t?{$4%1FQGC_HUo)=ec|mLGsZ)lIm$mk)8=C7)!9IQY
zQsg4-l@n9(<B1W<_fBQDlq}+n7cyUx4*JNYPLHv7{M>)*^*zNJ@1|0X`GX*is4+Ws
zXMN+$o{3Y;t>xCXo;@mCMIRk-)?f#mp@k&_?W&wY@t^2pl9*H7P}-X|otPAVl7VS+
z3KQvj1M?zzwyvQ(tyMm4E^&tOPMcMjnBuuk&oc`X6Fkd*w}P~sr!}DLq}FuJ9=4eN
zS~>ZWyP3m#{G%Hb&-<d^mq>bTtcR1%X4d(8iqn#}pi`Nb<QGqD!`zPSn`}D1LGc9s
z;WCr=U$yf7j07>u@wWWo$*YNN)nM;?o7l@S6U+aM45w^jT-g4)p}l?+u_H5Zz^|hZ
z8TNB(fVT6tlI%b&<vXUqQ{rGhrrZtg6UgC`@=H8R??|V;FzpHAN{fqsfA;L<>R-xZ
zo=wdU8}rF>vUvESWN}aRh0d0V7dpqSI^HE5Z(?%lJ;N4y&!#TfZp~?v_gFWD`cFJj
zTwk_#Y#V>Wo{2@gb-cNy_}9cPq~pFat5BSh{&qQ)zR{bKA74rqw=n-#mXZZ*taDQ+
zCkEM|E%{#~a$-aKp`ZKBGm#VGr8UHL6mOn_o-wvpu5}7~W*$s>7rN<u&&)0PiGAbq
z_-c{7EG^$h`%Zd(iFI}vy;FP{dCAYjN1z``^E<_N9w<z-6&D~zaJKGu%J1BVoVY#6
z3D0|x6Q1kzyazeqIl(hDNw8-`eBhR15A|D4Z%J#sI{1AJ^C+NCUN)c)e@?Ln`WnO@
zZqeLH;^SdDm#B}mC#ODBlq{#1G_k$-qqAqPvm+YcA-bdIFNW4HG3PUOO}PeoCr#)d
z1almnAJ`M}WSVNwt&uLyuwJ$`*R>|;Bfk3#z9`Ryz20DAzdzaOA#NbMv^B6zs+ToL
ziTR3-4()@<^iZC$4Q(x1%vss>YJBT}@910W@-3xS&GGa+Z+yDfYh@4ZGlAY%Ql8@U
zl#)*2OUB+<I*wkLVq5GlCgE}C;>5(mfoxr3<HJteHLQ5KF=x+84+r}d=`glphFIg$
zuCe>DyX>bif4-QU<~0F3Okc2ONKV{8oGkVaUr1faiMbJ(eGS?jtv@V1|C7PwlSR#I
z=pWcE(O>aA`DupzMA0n4JIb6sGcTI^`0dDiabfyg{hu0%k!4B?p}F*KsMo{2sV4fV
z`r%n^`<c)GQgN0C-qKgR_bTm|%+i``veKJPxZfvOMf)GZJ|L&?i2T7G%enqcGq%Mx
zY4m*_9dBywY~F9ohx<Kt_QsOpZ^Q~uD_%3UKd~M79_==vucTwy$NX>Gm3S=_*C)FY
zj}>2K@_%Mm;__b$cwHz5y0ItR&(i*95O3~aU1xa5KDCt&<#;;tRdKJnY@Z*;7-K(2
zF|E<GLh)^Xu#Gj()*xRBSd$KYy<k6We1p~m?6XOiKjxp0#*fV0?|<s5ZKX#RZS&7K
zPvPtK;PdSFSI_G6AHNDebjseMMVxBSTeiSUH_%0K`@O`^;#d>*vgWtOnmQC~`bfDB
z9x4Wk9m8&Gt+C&q9jr6H9>~wHpp$%vnBM5_$=_945Vtxv_N4aWcxdd)1oVW4!QL2h
z{HZ_8l~ylTOqDo9Xj5x%m}ttko+sw<wm(3pMQtCM%l<m?p5KLb(q#$y9q+eG4sWE6
z(Rk%(+~kDwB)Woe5eFQ*7kGwrjp^|lww-q`@r2@-&_l5u<&&?;{0x0fH;i+IG7|9?
z{b<n-%^~IAcRoIxZ?Cq357qENZJmz~@p!fVH|c%;Hv&Fr4JkhK;!B15wde9-Y5AM*
z?CXKN$6PVS#$RH5_*EY&8Tb?P7rIW)1-2kev&K9tzM%Ktg4QE4QSrW!_j4{8^PWDP
z&p&<(V`#*mkblvH?#?)SeVrv(Nqr4Jn>{Q)0i$)f{61ScQ}PLI@mGVsN>|70-=8wR
zm!|IXFW`N=RyYIy!u2mSiPpcRvu8h6IUXFe$sM!F!@NX))T$2AVr;&#X|Zp;YuY})
zb*A=@drGY{xA-s6AL+Xhx<D)XSgV+N4f=fsc5NwR)VS!!&i`!e|A3Ela%MOtt+%lm
z_&i}Oq%j)X3EszJdycjJV<S9XRQ{P_S@2bJqY)djkUqRYIkk@z9MTvE*%veeh4Rtm
z``G8&=fA<ek2AEQwBL*)=DFWH{=lDjmc6VrvjKbMe7od$OG@?4n~RGt*}Ujg@=iQ6
zb9f}5v#d008u>i(WtNmKnX#q#$;-AZsy}o6a1FFdbWq>tsn7Wcy75~jr(;QJ7W=c4
z+IosNU(>V5&g}CW&deVE!6FZT@aD4C_1dev$KLEE-OXNVXs_P_{p#6ct8orPj~;xL
z#oE)_`44Z2_KVQpRSshg<_~j7elPJg#(Fw<W^eO>ZI<bn#(9Oe)t8pgMquYB)T8V1
zv6&09vx+-^;a}PJ_$@Y2GATQr%E<o-&rVFB%mX*{6PxHM^<A|!u(9$H@1mYCecn0g
z!{U{#wKjT&b=9+W7;8FT9jOj%g}s}#|JSwF@@2OlxGIP%;tS0x?s*G?Lf(j<1~#3u
z62bYVU@s6KAW7e1{~*QQN-)=vOZf-*?ISXOzJ501PioC8zXZSjbli5|lx>W0=7=Am
zGb_K)n9z~h<Aa7~9)G{qo*4ZP_QaS2I`<%2i_X&HiXA+OTs9funP3h&%=Huam_a|;
zJCe?sknyy3J8h@&!?J~PpkEnF9=ZklMA^`fX#&btF62B_$87fYCNu=&*SbNvxlS?x
z?{0Q~F?`v_3dN;HdcrF!Mqo0;!lCbc`lGh3+H6_A7sJ>Y;+w#GePYRn;(4yNq?;BJ
z<JUTnyoR-d*{TPAhxwC?sh+?FLW_9pRnT7gB+{$cVa5g>gK=Y<k+GW5b~t|(wIkUJ
zV%5~8Iu)<Bvcw3WskO7W<m7g+MhW%U+zYUw4r8$KT{xQ))09|!u$GGRY0hn?Kk=E8
zI6XdlqP{*vO!U-w?6l6L$Odh6&;FBSYH;?G#GJx&PUGmu*<YRgiRz2v-Spw~HJKL}
z_s!*Y^4SAApYZX3PqMix^K;7JYv4!j_oXW{1)XV-E+xirXlJR-K8P;6r8vQ!%lh|j
z|98-7b@sj>9%0!xdhA)^ryuk!_MsK~Q6ANO;+JQCGWX)0CAAUngNpu&+grpGSyxPc
zvB8uL;{*?6Fg^z++9}@z)8koA8o9is_@`RSGLE_5+*zt4X3g2ZTJ1wx&UW?@y`sr(
z_tcioUnK%vHrLY`x<7pF>`%0(r*{EQSU>p<CV7xK+>1;qZEU;RJJI+x28~BFk*?vq
z1beH!=!JdIsW<Qi&|B=~Kp&UA9QSU&k1?Oq7UTUq?ff(2EK_g5KgO#1#Jjsli(~bY
zVfhM@AK8<){2OaajR#z3yZ-i9tW`LpVXc+Fj9&d5@y#5*GIKp;^OxztztA4kqTuY_
z3FmQi!vW@5=#QQ0csv-t#wDNTRoYgYBe4(aRJ&FO?{i+cCfny{2GAAwk52wxKjnOZ
zwMY{GM{%|7!JdKarQ#%_p>&|-><ISZ9QqTaK|52RzD%L$;D4|dDXu|&EGHM_3;2-}
zotG6aW9~2I97xjL$~twPx76M4cRZo9o6Ti(cx@bqU?SI^G*4@7jUTAk>CIM^G1r|S
zzAIW;W&wQ*W3kxwLsoTj;KRmebI=)+wYI8q7I?DDDLe1i%bwc!$?Rp?;G+AahRxnm
zY|1mxNphgQB=y%~FP8ZJ>E<D9IkvgZ9QG&ueCDuA?C6r8Uq8HuIFZg?zLS1tqcq`+
zuXbPzJ{A1T7+mW|w;0x;{LHi3EO8_I=kBn@o}%O(Eyw&_%wAExpFN|#w8?MHS5@Wz
z!rrsTnwZ}{wV|*_>pe1Z_VI8KI~*)Y?{Ov<yq>)V*1w*833i?_H8VcN1dc6+9+@7m
z3O+F2omTFBCB<{Km!L7HGWQ_|=tc3H{5nIS^<c>Ja6O!nT@g=ebEQV~U$EYbe1fV1
z?dH*oxo`O6v&dMkrlkG%YNt><TECB&R-s5-H8}eyK35ap!(R&cS;xEAh@(s25j(3r
zX@$HOkJ)Rr@Nak4*!{%H<jXT(htOO0cF$+tJDlgz_*!gq+YtSBh{1z%KG1WB^(XBw
zc`f!f|0r@`<))V=&^PU8p$~VSU_EF(!g<DH(K;cXM}?=b1?WjPjDxj0eg63Td%f1Y
z){YP0(}c2bGK#<V`+p7{1370ribrYA$xbCYphJc~Y)xPj(}m(cqdzS7eaJ88HEpj4
zzkFx2z0V&^5DQ=)CY|?jUV@koZO?L7AZHt;%h~V5AG5>pzeFAC-ypJSGY=K}wKDJX
z6jQmnzBAzaqv(9geSb;xQd{KjS9_G{r%XR(`mK)l=PA>FO?_ux=a3$b^^Y?**iTHF
z4S}B07=p8moN2VPlr??*I_F*Oyf3e_jk7q@D7`H|a|`Ew7LMrL(er=P$DFH*$DuKO
zg|VoQ)r@T`eU=W7*S(h6q_bc({}R#Ea_5#rSB=L?7kZda#I3@Z4tP<08rx1Y=U4`h
z_rv>s=)@UKv-gy2t7XskbY@R`voo8QvqvB9&*rC24eX0z!WMewL7fjI7OnG-6KB_Z
zv@sF=nGEI&{gm$z=yUj+WnL%TLUAB{Pstj3;bqRIm5(0JS78I0s*B2;+pd~3w55L6
z&^`9x&`T5RhB#aQ#4a=V#7kCacLE>0%vdL{d&`nCGV>UG|Hd6R%qu17^Ip;tPT~0k
z?b@`facj>bi5;Xrr$ra>DFGb=S%e+|gfBWLV_hD~c-;5!-O|7>(pq=yxvjQ{f7;um
zJ^ZLQpW718;=1B9Y}Vw^#>;nWjqHx~VCYvRvhaugDF$y1;4kF0zuV{6GEW=vKU~>Z
zXG^em)G?bqTEqDpVy)1Cy~7W(-@thmx6o&~g`Q)}Igf^((m8qy-;O+-fut^I;pX<>
zQ<&47Ct-dSo`;W5aDJl<B-^60;Y^I`)Ot3Xlf7Cdn%6e{>YCwHq0b*eR-U}H->?70
ztl_u*V)n510PEcFY>w6oA>D2%PovFoE@R4~4|9d`ll9>_aP8YPnnOW8r6DiDUY+zi
z>*MQEj$-XPyY~Ki^xEW+ytEnTO^}!M^K~;XGUa6>=YO~2BZc&h&zdcw4@uQed-E9c
zG1`-Tu4m1^XW9x+`t%2k%}Q@0=6}fFXITM#k1<B$6pDSR6uKf)d^YgA7ME@N5cfp3
zl#t^uJwbdwIdjjj_JC%ycP;slEU%_dPvXyMpF*^-?a_W|Y~l(1Eb4v0r*xlR4{dF9
zTp%yVR3p!thnnk(wS+XylvSR%OqKRoRGvJE8n?G9D91bbT~(B6bM9uGh4P+X5MOl*
z<r(g`NB3n|2VF%!E$tETJcV^<Djv_L^TSizRO#A{j3;|hi8WRbJG9{8G3YP*FobN?
z+4uW<Qwgu}SFOX6FDthrnZgzcN?wQ!V0*Q18`@!=`;$!7&~MA;+yylKDt?LDN3U7P
zA!>e6nKR{+n`OuFL&jaOxin{J557fkf2KA~3{vH^?qrYSbPE1Rel+$c#jmvVc!u$t
z>*m6P^oWifLx1EEUSfZ4DeoIM&PKo2YcERs)K(fgu*N4nSKWaRfy^!n@){GwH!|To
zwesvw=U5-Ww<ZU>GOw5UsXH&k>a*G#3+Jf#eC$!?VF!5&+e)(U>Z{^|HnuqCseA~X
z|GemRces&s@jb=9d;Gq}-Cq^*d0Un0Xkopjck!A@{Kkh69gBbWD)u3IR{D3q$L5nv
z$cLMNT%aekKU7ve`NK2ZC;gZ3g;bByg7z~JBu!^t8}S*#eg(FSHKg>*=y}#ry%@;&
zdG%skchK&6VkWU(G=;^1jctiyhV;Eb_mr&1c6kBKhUS)}&$AQre)D(N7auuZDE1;Z
zX?tpEYD2R}Oo08wLiu6#LT0!>@{@CWy*#lutvm9wd;J!*O^jxS^CSP*acm?y=OTFF
zaxcI!wBv9u40*t2Uta%)JABybKwo5nJzd?~P=3eW{3!P1OS(s<dt$a>e{*7fc;=-Z
z`k+40y8(@%UkaN32zgT6>(wo+Ez9^O%;65=RaSL<nYGAd=}P%5M-#-x^2<y4I^&rR
ze7}z8ijpIprLeQw<Ij7~O!<;$<uau?ThOug<0Z!|E=|09M{!YZ$0FrxdSecE4)Wf&
z$me92m(Ey}WlrwMNmnf@>1>Rfh|1<ETb(N|8lPKaGgiYHMAdO2<^PWI@;!rfCgn8u
zgZ8||CHK-oapF6+6c=5&Ws&X{)W0!nIN|K@T5`;dH`<1GF&A_%jhOIG?X@}C-6hdO
zv@m)3${umXcfgZSe&t(NxxDK*$iCuLz)XqxOk9(5k`WEt+%Nc(k^j4)WdhsH`xo)W
z%T*oNEzUSwg+fCr$C)woy?ie4ClVcnC(s+G$Avz7Z7lne^`I}bJ5KEm9rShXNqp8h
zKVv>tmX5GGwk53GvJ&S7CTmR~UqZGTol}+%rTHUy*17xCY}V`O5*L0MaO5_a2l5fL
z*C9VwdFz>*oGC4<&LGAz_U=JPp?EU=IQ_t1i{dC+?`eG(uj{ZihYaJ?y@9d$G~ZuK
zKdtreDYdQkq;tlx7SOn~Z-q`_tsq^~2S2`CszKk>u@>O$#c7K=Ig=5b_tu$Wt)Wf6
zP(E3Bym;xVLUGz>(6gV~R=oTg^vHER#dp1(y4^mn+WE4_JsQqB>}K4@OS*?p&EBc}
zkil83;qWDzhxqH+fe*RNx{Lllw1s&`-QzhwT4O$Db)&m!U+oo7q_y6Gb~bmZ63=17
z@kMyn+8&#1F~6^4Zj?`6%9$$qaw&aD(3jWP^OfCfjpn!Q9rQn0RGjyd$epR}p89~_
zJ&`z^IT+|N&K;btrcRr_jiX-ns4lOziFbNl5<SDY-H&*VSy56PxwTwi4L`3m$-Ad`
zb@3kbruu|0?A_!wNBvX3?c^>m?x({Y4l6xxFHY{E6CKYLRhQ~WIh=Fo_=sn+-zr^0
zY}%yv`WLx9#cSF3*WR+tc^LNTgZN`3F^qp`zZ*X7_NTs;J}_Q$IeWi0dvgwc8++_$
zphJo^^ItL7PF;G?w>|u<EWAKZ4F-Dy2U$ZM^pDl!OCpQf|7bwJHKli7jVxVvp@-bM
zH<d2=*{tC`rFGtg-aLGtPqG)iyPrH;tDtE!^#!)a-aQ(-=on)!@C6Pb&&t!}VN<<(
zO2i*dPwMc>2Z4WTjCr2FU$bA3gwMg+B#l0zj@Ar%1%2pZi=`WM&!Y<8Sbom*?A@i>
zfgX=Nun`-oHkv)wc*hmL_#)%|B4gd-OMhDgZw4EFRAhhLvzx<pzOi=%eU}dv>ykCt
zLFs?R69%XK2wH9_4Nm)CoR1*}%)F6qxQKb9Jc+5j-hl?@Gk(Z{hAo_vBklnYYYSUE
z-C-GQc(Ev5S0%Z04vw^8^2iADQ0M6bUE^>r2_35bYhDU!ZxmhDfWmoEYhBme=cia>
z*~pgGVaD0Q`32gTM;|$JP|u(4nn}*}zL`JW56dpv8`Rs&S<V!C$>2++i5)#O)IX_i
zsQ;o@r{w%MKAiIt&aR2CU6o@UfX>o9iDDFS{9JZ5mFCWMmUHCNFOJqXw85V6N&a*{
zQujhRcU)G?VjNI&<*6o9b|QaV<r12|@Uikvi~PRD(Abd2;;a(#hYv(M<Xt-Td0)13
z<=noimW7^WrBeyb+eDf;M4;0-TLPX0*I8A3LfL?wjm(ukV>n00ox}@r*zTUdm$$Q9
zdG7bCUBxl`xvK$PI*7feLs^zwiw6@-mUTJtVan@#pzge=pVF5D+$(y^b;*)7eu?Y?
z<7OR6`#hsN!t!Ts$omhn4!9(-QMRY{H`7e{U-3h=Kaw;{8iIL>52JV;a)vv+xUBV!
zaN0QZ`RnJEUMEIci~rZ4Imo$DtxtGYJGPDJ{90{__Wy?VtANM;KlTG1_@DNJxXqjT
z@sE@{OxrOZ;A6yxBz=buoMTNg7Xuk1egd6O$9p31(C9vYus*@gyyNd=OXY_VyEg0<
z+u_+u2c6f#pKSJcd-p3A^saH48>9tmNn~F%zU=zKG|mTJCSJySs56jl-T7A=)mr~k
zH-Dun_c`qSbI8PV{#^2_Ps$hA^|bDog!^-v2c|=3iIzylCSU$LrmQ_2wJ|nc&OSjD
z;}88~?G31%M)x1_@pxt|(m87P>&|n<mY_UyG?JZok54qw-c=)Xu(=m;-IZg`Uwn5<
z(U`X2{DtVKn6>s|l6l=H{zpHNrLXjN&cHtsOWgfRvyCt6{$3DAvxeRk*yX_l=kQ&x
z#|$Zkxu@UcSYI*Elg{tuiK+3fub-G&z72cR<S=)M3+zoMyhO)|;Tt-}l|BOv9(D4?
z8=T|3Tg-YucT;qqY_Znvwb|%d=N<>5XJQStXQF5M<Su*X$`3tjv(Yp28uNHdIU)ZI
zKW^N-UT-?<9G&-!X%w$xw140hi0AT7am?CaexZXzU+AfC3hWK;k`Ql*(vGrr)&9Ni
za3|g0^Ag0hWCyhWaO!8Qk$AS;cd@STW3I9`X6#xgslIQY(OT)ofR3Z_NaAJ*)hXKD
z_*>(V@mlIAb!a^}sD9W{JTiM@5Rbf;c%<67hkl4(dJf}}{ZTx!e>5JM|Ggj{`EKHo
zTgb1wDa!wOp2e$xzN|yvM3X|V{~>5%pqIuR(^9k@yH6JL@{7#%n3t@zM|gRF=a`rM
zJjcA;tNal!??E<Q&9yYPWoS>ZUzp5j&AZ1RkKFx@{Tx2jKl&Hg&-v4VoWCVD{g2ox
z?oZ%XXl}*!S<mX9OFU2Vo*W2$hNW5)=EJ#}D3C^3*(Q_QALs<lcioK`dmbq`b8bF@
zjphuOx!+$(y;}dt$FE86XHVGF<}V#R&xCB(o^xL=iycNr(Q&MM@AbzaBPr;gGWSMj
znEsOYOUl6+CU_mL<F_KG=iZf58H0Y)*yN8}Y6m`q_{YnNS=IbE`cd=$*pFtLJ4xuM
zpk3%CnQzVS_LZi)EV{Fh=C1}_7WcK*^%|h-r0LMG1)Zn;`gG*WNI$p2Kcy{XKFRNw
zzv{a17O1mws;4cBe+M1eg9_+4Hh$0;?f3pizC&yaV>pNQL`ThA-4##_2rU}yqfFpC
z0Mad@c`~Ls{S+Rar;1~1OQZfsZ;!?^;=R%TYMfW&JK;PXtnuPK$M|~?XGovJ-bj4L
ztC{;F=bo{fd(IiVnhxY7cfijupJWyk7tv2P>TRFIzhQo9?vLf)r=}=|RVdD;AMv}D
zI=91lBhlfbynjnX2knoj{a=op@jJJDtx08z615G%xzTGir(OBu*l5}|tbHUi%|?4M
zy4S~A16=3ER&&lf>=$iQUjEw!$ea2mTkDST1>(7_Ij!}8lP5+%{TBIo_FMQ{y_mHC
zWmRX_4cz}#J+vwOqc`+YZnv*-S~bBqCu^K`G|snO-&-;T5BV6qJF2l8>TjXHGmv-D
zA&y;ZZ_lEv&R-r`v`=?Q13hvk$$E5vZ=n27?nGq2RsIz15_3SVZYF-c+t(Qfi@R>}
zgH4Y4<YGUmKZw;LZ#pYh3;hDR5F=efe(5RMnWPi0HB|0N;#Kjz!7*d1)p&GwN#%9!
zT2OjC)?+mt__gGb%?sNIb&J*r!X3t}HG^#L$7uTi>)`n8W~l4%#fgn^2Y2LdaH#7J
z_*INU_3CbLcwX};ZN<7y<rK5rjvUD6XI}yusLi--$%*J4<1y5{mEIk2UnpL1d9oxQ
zJ29Tv|M(@`V=$9Hc@^h^gY&27%BI#x^2Pt=szSpzuPP*0&*Bb&+vA<@J1vsAfF96#
zI=l|_T8GZvgg)g$VDO$;ntYhJZ{lTR$Nl~;d|dG;=BMiWI6P9{#Xop9QR55g13!2t
z8z@~=$2y{>5U$hIhW1lqz0ksY-Fr6q(R1e$GR&)i`~2IYIj{XZ`2w7A+H5obJ~xy3
zK};y<FK3l(&g{gr4aaz{{u=$h0P_&pINw?<rjMY`SWr)}H>EYY{K+hBS{=kz)A%jv
z#?pFdWOZyVz5Zzv+OTv;U->uH4*kz-ZW6b`&rzS^^lEcAu@3gXd3Pjw_p8|^h@U~j
za@_#y*QwO;*cXT;ZSe-2?=ue<m+{@I1|R&<#0`bB<8(%XGXdYQvO0TlORyKHHJWT@
zJdVn}I(NjT{MTp@tWTo#u<FJ!Wq*xtULXU~L9%Nh{ljs`cOR0_Nb=CgH)eKBT<x*O
z^O81WHadrS_wb<kesR$7Z3@OU&UqYK^^`8ud_!-(epR?m<b1=(SueFMd8`~y$A5G0
z(WFCPgS{E%=>0xth)$1lh#y4bQLOUne+gre+y$5%j32*9_C~e_`3lw*^5>Fvp?o=c
zb^jxv1^C;+6A_Nz#@(oIo|^hEvRRADlGzKqLULf}grzls_Jhzhlfkhch4M|F&WSBj
zjQtzq*bhdhG~mOY{-V|5CDP*8(%}BFVlMiY3H|$y^v>JOtqqpDtG>=IOdN2BAQQUO
z_VA^UVeD31Ui&%3eQQ--=MLmU&WP-cfnQcOv?H1qvSEr-NS6oaBY1XrJ^~ca<vUM@
zU$P@D;Ng6`pFEVMPn;DePObBKeST}EhZrAmk97E*hhQF{dy(@Z@xZ`G`7m*!T66y?
z-BWe&jmNnwsC!ZI0%Snn3Sb_UZ(?2?$?WqFz@u2c2izZEb3R&J0L{kd6{BNMJs*B+
zO8sulXe`7z=%aL&e6S!r==;sZ8=+N*>rTzh$h4{5^)^#JG49RlT8%j#pYrV{-;wj?
zyO(<!;hE->>2DQJnr{)S{uccV&mi4ynM1FU-V)g@(Mfw~E&1@QRH!HRquUPnqFaok
zFNzNI)P8T5Wv<hA0%pi>kLIV=39^CCPo-ywXS25}dc<{n37#ML=rrQZ#A^!L|7Onq
zB-Gvbi|jS-XRSo+5&3uvb?6Qkcaef~fHj4FUu|D&>pnJnn@(Y-?j>ujsI~7b=%F=a
zo!#%FtC-izgM2fHf#{y+0n-!s)-eyH8?;uJpHb^*Pnx}8JGA3kn=ntISEhI;a-s7&
zlBx0B4If)q9eh=K6>aZ;7tK{~=2>uNXBV-u!{K>`*xtO#J@GTSr|^wK`Zi@~Ba#!{
zU%D1OVFtoj-Q-tWhf_Iy7i%6e`LQD3B=KnT(5Lxc-N48__0f9|Db9dEpR&$@h}QZR
zmgLTM?+fVl(9GwD@e4@1Z&EV1!;a_4II|a@ashipON!WUm-FRLGQZi={qtac<-#*(
zu}wC*(<vGvYofuoCvy+uJpGB+x9Ax32l?%AzUqvJ_P|uP(t|ee#lp1+-y@)2{I}rS
zJkKUW+NNkTVa{(m<91?bqx)5__R1cb`Tb$bo#s6>^Z0PkPBa&7v)liJNXD89)a%^q
zA4=5{x5Ni^>Pv0#pf>jf<~83>qW>CuO?o@A=IwsJVil2Wd{pws^MLbwV0T2r8v{MM
zxcni?ZbUxb7&#j;$}8=;-2|_+KOe+)4D=@Mok-`HA3qwtVaO_d!@jS$sNt32x=EXh
zU$=+Y=g|E~;^^#2K#O8}NZ;bz^Rjez%FDg1`&~7>OB?Re4efoI`B6*_Z4T1E;oMie
z3Hm*1pCs*m|5DBw*4y76ZgdX#`6s4%kJ{YPqwE5^hjn8Q@;!Pc!8qNe;2WKGiu<q2
z7wdZ|I(LDdFDIw&9k!<)5AOIUr*0mWuG04@q^~5m4rkSZ`GTzzE?;aabk{ckZn8NW
zk(}x!(7XCRCwE)e6YMF;HU{SwIO8$Eccc<-p~zW=)2dsvX`${LOh}(b&cBF81{%r7
z?|biZ?*s5ycVr*4bI=T0N$2t%QrV2(PBVOfp+0EF_c&sjx%U-65YfyYy5Hx!U&RK|
z%!OvhFCC%Td+ja$`x&Rs*Xa)EuYRLD;+#VsBgd%`|L5RumE(9W#PDU^6Guj3`TI5T
zs~UX!I%L%v*)t4fvWL8>bRXv@*;6d^R-AJfjU8x>anUc|Gpx0=ZSYf}jn1|ltKaY6
zS5@UzIq=oq8lAskox(ZPD)b@o@9S8r!{^buSYz_-wVry;zD$z-*8B?f|Mt>Y8*;~(
z`|f{_lOUf)K7e${(RJ(t;tLF3&w0gkp1l*!5g2SVJeF_2R(6v<FNF>x_X9}BKMC#!
ze2#MRfz~2(Dx-DPtg3L`6Rg$D-F)*wXBKn*t-wa0&WJPv_1(l4pnT(+jJ_?BV?Dy2
zKX931r89fH_os<r5d&UH`}$_8Rm+*T>k2(H$kQ?VpnqomP|>Px;NEp1+2-b|v{$%*
zcZv5D$}X_g&2djP$G0zY^zR@z^8&d*M+7o*LgUOz-yaOVhoX6RIb&-T4H)Np$(M1g
z(Xq4M7-F92n<)CGWgR+0{DTL~GuGIy?#=dq%ST#V)O{4|W4)zi7e9bq-%9?i=(nx@
z!Ye|(8u-ejw=yr&{LSZY0e{Wxoei=_=@8dn2wu;(Uz(}owP{Zk?Wk<n=N|tS?o}Ah
zNSX^CAa)q~=I^*pe)w+xOk3EF^;_;$z}ubTcTM(SFkY=UZD`(r{~6B%-MM7`*K+4M
zxC`>P(hno@Mmc!HzFjec-uivUdz$xmk~ShQ&}<{+)!!!ge4@Ul%r}GsnoCdhCz1Q8
zKGD32KHN&bRbJ`xB@;8YjKm7txHsD#)u+0g4Bsv0y9^I6W^J-)Ogt#6%l;4Q(j8pZ
zcMVMgg@zBreS{wBm;Az2_*?3e<cs^fRrIYkJ$7uoYod<#Q1;j?>6|5HK3u>#kAr^J
zI_S^I-0SDA>GKcg^8Uja#=?8fMb{7U&4CltGh*Y_2KBs?deZM<UmkhNplc*sgVfuY
z>-8rs5l<<T31p2v_WIX?w*a#<5Bf)-(<AizwU+Rn<<Jz)8DEaSQ}twVy6G+bbaE&Q
zO_6NhiC?Atjj?<hAJO27OR$YGkEnMFa{gt`xg<Uvo}&nThLBeS*NIo?$@B0^V|o>R
z{N&<;zUuss__R8z=X^YGq#hi}TE$H9S!=5u?zqsVbZFR@n}c-ePo>9av^0-2zHt{Y
zPVA)a?hSG-U^ezsG!{L_%-^ss<n>#$C3zk9KYL4sk3QfJ-p$`vh+9Gv$-df&dFMv-
zl#FmEE07WSSR-_Wx9b0+)QPN=R5tLz(bp|w%1)2UzRvd+$Cib6{(~AjK1-T4knN^|
zejjt^6N|c~_#$&IyXc_bn`SSK*u)CxV?l#>{%UWSIa*|{zbLuf#h&CsyU*`NX7HEF
zM`s<Z;(V}?k8W{yN9CkDL>tjoWt8^%TvP6zdeHyXMpMpiK8Rk@nnbaQgH^jiJ8yK(
z*m5@qXEXx7AoGHvWr{w?7d3?_He%v6PWUcm@AUBh!`R5!ca%~4bsbul^4;E<e1jC3
zoWpaE%kzqD-r&IVocG)o=%W9@ohZdc8(z^j8FqNAErWSEgYOCrKK67`<23_?GIyuO
zk*`YYz$9mHzOI-G^woJJ51Q)SROl0*d%o{zb?g)W*UtB8{F<M=^m!_K`s{bt)*zQV
z;DKnqkl2XmTFrMZQqV7^Y0QI!$(eD^N_@Y~0dG`a3SUTL(E1|#Y4LGsxfgvgm9@uT
z8uK0QC6%OW5>vN(slr}=4)_*lyEn)hP2Um;+9&@);@4{XVfv(Y`Nm&K{7fJZ*fGzt
zdq&zc9U(8(mdO>0$B?IBT*$#xY%20H5jksk4E+rZWIUEZ*^mL+&>4@P{kvqDbt+}z
zb;inQJ^f$(2B>K8<9|PUx~;Gezp2IxbhIfXYYID|-?=(EWp=W!wcl4><x?JflVoMS
z8uBTR-lzD+km&ameXWU}j|crmpTNgu*yUHJ?)7JI-ozSTU)K2u#m{xVuXm2-MFVjd
zVrJN-HTYk#&OKkdb!r#CrzWRw2eY=LU44u1j~Jiyrfl5#?An~Gf4hxLqccA7o3oSq
zsYCYsZu(Hock>#d!xtvr?&(|qmXq@=eJ|F2zBp(f=lt69#9xm47jma7j>T1Hx9{bQ
z%c0*k7aob$o!TS(ZR^7-=C1e^L#^E;7sSzsJ%#ZB#aNX`x}heE?#ZHyxZ8ITzJ%m5
zHAXI%kybTEzR@jJNi)ABIlnlP^Cr8mO0sU*JB{T1L)bOxG0FN48@V5&yHd<M%`Mg`
z=DqT52A+U6TT0dVaEXC=zQy0sdd;y#`p(AAK$m5=d-^V<#uEDIVgH-la9<|gN0BbS
zuz5#mIyzV53-3&Yd3BapHl#6n_xe@b(Tj9lBlLXzsviIBRVVp-BG7AXg{}Vo9_D*m
z?%(^O<qY?!Af`1qJB)j2ZiV{l+__aVvWEY!eP37o)VQPz$1&H_&_Q~J^$_>G@b@xW
zuQPV&S_hP`q%*unm=o8KSM<IXze4`H;)v35icwjNSA3UVV@+Ac=ZfqLdjQnYSC#Vk
zhKJXmOnUdFCU}b7>0502t|K=8klGI8U`va6)<e4Apzk+wk7Q@?-JEQpe1P_ov=P(4
zE~otm;seANb$9h`_;XsPqRYxn<kwh7>-|WvSN>jxJtp+?u`Sr8w7#{hGm6-4^r7Mq
zZZ@=Ax~mZHze=x2muX#h(Q7)xuC<-^gW|na^p3l)inN68DyW_`x<T!ayWr+B-zS(n
zgYTU*n{eH=3*YQkXgJ~r;FEm$jnF4)p)YmpTd9r~&TzV)*4hof1b&T-Cv&b(9Ow}8
z>%ID#3Uu_nBR=+6|C;;iFK?%<6z2q_hXS69Ub#X!&$oB#GTLk8Y#;SGg^(8G9B7U&
z7W*}(FzSbo()VM<<(9cz>qM)A`^3o3f!gp}+1Q+5eIM8?vt%MX#U3pwE+l69zwjGJ
z?=jp>d@<x3=dM`qhrd?<$i8_k!Y879^=kpn;qSxz-4>;3{i}7benA{F7smVa?S08@
zDto|h{P{J+trYiLTAYAAsLpO<jS|NG=9?+uT((F1VxzY$%1XZfh&bQ44(@|-R;d1(
z2Cv3FFe#bcZYz!u&_5eO&9M(qMzY`di#fx63s!r3Yo>dbvOgF5mhTPh!7b&1j+4dr
zvk$I4-f)f+gBW8!UyAzl-#IfNnt#N7g_xwifvP)l2dQ5^NjPqe_g?+m9M+r1JK(%n
zRN0lBb!eFO-QfY}JH<yyYjD0zd}w#+QSg*=h`HPMvd;GL@2-ULG1By2<tpD9_eKBx
zUFgHyPXDd$Q^c~qLx1ikcCZs)^!#>La$IS5tFiy`OX|4G)T{Auwo)`pLu;)K#DjRP
zMqa+p&-#ixTm$CC;2dchpC~zX&#*I%y(?mB(t}Odq8};7gD;R~&x(82F9&q9!?>Sl
zd5U!!HiSL97mJt9p68vKb+@nm7JUcpCYQa@fgL5Crxkzu-Z9M+?-h>^{!N$K6mr7%
zuQTC%T4*2ezwQz%?AYopAV%0|bAH_JFD@~!3{QPbcV)HK%!GWi;hSQ3*fEPZHF_xE
z+fNfyg8dK0>osP3jJ$^5xa1s^p-vk<4(%>YOn#UBxvj-V%?~-p1|Q+kqnx+bcX8en
z=Oj(<Rj%?~%KpLdysH(fdkX!J{sx|z`ZRj~|AmM9M|h}x!1M8tSX98n$-i*%W%@%N
zVv7v_&camgAxvP+XJ&30)_&<t?En3Kz{maP<)e5w==2wp?iakVJe0k=cbw(5nZ5p>
z+noI~kC&xKu?>@G!{*<7n8ZEP$;Xfb#R1>?^XrEB#(MBgh(n30Af6|EJ@$T^)`927
z0QK#JDE3D^31=(5Y<QPT@x3_qr?VwiV3UbEkuKhHH>0$Wamm-)1Z)}D&i8o3chX7d
z=dyJ3uYH~I4byj%@5%Ru{$&kvHw8I==)J^`=JFTi(HPMKlUuKz64(l*SH@$OnXUfo
z{}$RN*-qJs;Eru}Td6v(hxk-trdNLLGXC9=A?!H+Hj&~he0P^{8)tV*_!abz^<R-W
zN!;}?v5&2u=3X1TJTPsVcVg-j#RPY8bXWUA^fKSH4$j!0ta`dA9Yeg`qW+nh+w#dY
z_e}1ve{%jaq26`&@o$+t3{5$oz?@QF<%4F>u}L@Msjms=aj%1WAS+o*imp%p+u76I
zCw2#C<aGb7Ijgg|x0L@3SyW%O&Q?C1rO7};`N=GD_<ujo!MB@O>p%};c*-Z68Rut>
zR94JPWwj5eJA;?1Ed8n~=!_rf9oiq<R;udUHnI*&4eSrjtg9ZiA%5OOIpN~9)*N#R
zVgGCBkG|Cu)P*iwMjzuoguE>j=SF3fM}3k^)zGiFpIUdzw^STh@5g13r`_A|^Ln_$
z%GvtJk7+WKqA@Ph9`$6&dt65<qD`=uPaP@B+8vxtjq<23dUm3|G@j?(+oE@I|AYQU
z^`?2(hR-bj0pG5nDPL%qg4{OIKlP!lqCU;lxNX)q!M*&iAur0SbL4{ZF9h+;POI*N
z<M{V@m}kUxJ>7i^>Lp!xeAi$3gpZzYQ#@O-#E%p?Uw$32n$vN+>54uny)hbN^LgGW
zZlE?}KIz+Pb~L`2CXzMDvAzX3_FGIUr~6ET+_f6{Hj~aKIBDGj3gc+{H`0`+CW87m
z)#CFoxJ$ur!1U%8@-#4TBzGi$U(Mk+ga27>I*aOofk$%9IP3#|X5~^CXytPQ_|;rp
zRhaLH;MY>Q)hKV}Z^38{416`0V&)7C4CLAZ_(-mCLYUqw__cAlMh*rHe623`0tQ{>
z+c-2a@U`Y#2bUHH9;wQGj)PRHXC((@l%ESp0p13~Rd0vjpN`ADz(F;&JKYK4&{W`&
zs@&mez^|Fyu@>N0t8&xd4*ZiuZpJ%+)SDBe-JiZw_>o-Q<${moIs|F&g)4-AHMi@^
zFn#(}A$}}?M{=#M@PXX?0Dd)hQjl^voKm%WhKnQvU#rRG=P2J-b1w(*kzDt?m0p)S
z@gBiMZuRd1>DNg<a&LNTbLq4o=|J`Sr-HQ8$mCXk2j&64lFFs#3vbNT-3X-qI|aXz
z$a#XKzxDy8AIWupP<SGDC!46sHyFSpxdkYifv?r(7JfvqIhVU#(Bzh`Q@$fPosUE>
zmJ@R{#|y<rIH$7^9eE^!jHN?AM0d$+uo;lNHqN(;d~M_#n<qsc?88W&wdAoY^6=Fs
zbm3?oeN&<`PaS!%TN4$dkzSU3>#jy9=OLV6ymD|RlXEkYZT&vR-zxsPh42%d1Xpdm
zYSk?Mv$5;8JG$0&U%A5k-o}lax}243Hm>O0u+mx8xn^zG${EgvuI}rc%T}7UYpx$D
zqk>niHgCW4it9hyxu)AhW!kA{!(AiTiaS=CjcdBY)b@>C-Db_YJG$;@&vxF{6=i+<
zsue4)xPH~zO&eFYtETo(Z|d6AWmJEAkb1>so36WTlX?I8P3u-V?_c7qSifPzrfm0`
z_3P-_rghG$jVo?<y4O3a*4%leX=@$rVmvH*xl(P=nfA5oSKJ<<agQq-jnboL->&Yj
zx#Ieb!N8*Oof|fE-u3Y{pSW_xrVX^xe#fTnt~<@!N0L9ae$$3^oom}Se0F2k9W=LQ
zL-$=_CAY0zv#~p@#oRb=-gVCOg=^MzZdmVtIM-g;dc`bv=DV+SXT4L%l`|dCIWuR?
zob7ykZIJJZF?rz2XVz?l4$jrrbgj5%)iulC{q7YjW?pmcs#WfaS*zxB&Fq}j)wOc=
z?Bz4NR<4+H^~%;yn7K?l)7jOze2uYY@>n%*{RaAe#oU=!n{l<(b8D>eiTYHdHOaat
z*<}5WH92uf>Qd`+Yer%|im>8`svP;H%+G>v-^K|^Gxn`9N&YwXmozDZypQ===E4Y*
z+$P>s9z{Fmmo($dWn*vyJ{??TZ{<(rrBbBVUy5+$&y948f1wOq`ab+w2GtPY4*^wP
z^G0^y)d*MlrjcQU<z*kjAOB((55i9YRX*q+_9Fa+`DI69d@B#aX8@J|0if*5*#4TT
zFt_2o`YXE={wy;X;fH}L|1F^G(GY!(+h2)Y3V&gF*{K*m$%F7?K;^#`DEs9__`d*U
z$57qDdoft{Oy%PG?GYx1^~=tMKfdI{gYYa+`QHkyW&iTPxP0n@D0?(M*~Rc@1@R8y
zL(nwN|ExXwUQNk<hCend8N2Y+QT@bRjO=O)>2djm*w;9}%FEuycnA4~H;?JxolT?f
zm0xx_{PDFO@(GXmeGj<o_2<U)_hj>EewCLU4}X>^kYBjyuKtbvB~4Am{HO`!>B*5y
zBa94El5*9@{F0QuYz%I|AEOER4c)+)9w+c0!e7Wg`4cg&@{SXs^iTblpAr5-`5v4)
zitD}nkMI}1KQL_+*L(RT;V*oDv}F|6d-*HjFMRLdx5RkR{uo^SYkJ4I@8#cwzp(r%
z{F@k8dHFjruJX5DK8owT{Gad_mOpXDD6aSNi^5;{z6F0M#)JNi!BzhY?z!*fCxt)D
zJPjX&9~mPrpTmEO->W|PQ!)NM@(a%bWB&aVKP!H({PMeE{3qlSUKpbfo{<3vejz{Q
zhsAg``Q(pf$K-!ON;LR|`2#;K!Zp5A=>XwB;d}XO;m<OYs7HPp|8Vh0f6a}f@6})V
zZ{aVb=c^wW#r0l(T=)y$XFoWK>%IKD@E5-C{?I6{_wxI~U--Tae=o-MUjAQ<Ydnoz
zqqyEL9fRwA4*xLxLEJIFq`9DCzFlB0XZ-r5__N;hK4pIQocDN>qSr|Nl<5SIXSv0j
zwGkfHmolFRuN#v;503f^e#(Ei0zXoL4_4qq75K9i_{j=9YAOIp^Omuw;onKEz~i2U
z$^5&WhQQ;<Pj6qZ!0V8k_^0=8t-z;O;8QB__f+8TtH5urz&}xeudBd!Rp9*<_!lei
zKd!+4vI0L|fq%CG|ECK4=N0(t75F#_M)VWCCRN~<R^T%#@Yxmkdn)h`RNx<}z}qYE
z|51VOsldNffq$a{|851&VrS&1@%^F#Z>So19n6EbSKwDy;P0!zKU#sWtiab-;QzA%
zUsQqLUxEL51%A8&|6T=NtiVrI;9V8`f34zuYTUW>xH!V)zty8z-c#}ZLlt-jxZ({h
zL4M2Z2bX`a6xCOcM(eJ~-&=uy6<q$pfha$hLPmb#-~R@ezwlD@{$~~MtE)${2mG8;
zfx8v>+zNbA1-_yJ&w|SzaiaEf74QEC^p!udHhRCK;{DzV{ExsDXGul*|F+`&4=eD0
zuE77j0#C-uA2Ntu_2BYvmg*V$&!~9+Zg9nQWGD3g!xis4z~%oqQTfk;EAA85w;Npk
zPdDRM`G+dXf4u^K4qX1w(Wt&3gDYNiIKqDhuDH>@2p=~ddV=2>;ZwjBM+(NK@qoua
zrEx*TD83Yz|6s-Yk5%BegDc(?k7qNu;!b($(s=F#SN!SLh&~Thl>ZBG`9rb1e!JrR
zkHO{ttd8pYmx}k*wZ^2=j5&Hg8wX-FcyEMX#QXTC@m*GdUk@(-DK4L>c;5xCIGF6Z
z#&a9E;$iW4f4?ICwhH_JxcsfPw5{@A0ax5C9?w%1`HL0!&%qU6(;8UitK=X>KaJ<&
z3f!&0=Yh+g`y6>yeoe*uJHh48rK0ie2ABWV7UlmkxZ-!QJp47d;&`c=u)gQO<DdHD
zRp4wGjr{cfRdD%#t&_s?wQ{DSpWeT%0-s)i&#J)ND)9Lg_@WBDy#nv9z_(T4`@j{a
zd?BLGBNgwDRp7_L70+}Ti|B3Qh}a6#(rMb;H*^sW>+J4ok3(S!*R`zV%^jT^Zf_qA
z+ywzF)46ixXqws3ML4fL41iH$q$Y*BqIO8$xM}$v1kgsqdtqQNN{-v@TDNk|`k+I1
ztpCip-DwYlf^kmua8q`rIz7_8u?5d<J?QbKJEBPAXE&^&7(L!VERUXrVMt1^S+}uk
zL-z<3x;J!nUAbcYx{cl04ePU4&L&3?lN`yQPEbm*(sR<zP3c~}p{r9FSFKsM5?X(z
zeO=d`-R-~MwPAhxaw4YcTs$nEH*6$pkYg3?w=Z9N`}$R@Oju<|zNo@=U7wA~zG8Lf
zIs&O76UKD;YSXzkVo1b__T_iAuk2dYxoIt-+V$-rDHMgJQM$JN_AaOpM`kygC~N!1
zpq}>i*^TFhaoabp?OZ-K${QxMx8L4%*Ok{^J-c<}T^KeEvWE?fNeHvgp559i8ms8+
z*>kSBcFgm;<LB1at7nZqUpsTm^Jx0jt*xX7(arWv>pm;8ugGTGvm0D<yT-PnbH(be
z_FzclBSpM0?cH63WIM?$ffi>z+qq#K16u#tY-jiC_H~=qt~JZotd9ytqN{`;@U4gJ
zrf!pkYj<RkE81AOX{`v`y`ghOS9bjxq%8<%k71@+vHp(i+OF;>(0#|o+suaL?Ohu>
zH+GHft3<&B(d95^96oMZ7lg5c!1b#28``6~hy=GYjc#KU8@rI-l}Oac*jB9V>f8{F
z?zRn`%NcxkXAp%qK`37G*R>J8um9{i<N>jTIxDhwG1o#=qzQ6{svzt^RKce36$4(o
ze*Nt#v7DhJ!|Gc&w|KW^9eO}r4(HNpHA2Q{?yXqAcKwD>H*|My&=6J<++HE6TuEsC
zO;xicK_aAHar;PfnzBUKyVkAfQq7u6<f&xBIaB#OEgEKC`$js!sMc<}EkK#UYuKI$
z@a{EtbZyLbt!VFF-~OpJt5&V)Vs3<54pE>%rq{|fpScE66b~R@AQ9*3$vNu6+#XKv
z_KmC8Z(55icCXJ;X5;dxFTsor6VR671V)IM{u{Lw63QY>(;f?=nC;xqr5*+%8g)N-
z?%dS9enVHFW<T4>tY5Wh-3nD;R={>?)o?Ee3$PCDfNW{bY#b|-VaBm3E9t|A^>>-I
z!R7|)q>EjV_VpW9c5R@?VrC#Z-E1eFhYTCKZWGreDw?E$Qd)`P9gDx2jmW$V%a}63
z6kFc8wiEuhvw5`qHq-eTn(SP@7F_a3_3PQ33Nmh7y<yF|+uM;583T!{VdF|93$m{3
z?A~~8!WyR2@=a@CO_)LW#=F+7fZ4(B&bsxGA*x%+t0H8yN8!ucRzQP*^qaD18X3oP
zrf|%NQ0HsU3NAz5wPPtBs^vhmM+7HgAhMvYP&M3TGGfD4Xlmac=#ty-2#ZE+jW`$C
z=W`m1#Zht?P%P+cY_LL6KX<;LKift;1#}Mr5tj{(U8s-{)qtFl*rBlkYZ=%<RB^lX
z=x9o8JCz(1WKxd00c+NMrgQC@z&BVf1-TLH8LEgt2X|p^JG(p0I!PFNi%=aO08i(x
zaQLC(jJ*O$?WmHBT#nI%_6?n%ZQqz(vo6%jqiCd?11f7i$y$#LuIo<i{&jCyBU^;e
zqrOIB5+ousk&`0D7W8`5lB@H$1=_$2B{)<%!PL4#{0NJV_A$`?BZ@nCyS$UqVLk~-
zIN3DR09&(e)%vjRXuMIAw~J#CJS-R_2D9`{-3X;3NJa&%#rj1Z4*bL0N1Iz2w6}g$
z$dQWK9#JHaH>5cj;Arp1HhM=FreY;lZGE6?!|4<kktKhVme^<_xzh%8ICBFlwVvTc
zzURnn9(9x|h8*_{OS9pwY&Siq?4w){aVi|~7`lZLCz~;b3!{nAgo^i%5ij|6o9-~7
zHi%_i<-=*QYRv{DDw-*Q^$zNl-3}i@l~tkDWk<RZ1!l+X?b_uhA#^Qdr9mP!!P93#
zg%K#9m1wNUkcT_l8#+hlh~_y)3$qjOHkw-GA8qNjO`Iw)+1pS_-MD)j)^)AL(+q4!
zJV#=?qp2G;-5yBaX9D&0TXM%%ignHl{55Y2_v8d~EPE2f2^C{%-p<;dwNvvB)`o(2
zvp)j7cqfHe(<)tS+r(zpOv1lF{2_uJg1cBd3+|?z;60S1?!+G&;{coU#AkpP^M1AP
zJ;X)?_tL&#ANh&Vss2<1YXo^W2iVNQwgY%^zcD+6@26g3V(RA%LHd~yyq9rC>0Xrn
zMs=94hPANrY2R1v>=J%}xJCpWVip%4WDN~ed)hWsdx|wQb33L(@IJ;V$op<V0y@2d
z_fwzX7l}bc_@E%=j|sAY{gNR4eNAvD^|QuqE)aJBUi>9uJwWwqNa<gOPlDvvT3q?H
z#unew5!@yCAnyeqf^HXt<!c0?TU`Y0DE%-{d^sxkFzsCkWE}Ga|A_TI+Z4@z%s2&U
zcda1p*0A7L`V7G%j5op$2$Jt1LGm3FWW3skPJ9Kr3NjvTcQk*My|W0eW#2iVpWvS`
zUcpC<c}9@(rvx=_LFzrsMdju{g|CA2fBq!kpFu~#uOXLj1%844MKCKk06zqGA=iSt
z>5m}!wa=}7Wd#46IDp`zoXixY&K<z!$JiSb95m)h!M~uq;MeI#^!_!$za$3S1Uw3V
z1Sz*v@UM_F!EX?!0Ve($el&x_zm^ET1Qefoi6g7rVL{q^R`74(5Aoz+-U!mZD@eYK
zAnkrm@F?>*N`FL<c8>|tuJ*6h?oWk7M>7RT`;8HF1>yfb!G7kg;N$!`$Rl)ifa+h1
z;Bm$U6kj?7sc)?y<qt&Z4@K!u3R2%s1^eKW;6cVeHH6KAUqWtxYDfFz;>S@z+B+ur
zB>e|AKTVuc@LTjR!c&)mKLdRPdEX-VZRjER9q1^CybML}UlK&lP6_@m>JdcV-Vl72
zziIqY&z*vl)4sgqVMzE>#7J9!jPnuT#eWAKE(3p%ehQwTpMu|mUT+Wk-y*mf{sWtz
zhrWX3_XJ;{eZe0vU*7@zVYpA9_<NqgHGW5s@-2dG$W?^j3T*xd=q^aPhXm=@QNbS}
zH-gapCBgmBEqeckAbhKt4uo%QK<Tw-g#R&g5!8H(-Y<M-nBE~s`dUHC9gWg;Zb1E8
zcsc3tSLX!O?}vn|KY~A|AA%n9@LfRopPK=s-67z`(Cw$fc|Ujskb0gJq@2zbsJ<7j
z1gCvZa3}c%slV~6u>U$=pnfa`Dt$nZ`qM7&|A~15l-^z@cpu{sydS+S_yBwnr2YXx
z>OU%2pdUc#<7b6$ryoGIQ#TWQ7&#C;MY<sUH?u<M2vXk+LF!u@r5}ybpN!H^MbOM9
z-wyaK_zHim{88T=LF$<=NIg3Dp!NrZ)BZDpYG07@uSU?m8k~BX1ouG)LFmyf=u?j%
zbl4>b9Uc*+oo57T=Y$~R_kbF|&QGXa^KR0qZ@OSV^t=wZhkD)<rXLXeXZSD3`vJkf
zqF$iNKO4b1WI5np1Q!Ut$T$Rx$crH5XZ$YkKIRWlaylTKem*NmKj&Nzq(939{}1{|
z@L$l^f|N_$5W?vZ+!euRfT~aDHq@^fY4ZJy7`Gth^MbT<Sdexe5qy<?3I39K0#rGB
zF7^D{81r7z=|@cjm(ByH{*^$r^Hbrkq5lLa|IB>gJ+v<f-(D8{H{|qvVfw9t$XibE
zb;ct|`_BmeEA<J|znb?0>7OlFfZu{&VjK}%Ab5~@8Nts9Qtp5t<qCq7J0eKA6N1b?
zoj;M@O$jp28o?CrfEwo<LB^F4r2av{-!LBF#b?RC0Q@=nBY2qng0#0#kn*bqv0Kjy
zQtnkj>Z|)bAoVp0ei1t-xC8kWgg%3U(CwJu1C$s1ciI)SER+5KFkzVv!K7uff{gFU
z2<qI7#$|ty^eW4=2vWXH@NVQta3^vkNV&B@$-mCihz<voeh9h=B40-Z@2C9;PG1O4
zztV!#cdH=vtrVobZlLPR3#Xm~g4A<HkaG5ifRvjdNV!%)%B2M<r*k{%$G)4uq2rKX
ztz~LH44lAt1nVrbT9A6W1*s<=;fEvqSwZOS2~y7)LF#GDg!0-7l>R*`NWCvbcxn+i
z^*0Mr|8zm>&j=zn`6&Hxl>VyVKOskpfsEG?)c6E7K0(GmKY|%S=($V~dfX{U{(XYv
zKP(769ukBeLxPlVTLL8C0zvYnZw~QW1;JMeil2g%8xTB&90?v^J_$13nvaCIBlrsa
z6C_>dp+xtzAoE~;gfEC-FHrXV5y1;Ble;CvPYAxnGIh&<4>At~U!b3YKY%}i--m93
zKSaI-smBwvEk17r<Z|l_LGXnUo);wFNx^#Fe++mp{Su_TTLpQ)OOSGp2vW}r5&mj~
zH+`IR=Aj$Gm4f8oCrCYmg4A<DkblMDOoX@I3jQ+v7i_f5fFOK6DtI6BK@dKkiQukJ
zfWx07g79NN5PlpLgda7Z1X9oE1gWQ2ka~^^PO^+ANclGeDW7TwQoc@*@~wjO^VSHy
z5W!Rj>5QjEkntZ7q@F=R>NzG@KtBjl&q+br_XKIb&<SLI3<xq0h6L|N?+7vvUW)MM
z<>39ui6Hea6QuqQLF!*E_$BBf$T-~<z{B_}f?tGBg2>|mLG<0x2)-cr3U)(~@v-d~
z@MXRr<LVI9xCAMGMDWLqPmpq^3rK(J1nG~??a9Av66Bz9v*2dtrC^HsBYe8xmCVx!
zcLhHUog;is1luB*j^O+VE{Nd52xbH?vdk`^`g1^#{yZrNy`L3?-e&}%ud@nBzBWPf
z%@>4@3k9L$=c4yJqW24KBON(DB}n<U)j-NG5TtzFn(+NGLFn|1;6d^WLa)@PLcB@v
z6~-wD-xmtP*Q_A)&I>~CqtW}u+rhs^dxH0pPmufv1W%%$1pk5d1exEdwLt2%1%Jmf
zj^JeEL6C9_qx4&&^sFG|4oC2z2o6T@q#*U25~QA2BRq9Sh}Q{Heoh4E3zC0ngx?y$
zl@VMU!R`p=BUp&wKm?x^q`i}ZYCpnXjqudE@O_gY?K=^i1H2f#EyCwVutV@~m?sg;
zM(}gMi%HjcQpu-&@p)0R6}=JRb_AOu=tOXO1l<VEiC{W{3nGYl3+hGf2CyT7t0S0=
z;GGf7MQ}$1^AS7{!9oO&L~tO2M<X~C!Dk|PB7!F)=tb~U1kXh9wg20=`GnXM#c}+g
z^n@C0rYLWtL{2l3gfdnpMN*1vn5eNB^P2b6%tn%;Scr|KM3gDBuy}=<g@s}<3yWEf
z-7G9DEq%WCe1ESqO8M2fpYuEC_xqi{_ubpQ@0w{{>1WGiYc~BJHrwW2bHqGij+x`;
zIrE}<#nd+fn(vM|Yu+&*n2*h8=5zCnxnTCqMe~cfWG<U4=BoM2{B0)sq<*!`A#>Pl
zGf%rd@w;J8nvcwvBKvCId~be+`aRUTXuo~4uJuv*cN3(2hjm2Qhm!S|Ippr#RF9Yb
zndh~Ilab>EPv#?{Udnn<p7I2*oASx?XEJ5-P<>HvT$?Sbo-^BLV3@1IH7<Ww%uJVd
z3e};}Jev6b!<0T_OZnz>?|MFU_QHYY(R1m_)gEtHCiqUP+YITy4!f~pS<*&ZAA<Kd
zUqhJ2Ms{-CL>g-}?s=YYo!g$$4s`j;u0`5oeFK#At60)yE7?zyeQh_S3QM#*f-WDn
zMkD`<cY<2%I(I9(HcruA#5+cPJ&y5L+y`T)acB-=99*&+-<X%>4)+(7g+#p56x8uL
zueooaOz||nh<Ay6J&pyg$F)R1XNuim9I{g!B}ufaX|3B`qFv3O+TCnB`8*`m?e>Wm
zF{m2k?~||Ntq@QCinrBv(w~wP?;uI?k$AVG^XSSdy)d<YlB3;}Zk23v47;~zm3w-J
zT`f`ffkO5Qt58IC$3uZ(C$gLa`H9`)HtwA$(W$PnYo0XL*n4EtJe5DTC|4xn;kw3d
Mm3jFZMlkID0GyWTPXGV_

literal 0
HcmV?d00001

diff --git a/sound/soc/codecs/wcd9320.c b/sound/soc/codecs/wcd9320.c
deleted file mode 100644
index a49ed279975b..000000000000
--- a/sound/soc/codecs/wcd9320.c
+++ /dev/null
@@ -1,7812 +0,0 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/firmware.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#include <linux/device.h>
-#include <linux/printk.h>
-#include <linux/ratelimit.h>
-#include <linux/debugfs.h>
-#include <linux/wait.h>
-#include <linux/mfd/wcd9xxx/core.h>
-#include <linux/mfd/wcd9xxx/wcd9xxx_registers.h>
-#include <linux/mfd/wcd9xxx/wcd9320_registers.h>
-#include <linux/mfd/wcd9xxx/pdata.h>
-#include <linux/regulator/consumer.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/tlv.h>
-#include <linux/bitops.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include <linux/kernel.h>
-#include <linux/gpio.h>
-#include <linux/pm_qos.h>
-#include <linux/pm.h>
-#include <mach/cpuidle.h>
-#include "wcd9320.h"
-#include "wcd9xxx-resmgr.h"
-#include "wcd9xxx-common.h"
-#include "wcdcal-hwdep.h"
-
-#if defined(CONFIG_SND_SOC_ES705)
-#include "audience/es705-export.h"
-#elif defined(CONFIG_SND_SOC_ES325)
-#include "es325-export.h"
-#endif
-
-#if defined(CONFIG_SND_SOC_ES705)
-
-#define CONFIG_SND_SOC_ESXXX
-#define REMOTE_ROUTE_ENABLE_CB  es705_remote_route_enable
-#define SLIM_GET_CHANNEL_MAP_CB es705_slim_get_channel_map
-#define SLIM_SET_CHANNEL_MAP_CB es705_slim_set_channel_map
-#define SLIM_HW_PARAMS_CB       es705_slim_hw_params
-#define REMOTE_CFG_SLIM_RX_CB	es705_remote_cfg_slim_rx
-#define REMOTE_CLOSE_SLIM_RX_CB	es705_remote_close_slim_rx
-#define REMOTE_CFG_SLIM_TX_CB	es705_remote_cfg_slim_tx
-#define REMOTE_CLOSE_SLIM_TX_CB	es705_remote_close_slim_tx
-#define REMOTE_ADD_CODEC_CONTROLS_CB	es705_remote_add_codec_controls
-#endif
-
-#define TAIKO_MAD_SLIMBUS_TX_PORT 12
-#define TAIKO_MAD_AUDIO_FIRMWARE_PATH "wcd9320/wcd9320_mad_audio.bin"
-#define TAIKO_VALIDATE_RX_SBPORT_RANGE(port) ((port >= 16) && (port <= 22))
-#define TAIKO_CONVERT_RX_SBPORT_ID(port) (port - 16) /* RX1 port ID = 0 */
-
-#define TAIKO_HPH_PA_SETTLE_COMP_ON 3000
-#define TAIKO_HPH_PA_SETTLE_COMP_OFF 13000
-
-#define DAPM_MICBIAS2_EXTERNAL_STANDALONE "MIC BIAS2 External Standalone"
-#define DAPM_MICBIAS3_EXTERNAL_STANDALONE "MIC BIAS3 External Standalone"
-
-/* RX_HPH_CNP_WG_TIME increases by 0.24ms */
-#define TAIKO_WG_TIME_FACTOR_US	240
-
-static atomic_t kp_taiko_priv;
-static int spkr_drv_wrnd_param_set(const char *val,
-				   const struct kernel_param *kp);
-static int spkr_drv_wrnd = 1;
-
-#if defined(CONFIG_SEC_JACTIVE_PROJECT)
-static int sub_mic_rec_delay = 0;
-#endif
-
-static struct kernel_param_ops spkr_drv_wrnd_param_ops = {
-	.set = spkr_drv_wrnd_param_set,
-	.get = param_get_int,
-};
-
-static struct afe_param_slimbus_slave_port_cfg taiko_slimbus_slave_port_cfg = {
-	.minor_version = 1,
-	.slimbus_dev_id = AFE_SLIMBUS_DEVICE_1,
-	.slave_dev_pgd_la = 0,
-	.slave_dev_intfdev_la = 0,
-	.bit_width = 16,
-	.data_format = 0,
-	.num_channels = 1
-};
-
-static struct afe_param_cdc_reg_cfg audio_reg_cfg[] = {
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_MAD_MAIN_CTL_1),
-		HW_MAD_AUDIO_ENABLE, 0x1, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_MAD_AUDIO_CTL_3),
-		HW_MAD_AUDIO_SLEEP_TIME, 0xF, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_MAD_AUDIO_CTL_4),
-		HW_MAD_TX_AUDIO_SWITCH_OFF, 0x1, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_DESTN3),
-		MAD_AUDIO_INT_DEST_SELECT_REG, 0x1, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_MASK3),
-		MAD_AUDIO_INT_MASK_REG, 0x1, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_STATUS3),
-		MAD_AUDIO_INT_STATUS_REG, 0x1, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_CLEAR3),
-		MAD_AUDIO_INT_CLEAR_REG, 0x1, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_SB_PGD_PORT_TX_BASE),
-		SB_PGD_PORT_TX_WATERMARK_N, 0x1E, 8, 0x1
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_SB_PGD_PORT_TX_BASE),
-		SB_PGD_PORT_TX_ENABLE_N, 0x1, 8, 0x1
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_SB_PGD_PORT_RX_BASE),
-		SB_PGD_PORT_RX_WATERMARK_N, 0x1E, 8, 0x1
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_SB_PGD_PORT_RX_BASE),
-		SB_PGD_PORT_RX_ENABLE_N, 0x1, 8, 0x1
-	},
-	{	1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_ANC1_IIR_B1_CTL),
-		AANC_FF_GAIN_ADAPTIVE, 0x4, 8, 0
-	},
-	{	1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_ANC1_IIR_B1_CTL),
-		AANC_FFGAIN_ADAPTIVE_EN, 0x8, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_ANC1_GAIN_CTL),
-		AANC_GAIN_CONTROL, 0xFF, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_DESTN3),
-		MAD_CLIP_INT_DEST_SELECT_REG, 0x8, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_MASK3),
-		MAD_CLIP_INT_MASK_REG, 0x8, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_STATUS3),
-		MAD_CLIP_INT_STATUS_REG, 0x8, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_INTR_CLEAR3),
-		MAD_CLIP_INT_CLEAR_REG, 0x8, 8, 0
-	},
-};
-
-static struct afe_param_cdc_reg_cfg clip_reg_cfg[] = {
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_B1_CTL),
-		SPKR_CLIP_PIPE_BANK_SEL, 0x3, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL0),
-		SPKR_CLIPDET_VAL0, 0xff, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL1),
-		SPKR_CLIPDET_VAL1, 0xff, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL2),
-		SPKR_CLIPDET_VAL2, 0xff, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL3),
-		SPKR_CLIPDET_VAL3, 0xff, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL4),
-		SPKR_CLIPDET_VAL4, 0xff, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL5),
-		SPKR_CLIPDET_VAL5, 0xff, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL6),
-		SPKR_CLIPDET_VAL6, 0xff, 8, 0
-	},
-	{
-		1,
-		(TAIKO_REGISTER_START_OFFSET + TAIKO_A_CDC_SPKR_CLIPDET_VAL7),
-		SPKR_CLIPDET_VAL7, 0xff, 8, 0
-	},
-};
-
-static struct afe_param_cdc_reg_cfg_data taiko_audio_reg_cfg = {
-	.num_registers = ARRAY_SIZE(audio_reg_cfg),
-	.reg_data = audio_reg_cfg,
-};
-
-static struct afe_param_cdc_reg_cfg_data taiko_clip_reg_cfg = {
-	.num_registers = ARRAY_SIZE(clip_reg_cfg),
-	.reg_data = clip_reg_cfg,
-};
-
-static struct afe_param_id_cdc_aanc_version taiko_cdc_aanc_version = {
-	.cdc_aanc_minor_version = AFE_API_VERSION_CDC_AANC_VERSION,
-	.aanc_hw_version        = AANC_HW_BLOCK_VERSION_2,
-};
-
-static struct afe_param_id_clip_bank_sel clip_bank_sel = {
-	.minor_version = AFE_API_VERSION_CLIP_BANK_SEL_CFG,
-	.num_banks = AFE_CLIP_MAX_BANKS,
-	.bank_map = {0, 1, 2, 3},
-};
-
-module_param_cb(spkr_drv_wrnd, &spkr_drv_wrnd_param_ops, &spkr_drv_wrnd, 0644);
-MODULE_PARM_DESC(spkr_drv_wrnd,
-	       "Run software workaround to avoid leakage on the speaker drive");
-
-#define WCD9320_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\
-			SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000 |\
-			SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
-
-#define NUM_DECIMATORS 10
-#define NUM_INTERPOLATORS 7
-#define BITS_PER_REG 8
-#define TAIKO_TX_PORT_NUMBER	16
-#define TAIKO_RX_PORT_START_NUMBER	16
-
-#define TAIKO_I2S_MASTER_MODE_MASK 0x08
-
-#define TAIKO_SLIM_CLOSE_TIMEOUT 1000
-#define TAIKO_SLIM_IRQ_OVERFLOW (1 << 0)
-#define TAIKO_SLIM_IRQ_UNDERFLOW (1 << 1)
-#define TAIKO_SLIM_IRQ_PORT_CLOSED (1 << 2)
-#define TAIKO_MCLK_CLK_12P288MHZ 12288000
-#define TAIKO_MCLK_CLK_9P6MHZ 9600000
-
-#define TAIKO_FORMATS_S16_S24_LE (SNDRV_PCM_FMTBIT_S16_LE | \
-			SNDRV_PCM_FORMAT_S24_LE)
-
-#define TAIKO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE)
-
-#define TAIKO_SLIM_PGD_PORT_INT_TX_EN0 (TAIKO_SLIM_PGD_PORT_INT_EN0 + 2)
-
-enum {
-	AIF1_PB = 0,
-	AIF1_CAP,
-	AIF2_PB,
-	AIF2_CAP,
-	AIF3_PB,
-	AIF3_CAP,
-	AIF4_VIFEED,
-	AIF4_MAD_TX,
-	NUM_CODEC_DAIS,
-};
-
-enum {
-	RX_MIX1_INP_SEL_ZERO = 0,
-	RX_MIX1_INP_SEL_SRC1,
-	RX_MIX1_INP_SEL_SRC2,
-	RX_MIX1_INP_SEL_IIR1,
-	RX_MIX1_INP_SEL_IIR2,
-	RX_MIX1_INP_SEL_RX1,
-	RX_MIX1_INP_SEL_RX2,
-	RX_MIX1_INP_SEL_RX3,
-	RX_MIX1_INP_SEL_RX4,
-	RX_MIX1_INP_SEL_RX5,
-	RX_MIX1_INP_SEL_RX6,
-	RX_MIX1_INP_SEL_RX7,
-	RX_MIX1_INP_SEL_AUXRX,
-};
-
-#define TAIKO_COMP_DIGITAL_GAIN_OFFSET 3
-
-static const DECLARE_TLV_DB_SCALE(digital_gain, 0, 1, 0);
-static const DECLARE_TLV_DB_SCALE(line_gain, 0, 7, 1);
-static const DECLARE_TLV_DB_SCALE(analog_gain, 0, 25, 1);
-static struct snd_soc_dai_driver taiko_dai[];
-static const DECLARE_TLV_DB_SCALE(aux_pga_gain, 0, 2, 0);
-
-/* Codec supports 2 IIR filters */
-enum {
-	IIR1 = 0,
-	IIR2,
-	IIR_MAX,
-};
-/* Codec supports 5 bands */
-enum {
-	BAND1 = 0,
-	BAND2,
-	BAND3,
-	BAND4,
-	BAND5,
-	BAND_MAX,
-};
-
-enum {
-	COMPANDER_0,
-	COMPANDER_1,
-	COMPANDER_2,
-	COMPANDER_MAX,
-};
-
-enum {
-	COMPANDER_FS_8KHZ = 0,
-	COMPANDER_FS_16KHZ,
-	COMPANDER_FS_32KHZ,
-	COMPANDER_FS_48KHZ,
-	COMPANDER_FS_96KHZ,
-	COMPANDER_FS_192KHZ,
-	COMPANDER_FS_MAX,
-};
-
-struct comp_sample_dependent_params {
-	u32 peak_det_timeout;
-	u32 rms_meter_div_fact;
-	u32 rms_meter_resamp_fact;
-};
-
-struct hpf_work {
-	struct taiko_priv *taiko;
-	u32 decimator;
-	u8 tx_hpf_cut_of_freq;
-	struct delayed_work dwork;
-};
-
-static struct hpf_work tx_hpf_work[NUM_DECIMATORS];
-
-static const struct wcd9xxx_ch taiko_rx_chs[TAIKO_RX_MAX] = {
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER, 0),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 1, 1),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 2, 2),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 3, 3),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 4, 4),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 5, 5),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 6, 6),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 7, 7),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 8, 8),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 9, 9),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 10, 10),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 11, 11),
-	WCD9XXX_CH(TAIKO_RX_PORT_START_NUMBER + 12, 12),
-};
-
-static const struct wcd9xxx_ch taiko_tx_chs[TAIKO_TX_MAX] = {
-	WCD9XXX_CH(0, 0),
-	WCD9XXX_CH(1, 1),
-	WCD9XXX_CH(2, 2),
-	WCD9XXX_CH(3, 3),
-	WCD9XXX_CH(4, 4),
-	WCD9XXX_CH(5, 5),
-	WCD9XXX_CH(6, 6),
-	WCD9XXX_CH(7, 7),
-	WCD9XXX_CH(8, 8),
-	WCD9XXX_CH(9, 9),
-	WCD9XXX_CH(10, 10),
-	WCD9XXX_CH(11, 11),
-	WCD9XXX_CH(12, 12),
-	WCD9XXX_CH(13, 13),
-	WCD9XXX_CH(14, 14),
-	WCD9XXX_CH(15, 15),
-};
-
-static const u32 vport_check_table[NUM_CODEC_DAIS] = {
-	0,					/* AIF1_PB */
-	(1 << AIF2_CAP) | (1 << AIF3_CAP),	/* AIF1_CAP */
-	0,					/* AIF2_PB */
-	(1 << AIF1_CAP) | (1 << AIF3_CAP),	/* AIF2_CAP */
-	0,					/* AIF2_PB */
-	(1 << AIF1_CAP) | (1 << AIF2_CAP),	/* AIF2_CAP */
-};
-
-static const u32 vport_i2s_check_table[NUM_CODEC_DAIS] = {
-	0,	/* AIF1_PB */
-	0,	/* AIF1_CAP */
-	0,	/* AIF2_PB */
-	0,	/* AIF2_CAP */
-};
-
-struct taiko_priv {
-	struct snd_soc_codec *codec;
-	u32 adc_count;
-	u32 rx_bias_count;
-	s32 dmic_1_2_clk_cnt;
-	s32 dmic_3_4_clk_cnt;
-	s32 dmic_5_6_clk_cnt;
-	s32 ldo_h_users;
-	s32 micb_2_users;
-
-	u32 anc_slot;
-	bool anc_func;
-
-	/*track taiko interface type*/
-	u8 intf_type;
-
-	/* num of slim ports required */
-	struct wcd9xxx_codec_dai_data  dai[NUM_CODEC_DAIS];
-
-	/*compander*/
-	int comp_enabled[COMPANDER_MAX];
-	u32 comp_fs[COMPANDER_MAX];
-
-	/* Maintain the status of AUX PGA */
-	int aux_pga_cnt;
-	u8 aux_l_gain;
-	u8 aux_r_gain;
-
-	bool spkr_pa_widget_on;
-	struct regulator *spkdrv_reg;
-
-	bool mbhc_started;
-
-	struct afe_param_cdc_slimbus_slave_cfg slimbus_slave_cfg;
-
-	/* resmgr module */
-	struct wcd9xxx_resmgr resmgr;
-	/* mbhc module */
-	struct wcd9xxx_mbhc mbhc;
-
-	/* class h specific data */
-	struct wcd9xxx_clsh_cdc_data clsh_d;
-
-	int (*machine_codec_event_cb)(struct snd_soc_codec *codec,
-			enum wcd9xxx_codec_event);
-
-	/*
-	 * list used to save/restore registers at start and
-	 * end of impedance measurement
-	 */
-	struct list_head reg_save_restore;
-	struct pm_qos_request pm_qos_req;
-	/* cal info for codec */
-	struct fw_info *fw_data;
-};
-
-static const u32 comp_shift[] = {
-	4, /* Compander 0's clock source is on interpolator 7 */
-	0,
-	2,
-};
-
-static const int comp_rx_path[] = {
-	COMPANDER_1,
-	COMPANDER_1,
-	COMPANDER_2,
-	COMPANDER_2,
-	COMPANDER_2,
-	COMPANDER_2,
-	COMPANDER_0,
-	COMPANDER_MAX,
-};
-
-static const struct comp_sample_dependent_params comp_samp_params[] = {
-	{
-		/* 8 Khz */
-		.peak_det_timeout = 0x06,
-		.rms_meter_div_fact = 0x09,
-		.rms_meter_resamp_fact = 0x06,
-	},
-	{
-		/* 16 Khz */
-		.peak_det_timeout = 0x07,
-		.rms_meter_div_fact = 0x0A,
-		.rms_meter_resamp_fact = 0x0C,
-	},
-	{
-		/* 32 Khz */
-		.peak_det_timeout = 0x08,
-		.rms_meter_div_fact = 0x0B,
-		.rms_meter_resamp_fact = 0x1E,
-	},
-	{
-		/* 48 Khz */
-		.peak_det_timeout = 0x09,
-		.rms_meter_div_fact = 0x0B,
-		.rms_meter_resamp_fact = 0x28,
-	},
-	{
-		/* 96 Khz */
-		.peak_det_timeout = 0x0A,
-		.rms_meter_div_fact = 0x0C,
-		.rms_meter_resamp_fact = 0x50,
-	},
-	{
-		/* 192 Khz */
-		.peak_det_timeout = 0x0B,
-		.rms_meter_div_fact = 0xC,
-		.rms_meter_resamp_fact = 0x50,
-	},
-};
-
-static unsigned short rx_digital_gain_reg[] = {
-	TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL,
-	TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL,
-};
-
-
-static unsigned short tx_digital_gain_reg[] = {
-	TAIKO_A_CDC_TX1_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX2_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX3_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX4_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX5_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX6_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX7_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX8_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX9_VOL_CTL_GAIN,
-	TAIKO_A_CDC_TX10_VOL_CTL_GAIN,
-};
-
-static int spkr_drv_wrnd_param_set(const char *val,
-				   const struct kernel_param *kp)
-{
-	struct snd_soc_codec *codec;
-	int ret, old;
-	struct taiko_priv *priv;
-
-	priv = (struct taiko_priv *)atomic_read(&kp_taiko_priv);
-	if (!priv) {
-		pr_debug("%s: codec isn't yet registered\n", __func__);
-		return 0;
-	}
-
-	codec = priv->codec;
-	mutex_lock(&codec->mutex);
-	old = spkr_drv_wrnd;
-	ret = param_set_int(val, kp);
-	if (ret) {
-		mutex_unlock(&codec->mutex);
-		return ret;
-	}
-
-	pr_debug("%s: spkr_drv_wrnd %d -> %d\n", __func__, old, spkr_drv_wrnd);
-	if ((old == -1 || old == 0) && spkr_drv_wrnd == 1) {
-		WCD9XXX_BG_CLK_LOCK(&priv->resmgr);
-		wcd9xxx_resmgr_get_bandgap(&priv->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-		WCD9XXX_BG_CLK_UNLOCK(&priv->resmgr);
-		snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_EN, 0x80, 0x80);
-	} else if (old == 1 && spkr_drv_wrnd == 0) {
-		WCD9XXX_BG_CLK_LOCK(&priv->resmgr);
-		wcd9xxx_resmgr_put_bandgap(&priv->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-		WCD9XXX_BG_CLK_UNLOCK(&priv->resmgr);
-		if (!priv->spkr_pa_widget_on)
-			snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_EN, 0x80,
-					    0x00);
-	}
-	mutex_unlock(&codec->mutex);
-
-	return 0;
-}
-
-static int taiko_get_anc_slot(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	ucontrol->value.integer.value[0] = taiko->anc_slot;
-	return 0;
-}
-
-static int taiko_put_anc_slot(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	taiko->anc_slot = ucontrol->value.integer.value[0];
-	return 0;
-}
-
-static int taiko_get_anc_func(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	ucontrol->value.integer.value[0] = (taiko->anc_func == true ? 1 : 0);
-	return 0;
-}
-
-static int taiko_put_anc_func(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-
-	mutex_lock(&dapm->codec->mutex);
-	taiko->anc_func = (!ucontrol->value.integer.value[0] ? false : true);
-
-	dev_dbg(codec->dev, "%s: anc_func %x", __func__, taiko->anc_func);
-
-	if (taiko->anc_func == true) {
-		snd_soc_dapm_enable_pin(dapm, "ANC HPHR");
-		snd_soc_dapm_enable_pin(dapm, "ANC HPHL");
-		snd_soc_dapm_enable_pin(dapm, "ANC HEADPHONE");
-		snd_soc_dapm_enable_pin(dapm, "ANC EAR PA");
-		snd_soc_dapm_enable_pin(dapm, "ANC EAR");
-		snd_soc_dapm_disable_pin(dapm, "HPHR");
-		snd_soc_dapm_disable_pin(dapm, "HPHL");
-		snd_soc_dapm_disable_pin(dapm, "HEADPHONE");
-		snd_soc_dapm_disable_pin(dapm, "EAR PA");
-		snd_soc_dapm_disable_pin(dapm, "EAR");
-	} else {
-		snd_soc_dapm_disable_pin(dapm, "ANC HPHR");
-		snd_soc_dapm_disable_pin(dapm, "ANC HPHL");
-		snd_soc_dapm_disable_pin(dapm, "ANC HEADPHONE");
-		snd_soc_dapm_disable_pin(dapm, "ANC EAR PA");
-		snd_soc_dapm_disable_pin(dapm, "ANC EAR");
-		snd_soc_dapm_enable_pin(dapm, "HPHR");
-		snd_soc_dapm_enable_pin(dapm, "HPHL");
-		snd_soc_dapm_enable_pin(dapm, "HEADPHONE");
-		snd_soc_dapm_enable_pin(dapm, "EAR PA");
-		snd_soc_dapm_enable_pin(dapm, "EAR");
-	}
-	snd_soc_dapm_sync(dapm);
-	mutex_unlock(&dapm->codec->mutex);
-	return 0;
-}
-
-static int taiko_get_iir_enable_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-
-	ucontrol->value.integer.value[0] =
-		(snd_soc_read(codec, (TAIKO_A_CDC_IIR1_CTL + 16 * iir_idx)) &
-		(1 << band_idx)) != 0;
-
-	pr_debug("%s: IIR #%d band #%d enable %d\n", __func__,
-		iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[0]);
-	return 0;
-}
-
-#if defined(CONFIG_SEC_JACTIVE_PROJECT)
-static int taiko_get_sub_mic_delay_set(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	return 0;
-}
-
-static int taiko_put_sub_mic_delay_set(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	sub_mic_rec_delay = ucontrol->value.integer.value[0];
-	pr_info("%s : sub_mic_rec_delay : %d\n",  __func__, sub_mic_rec_delay);
-
-	return 0;
-}
-#endif
-
-static int taiko_put_iir_enable_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-	int value = ucontrol->value.integer.value[0];
-
-	/* Mask first 5 bits, 6-8 are reserved */
-	snd_soc_update_bits(codec, (TAIKO_A_CDC_IIR1_CTL + 16 * iir_idx),
-		(1 << band_idx), (value << band_idx));
-
-	pr_debug("%s: IIR #%d band #%d enable %d\n", __func__,
-		iir_idx, band_idx,
-		((snd_soc_read(codec, (TAIKO_A_CDC_IIR1_CTL + 16 * iir_idx)) &
-		(1 << band_idx)) != 0));
-	return 0;
-}
-static uint32_t get_iir_band_coeff(struct snd_soc_codec *codec,
-				int iir_idx, int band_idx,
-				int coeff_idx)
-{
-	uint32_t value = 0;
-
-	/* Address does not automatically update if reading */
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
-		((band_idx * BAND_MAX + coeff_idx)
-		* sizeof(uint32_t)) & 0x7F);
-
-	value |= snd_soc_read(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx));
-
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
-		((band_idx * BAND_MAX + coeff_idx)
-		* sizeof(uint32_t) + 1) & 0x7F);
-
-	value |= (snd_soc_read(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx)) << 8);
-
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
-		((band_idx * BAND_MAX + coeff_idx)
-		* sizeof(uint32_t) + 2) & 0x7F);
-
-	value |= (snd_soc_read(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx)) << 16);
-
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
-		((band_idx * BAND_MAX + coeff_idx)
-		* sizeof(uint32_t) + 3) & 0x7F);
-
-	/* Mask bits top 2 bits since they are reserved */
-	value |= ((snd_soc_read(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx)) & 0x3F) << 24);
-
-	return value;
-}
-
-static int taiko_get_iir_band_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-
-	ucontrol->value.integer.value[0] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 0);
-	ucontrol->value.integer.value[1] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 1);
-	ucontrol->value.integer.value[2] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 2);
-	ucontrol->value.integer.value[3] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 3);
-	ucontrol->value.integer.value[4] =
-		get_iir_band_coeff(codec, iir_idx, band_idx, 4);
-
-	pr_debug("%s: IIR #%d band #%d b0 = 0x%x\n"
-		"%s: IIR #%d band #%d b1 = 0x%x\n"
-		"%s: IIR #%d band #%d b2 = 0x%x\n"
-		"%s: IIR #%d band #%d a1 = 0x%x\n"
-		"%s: IIR #%d band #%d a2 = 0x%x\n",
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[0],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[1],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[2],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[3],
-		__func__, iir_idx, band_idx,
-		(uint32_t)ucontrol->value.integer.value[4]);
-	return 0;
-}
-
-static void set_iir_band_coeff(struct snd_soc_codec *codec,
-				int iir_idx, int band_idx,
-				uint32_t value)
-{
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx),
-		(value & 0xFF));
-
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx),
-		(value >> 8) & 0xFF);
-
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx),
-		(value >> 16) & 0xFF);
-
-	/* Mask top 2 bits, 7-8 are reserved */
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B2_CTL + 16 * iir_idx),
-		(value >> 24) & 0x3F);
-}
-
-static int taiko_put_iir_band_audio_mixer(
-					struct snd_kcontrol *kcontrol,
-					struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int iir_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->reg;
-	int band_idx = ((struct soc_multi_mixer_control *)
-					kcontrol->private_value)->shift;
-
-	/* Mask top bit it is reserved */
-	/* Updates addr automatically for each B2 write */
-	snd_soc_write(codec,
-		(TAIKO_A_CDC_IIR1_COEF_B1_CTL + 16 * iir_idx),
-		(band_idx * BAND_MAX * sizeof(uint32_t)) & 0x7F);
-
-	set_iir_band_coeff(codec, iir_idx, band_idx,
-				ucontrol->value.integer.value[0]);
-	set_iir_band_coeff(codec, iir_idx, band_idx,
-				ucontrol->value.integer.value[1]);
-	set_iir_band_coeff(codec, iir_idx, band_idx,
-				ucontrol->value.integer.value[2]);
-	set_iir_band_coeff(codec, iir_idx, band_idx,
-				ucontrol->value.integer.value[3]);
-	set_iir_band_coeff(codec, iir_idx, band_idx,
-				ucontrol->value.integer.value[4]);
-
-	pr_debug("%s: IIR #%d band #%d b0 = 0x%x\n"
-		"%s: IIR #%d band #%d b1 = 0x%x\n"
-		"%s: IIR #%d band #%d b2 = 0x%x\n"
-		"%s: IIR #%d band #%d a1 = 0x%x\n"
-		"%s: IIR #%d band #%d a2 = 0x%x\n",
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 0),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 1),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 2),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 3),
-		__func__, iir_idx, band_idx,
-		get_iir_band_coeff(codec, iir_idx, band_idx, 4));
-	return 0;
-}
-
-static int taiko_get_compander(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	int comp = ((struct soc_multi_mixer_control *)
-		    kcontrol->private_value)->shift;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	ucontrol->value.integer.value[0] = taiko->comp_enabled[comp];
-	return 0;
-}
-
-static int taiko_set_compander(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	int comp = ((struct soc_multi_mixer_control *)
-		    kcontrol->private_value)->shift;
-	int value = ucontrol->value.integer.value[0];
-
-	pr_debug("%s: Compander %d enable current %d, new %d\n",
-		 __func__, comp, taiko->comp_enabled[comp], value);
-	taiko->comp_enabled[comp] = value;
-
-	if (comp == COMPANDER_1 &&
-			taiko->comp_enabled[comp] == 1) {
-		/* Wavegen to 5 msec */
-		snd_soc_write(codec, TAIKO_A_RX_HPH_CNP_WG_CTL, 0xDA);
-		snd_soc_write(codec, TAIKO_A_RX_HPH_CNP_WG_TIME, 0x15);
-		snd_soc_write(codec, TAIKO_A_RX_HPH_BIAS_WG_OCP, 0x2A);
-
-		/* Enable Chopper */
-		snd_soc_update_bits(codec,
-			TAIKO_A_RX_HPH_CHOP_CTL, 0x80, 0x80);
-
-		snd_soc_write(codec, TAIKO_A_NCP_DTEST, 0x20);
-		pr_debug("%s: Enabled Chopper and set wavegen to 5 msec\n",
-				__func__);
-	} else if (comp == COMPANDER_1 &&
-			taiko->comp_enabled[comp] == 0) {
-		/* Wavegen to 20 msec */
-		snd_soc_write(codec, TAIKO_A_RX_HPH_CNP_WG_CTL, 0xDB);
-		snd_soc_write(codec, TAIKO_A_RX_HPH_CNP_WG_TIME, 0x58);
-		snd_soc_write(codec, TAIKO_A_RX_HPH_BIAS_WG_OCP, 0x1A);
-
-		/* Disable CHOPPER block */
-		snd_soc_update_bits(codec,
-			TAIKO_A_RX_HPH_CHOP_CTL, 0x80, 0x00);
-
-		snd_soc_write(codec, TAIKO_A_NCP_DTEST, 0x10);
-		pr_debug("%s: Disabled Chopper and set wavegen to 20 msec\n",
-				__func__);
-	}
-	return 0;
-}
-
-static int taiko_config_gain_compander(struct snd_soc_codec *codec,
-				       int comp, bool enable)
-{
-	int ret = 0;
-
-	switch (comp) {
-	case COMPANDER_0:
-		snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_GAIN,
-				    1 << 2, !enable << 2);
-		break;
-	case COMPANDER_1:
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_L_GAIN,
-				    1 << 5, !enable << 5);
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_R_GAIN,
-				    1 << 5, !enable << 5);
-		break;
-	case COMPANDER_2:
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_1_GAIN,
-				    1 << 5, !enable << 5);
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_3_GAIN,
-				    1 << 5, !enable << 5);
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_2_GAIN,
-				    1 << 5, !enable << 5);
-		snd_soc_update_bits(codec, TAIKO_A_RX_LINE_4_GAIN,
-				    1 << 5, !enable << 5);
-		break;
-	default:
-		WARN_ON(1);
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static void taiko_discharge_comp(struct snd_soc_codec *codec, int comp)
-{
-	/* Level meter DIV Factor to 5*/
-	snd_soc_update_bits(codec, TAIKO_A_CDC_COMP0_B2_CTL + (comp * 8), 0xF0,
-			    0x05 << 4);
-	/* RMS meter Sampling to 0x01 */
-	snd_soc_write(codec, TAIKO_A_CDC_COMP0_B3_CTL + (comp * 8), 0x01);
-
-	/* Worst case timeout for compander CnP sleep timeout */
-	usleep_range(3000, 3000);
-}
-
-static enum wcd9xxx_buck_volt taiko_codec_get_buck_mv(
-	struct snd_soc_codec *codec)
-{
-	int buck_volt = WCD9XXX_CDC_BUCK_UNSUPPORTED;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	struct wcd9xxx_pdata *pdata = taiko->resmgr.pdata;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(pdata->regulator); i++) {
-		if (!strncmp(pdata->regulator[i].name,
-					 WCD9XXX_SUPPLY_BUCK_NAME,
-					 sizeof(WCD9XXX_SUPPLY_BUCK_NAME))) {
-			if ((pdata->regulator[i].min_uV ==
-					WCD9XXX_CDC_BUCK_MV_1P8) ||
-				(pdata->regulator[i].min_uV ==
-					WCD9XXX_CDC_BUCK_MV_2P15))
-				buck_volt = pdata->regulator[i].min_uV;
-			break;
-		}
-	}
-	return buck_volt;
-}
-
-static int taiko_config_compander(struct snd_soc_dapm_widget *w,
-				  struct snd_kcontrol *kcontrol, int event)
-{
-	int mask, enable_mask;
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const int comp = w->shift;
-	const u32 rate = taiko->comp_fs[comp];
-	const struct comp_sample_dependent_params *comp_params =
-	    &comp_samp_params[rate];
-	enum wcd9xxx_buck_volt buck_mv;
-
-	pr_debug("%s: %s event %d compander %d, enabled %d", __func__,
-		 w->name, event, comp, taiko->comp_enabled[comp]);
-
-	if (!taiko->comp_enabled[comp])
-		return 0;
-
-	/* Compander 0 has single channel */
-	mask = (comp == COMPANDER_0 ? 0x01 : 0x03);
-	enable_mask = (comp == COMPANDER_0 ? 0x02 : 0x03);
-	buck_mv = taiko_codec_get_buck_mv(codec);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		/* Set compander Sample rate */
-		snd_soc_update_bits(codec,
-				    TAIKO_A_CDC_COMP0_FS_CFG + (comp * 8),
-				    0x07, rate);
-		/* Set the static gain offset */
-		if (comp == COMPANDER_1
-			&& buck_mv == WCD9XXX_CDC_BUCK_MV_1P8) {
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_COMP0_B4_CTL + (comp * 8),
-					0x80, 0x80);
-		} else {
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_COMP0_B4_CTL + (comp * 8),
-					0x80, 0x00);
-		}
-		/* Enable RX interpolation path compander clocks */
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_B2_CTL,
-				    mask << comp_shift[comp],
-				    mask << comp_shift[comp]);
-		/* Toggle compander reset bits */
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_OTHR_RESET_B2_CTL,
-				    mask << comp_shift[comp],
-				    mask << comp_shift[comp]);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_OTHR_RESET_B2_CTL,
-				    mask << comp_shift[comp], 0);
-
-		/* Set gain source to compander */
-		taiko_config_gain_compander(codec, comp, true);
-
-		/* Compander enable */
-		snd_soc_update_bits(codec, TAIKO_A_CDC_COMP0_B1_CTL +
-				    (comp * 8), enable_mask, enable_mask);
-
-		taiko_discharge_comp(codec, comp);
-
-		/* Set sample rate dependent paramater */
-		snd_soc_write(codec, TAIKO_A_CDC_COMP0_B3_CTL + (comp * 8),
-			      comp_params->rms_meter_resamp_fact);
-		snd_soc_update_bits(codec,
-				    TAIKO_A_CDC_COMP0_B2_CTL + (comp * 8),
-				    0xF0, comp_params->rms_meter_div_fact << 4);
-		snd_soc_update_bits(codec,
-					TAIKO_A_CDC_COMP0_B2_CTL + (comp * 8),
-					0x0F, comp_params->peak_det_timeout);
-		break;
-	case SND_SOC_DAPM_PRE_PMD:
-		/* Disable compander */
-		snd_soc_update_bits(codec,
-				    TAIKO_A_CDC_COMP0_B1_CTL + (comp * 8),
-				    enable_mask, 0x00);
-
-		/* Toggle compander reset bits */
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_OTHR_RESET_B2_CTL,
-				    mask << comp_shift[comp],
-				    mask << comp_shift[comp]);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_OTHR_RESET_B2_CTL,
-				    mask << comp_shift[comp], 0);
-
-		/* Turn off the clock for compander in pair */
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_B2_CTL,
-				    mask << comp_shift[comp], 0);
-
-		/* Set gain source to register */
-		taiko_config_gain_compander(codec, comp, false);
-		break;
-	}
-	return 0;
-}
-
-
-
-static const char *const taiko_anc_func_text[] = {"OFF", "ON"};
-static const struct soc_enum taiko_anc_func_enum =
-		SOC_ENUM_SINGLE_EXT(2, taiko_anc_func_text);
-
-#if defined(CONFIG_SEC_JACTIVE_PROJECT)
-static const char *const taiko_sub_mic_delay_text[] = {"OFF", "ON"};
-static const struct soc_enum taiko_sub_mic_delay_enum =
-		SOC_ENUM_SINGLE_EXT(2, taiko_sub_mic_delay_text);
-#endif
-
-static const char *const tabla_ear_pa_gain_text[] = {"POS_6_DB", "POS_2_DB"};
-static const struct soc_enum tabla_ear_pa_gain_enum[] = {
-		SOC_ENUM_SINGLE_EXT(2, tabla_ear_pa_gain_text),
-};
-
-/*cut of frequency for high pass filter*/
-static const char * const cf_text[] = {
-	"MIN_3DB_4Hz", "MIN_3DB_75Hz", "MIN_3DB_150Hz"
-};
-
-static const struct soc_enum cf_dec1_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX1_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec2_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX2_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec3_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX3_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec4_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX4_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec5_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX5_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec6_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX6_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec7_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX7_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec8_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX8_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec9_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX9_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_dec10_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_TX10_MUX_CTL, 4, 3, cf_text);
-
-static const struct soc_enum cf_rxmix1_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX1_B4_CTL, 0, 3, cf_text);
-
-static const struct soc_enum cf_rxmix2_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX2_B4_CTL, 0, 3, cf_text);
-
-static const struct soc_enum cf_rxmix3_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX3_B4_CTL, 0, 3, cf_text);
-
-static const struct soc_enum cf_rxmix4_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX4_B4_CTL, 0, 3, cf_text);
-
-static const struct soc_enum cf_rxmix5_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX5_B4_CTL, 0, 3, cf_text)
-;
-static const struct soc_enum cf_rxmix6_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX6_B4_CTL, 0, 3, cf_text);
-
-static const struct soc_enum cf_rxmix7_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_RX7_B4_CTL, 0, 3, cf_text);
-
-static const char * const class_h_dsm_text[] = {
-	"ZERO", "DSM_HPHL_RX1", "DSM_SPKR_RX7"
-};
-
-static const struct soc_enum class_h_dsm_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_CLSH_CTL, 4, 3, class_h_dsm_text);
-
-static const struct snd_kcontrol_new class_h_dsm_mux =
-	SOC_DAPM_ENUM("CLASS_H_DSM MUX Mux", class_h_dsm_enum);
-
-static const char *const taiko_conn_mad_text[] = {
-	"ADC_MB", "ADC1", "ADC2", "ADC3", "ADC4", "ADC5", "ADC6", "NOTUSED1",
-	"DMIC1", "DMIC2", "DMIC3", "DMIC4", "DMIC5", "DMIC6", "NOTUSED2",
-	"NOTUSED3"};
-
-static const struct soc_enum taiko_conn_mad_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(taiko_conn_mad_text),
-			taiko_conn_mad_text);
-
-
-static int taiko_mad_input_get(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	u8 taiko_mad_input;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-
-	taiko_mad_input = snd_soc_read(codec, TAIKO_A_CDC_CONN_MAD);
-
-	taiko_mad_input = taiko_mad_input & 0x0F;
-
-	ucontrol->value.integer.value[0] = taiko_mad_input;
-
-	pr_debug("%s: taiko_mad_input = %s\n", __func__,
-			taiko_conn_mad_text[taiko_mad_input]);
-
-	return 0;
-}
-
-static int taiko_mad_input_put(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	u8 taiko_mad_input;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_card *card = codec->card;
-	char mad_amic_input_widget[6];
-	u32 adc;
-	const char *mad_input_widget;
-	u32  mic_bias_found = 0;
-	u32 i;
-	int ret = 0;
-
-	taiko_mad_input = ucontrol->value.integer.value[0];
-
-	if (taiko_mad_input >= ARRAY_SIZE(taiko_conn_mad_text)) {
-		dev_err(codec->dev,
-			"%s: taiko_mad_input = %d out of bounds\n",
-			__func__, taiko_mad_input);
-		return -EINVAL;
-	}
-
-	pr_debug("%s: taiko_mad_input = %s\n", __func__,
-			taiko_conn_mad_text[taiko_mad_input]);
-
-	if (!strcmp(taiko_conn_mad_text[taiko_mad_input], "NOTUSED1") ||
-		!strcmp(taiko_conn_mad_text[taiko_mad_input], "NOTUSED2") ||
-		!strcmp(taiko_conn_mad_text[taiko_mad_input], "NOTUSED3") ||
-		!strcmp(taiko_conn_mad_text[taiko_mad_input], "ADC_MB")) {
-		pr_info("%s: taiko mad input is set to unsupported input = %s\n",
-				__func__, taiko_conn_mad_text[taiko_mad_input]);
-		return -EINVAL;
-	}
-
-	if (strnstr(taiko_conn_mad_text[taiko_mad_input],
-				"ADC", sizeof("ADC"))) {
-		ret = kstrtouint(strpbrk(taiko_conn_mad_text[taiko_mad_input]
-					, "123456"), 10, &adc);
-		if ((ret < 0) || (adc > 6)) {
-			pr_err("%s: Invalid ADC = %s\n", __func__,
-				taiko_conn_mad_text[taiko_mad_input]);
-			ret =  -EINVAL;
-		}
-
-		snprintf(mad_amic_input_widget, 6, "%s%u", "AMIC", adc);
-
-		mad_input_widget = mad_amic_input_widget;
-		pr_debug("%s: taiko amic input widget = %s\n", __func__,
-			  mad_amic_input_widget);
-	} else {
-		/* DMIC type input widget*/
-		mad_input_widget = taiko_conn_mad_text[taiko_mad_input];
-	}
-
-	pr_debug("%s: taiko input widget = %s\n", __func__, mad_input_widget);
-
-	for (i = 0; i < card->num_dapm_routes; i++) {
-
-		if (!strncmp(card->dapm_routes[i].sink,
-				mad_input_widget, strlen(mad_input_widget))) {
-
-			if (strnstr(card->dapm_routes[i].source,
-				"MIC BIAS1", sizeof("MIC BIAS1"))) {
-				mic_bias_found = 1;
-				break;
-			} else if (strnstr(card->dapm_routes[i].source,
-				"MIC BIAS2", sizeof("MIC BIAS2"))) {
-				mic_bias_found = 2;
-				break;
-			} else if (strnstr(card->dapm_routes[i].source,
-				"MIC BIAS3", sizeof("MIC BIAS3"))) {
-				mic_bias_found = 3;
-				break;
-			} else if (strnstr(card->dapm_routes[i].source,
-				"MIC BIAS4", sizeof("MIC BIAS4"))) {
-				mic_bias_found = 4;
-				break;
-			}
-		}
-	}
-
-	if (mic_bias_found) {
-		pr_debug("%s: source mic bias = %s. sink = %s\n", __func__,
-				card->dapm_routes[i].source,
-				card->dapm_routes[i].sink);
-
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CONN_MAD,
-					0x0F, taiko_mad_input);
-		snd_soc_update_bits(codec, TAIKO_A_MAD_ANA_CTRL,
-					0x07, mic_bias_found);
-		return 0;
-	} else {
-		pr_err("%s: mic bias source not found for input = %s\n",
-				__func__, mad_input_widget);
-		return -EINVAL;
-	}
-}
-
-
-static const struct snd_kcontrol_new taiko_snd_controls[] = {
-
-	SOC_SINGLE_S8_TLV("RX1 Digital Volume", TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX2 Digital Volume", TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX3 Digital Volume", TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX4 Digital Volume", TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX5 Digital Volume", TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX6 Digital Volume", TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-	SOC_SINGLE_S8_TLV("RX7 Digital Volume", TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL,
-		-84, 40, digital_gain),
-
-	SOC_SINGLE_S8_TLV("DEC1 Volume", TAIKO_A_CDC_TX1_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC2 Volume", TAIKO_A_CDC_TX2_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC3 Volume", TAIKO_A_CDC_TX3_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC4 Volume", TAIKO_A_CDC_TX4_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC5 Volume", TAIKO_A_CDC_TX5_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC6 Volume", TAIKO_A_CDC_TX6_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC7 Volume", TAIKO_A_CDC_TX7_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC8 Volume", TAIKO_A_CDC_TX8_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC9 Volume", TAIKO_A_CDC_TX9_VOL_CTL_GAIN, -84, 40,
-		digital_gain),
-	SOC_SINGLE_S8_TLV("DEC10 Volume", TAIKO_A_CDC_TX10_VOL_CTL_GAIN, -84,
-		40, digital_gain),
-
-	SOC_SINGLE_S8_TLV("IIR1 INP1 Volume", TAIKO_A_CDC_IIR1_GAIN_B1_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR1 INP2 Volume", TAIKO_A_CDC_IIR1_GAIN_B2_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR1 INP3 Volume", TAIKO_A_CDC_IIR1_GAIN_B3_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR1 INP4 Volume", TAIKO_A_CDC_IIR1_GAIN_B4_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR2 INP1 Volume", TAIKO_A_CDC_IIR2_GAIN_B1_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR2 INP2 Volume", TAIKO_A_CDC_IIR2_GAIN_B2_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR2 INP3 Volume", TAIKO_A_CDC_IIR2_GAIN_B3_CTL, -84,
-		40, digital_gain),
-	SOC_SINGLE_S8_TLV("IIR2 INP4 Volume", TAIKO_A_CDC_IIR2_GAIN_B4_CTL, -84,
-		40, digital_gain),
-
-	SOC_SINGLE_EXT("ANC Slot", SND_SOC_NOPM, 0, 100, 0, taiko_get_anc_slot,
-		taiko_put_anc_slot),
-	SOC_ENUM_EXT("ANC Function", taiko_anc_func_enum, taiko_get_anc_func,
-		taiko_put_anc_func),
-#if defined(CONFIG_SEC_JACTIVE_PROJECT)
-        SOC_ENUM_EXT("SUB_MIC_REC_DELAY", taiko_sub_mic_delay_enum, taiko_get_sub_mic_delay_set,
-            taiko_put_sub_mic_delay_set),
-#endif
-
-	SOC_ENUM("TX1 HPF cut off", cf_dec1_enum),
-	SOC_ENUM("TX2 HPF cut off", cf_dec2_enum),
-	SOC_ENUM("TX3 HPF cut off", cf_dec3_enum),
-	SOC_ENUM("TX4 HPF cut off", cf_dec4_enum),
-	SOC_ENUM("TX5 HPF cut off", cf_dec5_enum),
-	SOC_ENUM("TX6 HPF cut off", cf_dec6_enum),
-	SOC_ENUM("TX7 HPF cut off", cf_dec7_enum),
-	SOC_ENUM("TX8 HPF cut off", cf_dec8_enum),
-	SOC_ENUM("TX9 HPF cut off", cf_dec9_enum),
-	SOC_ENUM("TX10 HPF cut off", cf_dec10_enum),
-
-	SOC_SINGLE("TX1 HPF Switch", TAIKO_A_CDC_TX1_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX2 HPF Switch", TAIKO_A_CDC_TX2_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX3 HPF Switch", TAIKO_A_CDC_TX3_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX4 HPF Switch", TAIKO_A_CDC_TX4_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX5 HPF Switch", TAIKO_A_CDC_TX5_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX6 HPF Switch", TAIKO_A_CDC_TX6_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX7 HPF Switch", TAIKO_A_CDC_TX7_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX8 HPF Switch", TAIKO_A_CDC_TX8_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX9 HPF Switch", TAIKO_A_CDC_TX9_MUX_CTL, 3, 1, 0),
-	SOC_SINGLE("TX10 HPF Switch", TAIKO_A_CDC_TX10_MUX_CTL, 3, 1, 0),
-
-	SOC_SINGLE("RX1 HPF Switch", TAIKO_A_CDC_RX1_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX2 HPF Switch", TAIKO_A_CDC_RX2_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX3 HPF Switch", TAIKO_A_CDC_RX3_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX4 HPF Switch", TAIKO_A_CDC_RX4_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX5 HPF Switch", TAIKO_A_CDC_RX5_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX6 HPF Switch", TAIKO_A_CDC_RX6_B5_CTL, 2, 1, 0),
-	SOC_SINGLE("RX7 HPF Switch", TAIKO_A_CDC_RX7_B5_CTL, 2, 1, 0),
-
-	SOC_ENUM("RX1 HPF cut off", cf_rxmix1_enum),
-	SOC_ENUM("RX2 HPF cut off", cf_rxmix2_enum),
-	SOC_ENUM("RX3 HPF cut off", cf_rxmix3_enum),
-	SOC_ENUM("RX4 HPF cut off", cf_rxmix4_enum),
-	SOC_ENUM("RX5 HPF cut off", cf_rxmix5_enum),
-	SOC_ENUM("RX6 HPF cut off", cf_rxmix6_enum),
-	SOC_ENUM("RX7 HPF cut off", cf_rxmix7_enum),
-
-	SOC_SINGLE_EXT("IIR1 Enable Band1", IIR1, BAND1, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band2", IIR1, BAND2, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band3", IIR1, BAND3, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band4", IIR1, BAND4, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR1 Enable Band5", IIR1, BAND5, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band1", IIR2, BAND1, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band2", IIR2, BAND2, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band3", IIR2, BAND3, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band4", IIR2, BAND4, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-	SOC_SINGLE_EXT("IIR2 Enable Band5", IIR2, BAND5, 1, 0,
-	taiko_get_iir_enable_audio_mixer, taiko_put_iir_enable_audio_mixer),
-
-	SOC_SINGLE_MULTI_EXT("IIR1 Band1", IIR1, BAND1, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band2", IIR1, BAND2, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band3", IIR1, BAND3, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band4", IIR1, BAND4, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR1 Band5", IIR1, BAND5, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band1", IIR2, BAND1, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band2", IIR2, BAND2, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band3", IIR2, BAND3, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band4", IIR2, BAND4, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-	SOC_SINGLE_MULTI_EXT("IIR2 Band5", IIR2, BAND5, 255, 0, 5,
-	taiko_get_iir_band_audio_mixer, taiko_put_iir_band_audio_mixer),
-
-	SOC_SINGLE_EXT("COMP0 Switch", SND_SOC_NOPM, COMPANDER_0, 1, 0,
-		       taiko_get_compander, taiko_set_compander),
-	SOC_SINGLE_EXT("COMP1 Switch", SND_SOC_NOPM, COMPANDER_1, 1, 0,
-		       taiko_get_compander, taiko_set_compander),
-	SOC_SINGLE_EXT("COMP2 Switch", SND_SOC_NOPM, COMPANDER_2, 1, 0,
-		       taiko_get_compander, taiko_set_compander),
-
-	SOC_ENUM_EXT("MAD Input", taiko_conn_mad_enum,
-			taiko_mad_input_get, taiko_mad_input_put),
-
-};
-
-static int taiko_pa_gain_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	u8 ear_pa_gain;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-
-	ear_pa_gain = snd_soc_read(codec, TAIKO_A_RX_EAR_GAIN);
-
-	ear_pa_gain = ear_pa_gain >> 5;
-
-	ucontrol->value.integer.value[0] = ear_pa_gain;
-
-	pr_debug("%s: ear_pa_gain = 0x%x\n", __func__, ear_pa_gain);
-
-	return 0;
-}
-
-static int taiko_pa_gain_put(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	u8 ear_pa_gain;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-
-	pr_debug("%s: ucontrol->value.integer.value[0]  = %ld\n", __func__,
-			ucontrol->value.integer.value[0]);
-
-	ear_pa_gain =  ucontrol->value.integer.value[0] << 5;
-
-	snd_soc_update_bits(codec, TAIKO_A_RX_EAR_GAIN, 0xE0, ear_pa_gain);
-	return 0;
-}
-
-static const char * const taiko_1_x_ear_pa_gain_text[] = {
-	"POS_6_DB", "UNDEFINED_1", "UNDEFINED_2", "UNDEFINED_3", "POS_2_DB",
-	"NEG_2P5_DB", "UNDEFINED_4", "NEG_12_DB"
-};
-
-static const struct soc_enum taiko_1_x_ear_pa_gain_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(taiko_1_x_ear_pa_gain_text),
-			taiko_1_x_ear_pa_gain_text);
-
-static const struct snd_kcontrol_new taiko_1_x_analog_gain_controls[] = {
-
-	SOC_ENUM_EXT("EAR PA Gain", taiko_1_x_ear_pa_gain_enum,
-		taiko_pa_gain_get, taiko_pa_gain_put),
-
-	SOC_SINGLE_TLV("HPHL Volume", TAIKO_A_RX_HPH_L_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("HPHR Volume", TAIKO_A_RX_HPH_R_GAIN, 0, 20, 1,
-		line_gain),
-
-	SOC_SINGLE_TLV("LINEOUT1 Volume", TAIKO_A_RX_LINE_1_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT2 Volume", TAIKO_A_RX_LINE_2_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT3 Volume", TAIKO_A_RX_LINE_3_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT4 Volume", TAIKO_A_RX_LINE_4_GAIN, 0, 20, 1,
-		line_gain),
-
-	SOC_SINGLE_TLV("SPK DRV Volume", TAIKO_A_SPKR_DRV_GAIN, 3, 7, 1,
-		line_gain),
-
-	SOC_SINGLE_TLV("ADC1 Volume", TAIKO_A_TX_1_2_EN, 5, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC2 Volume", TAIKO_A_TX_1_2_EN, 1, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC3 Volume", TAIKO_A_TX_3_4_EN, 5, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC4 Volume", TAIKO_A_TX_3_4_EN, 1, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC5 Volume", TAIKO_A_TX_5_6_EN, 5, 3, 0, analog_gain),
-	SOC_SINGLE_TLV("ADC6 Volume", TAIKO_A_TX_5_6_EN, 1, 3, 0, analog_gain),
-};
-
-static const char * const taiko_2_x_ear_pa_gain_text[] = {
-	"POS_6_DB", "POS_4P5_DB", "POS_3_DB", "POS_1P5_DB",
-	"POS_0_DB", "NEG_2P5_DB", "UNDEFINED", "NEG_12_DB"
-};
-
-static const struct soc_enum taiko_2_x_ear_pa_gain_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(taiko_2_x_ear_pa_gain_text),
-			taiko_2_x_ear_pa_gain_text);
-
-static const struct snd_kcontrol_new taiko_2_x_analog_gain_controls[] = {
-
-	SOC_ENUM_EXT("EAR PA Gain", taiko_2_x_ear_pa_gain_enum,
-		taiko_pa_gain_get, taiko_pa_gain_put),
-
-	SOC_SINGLE_TLV("HPHL Volume", TAIKO_A_RX_HPH_L_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("HPHR Volume", TAIKO_A_RX_HPH_R_GAIN, 0, 20, 1,
-		line_gain),
-
-	SOC_SINGLE_TLV("LINEOUT1 Volume", TAIKO_A_RX_LINE_1_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT2 Volume", TAIKO_A_RX_LINE_2_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT3 Volume", TAIKO_A_RX_LINE_3_GAIN, 0, 20, 1,
-		line_gain),
-	SOC_SINGLE_TLV("LINEOUT4 Volume", TAIKO_A_RX_LINE_4_GAIN, 0, 20, 1,
-		line_gain),
-
-	SOC_SINGLE_TLV("SPK DRV Volume", TAIKO_A_SPKR_DRV_GAIN, 3, 8, 1,
-		line_gain),
-
-	SOC_SINGLE_TLV("ADC1 Volume", TAIKO_A_CDC_TX_1_GAIN, 2, 19, 0,
-			analog_gain),
-	SOC_SINGLE_TLV("ADC2 Volume", TAIKO_A_CDC_TX_2_GAIN, 2, 19, 0,
-			analog_gain),
-	SOC_SINGLE_TLV("ADC3 Volume", TAIKO_A_CDC_TX_3_GAIN, 2, 19, 0,
-			analog_gain),
-	SOC_SINGLE_TLV("ADC4 Volume", TAIKO_A_CDC_TX_4_GAIN, 2, 19, 0,
-			analog_gain),
-	SOC_SINGLE_TLV("ADC5 Volume", TAIKO_A_CDC_TX_5_GAIN, 2, 19, 0,
-			analog_gain),
-	SOC_SINGLE_TLV("ADC6 Volume", TAIKO_A_CDC_TX_6_GAIN, 2, 19, 0,
-			analog_gain),
-};
-
-#if defined(CONFIG_MACH_KLTE_JPN) || defined(CONFIG_MACH_KLTE_KOR)
-extern unsigned int system_rev;
-#endif
-
-static int taiko_hph_impedance_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
-{
-#if defined(CONFIG_MACH_KLTE_KOR)
-	if (system_rev >= 13) {
-		uint32_t zl, zr;
-		bool hphr;
-		struct soc_multi_mixer_control *mc;
-		struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-		struct taiko_priv *priv = snd_soc_codec_get_drvdata(codec);
-
-		mc = (struct soc_multi_mixer_control *)(kcontrol->private_value);
-
-		hphr = mc->shift;
-		wcd9xxx_mbhc_get_impedance(&priv->mbhc, &zl, &zr);
-		pr_debug("%s: zl %u, zr %u\n", __func__, zl, zr);
-		ucontrol->value.integer.value[0] = hphr ? zr : zl;
-	}
-#elif defined(CONFIG_MACH_KLTE_JPN)
-	if (system_rev >= 11) {
-		uint32_t zl, zr;
-		bool hphr;
-		struct soc_multi_mixer_control *mc;
-		struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-		struct taiko_priv *priv = snd_soc_codec_get_drvdata(codec);
-
-		mc = (struct soc_multi_mixer_control *)(kcontrol->private_value);
-
-		hphr = mc->shift;
-		wcd9xxx_mbhc_get_impedance(&priv->mbhc, &zl, &zr);
-		pr_debug("%s: zl %u, zr %u\n", __func__, zl, zr);
-		ucontrol->value.integer.value[0] = hphr ? zr : zl;
-	}
-#else
-#if !defined(CONFIG_SAMSUNG_JACK) && !defined(CONFIG_MUIC_DET_JACK)
-	uint32_t zl, zr;
-	bool hphr;
-	struct soc_multi_mixer_control *mc;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct taiko_priv *priv = snd_soc_codec_get_drvdata(codec);
-
-	mc = (struct soc_multi_mixer_control *)(kcontrol->private_value);
-
-	hphr = mc->shift;
-	wcd9xxx_mbhc_get_impedance(&priv->mbhc, &zl, &zr);
-	pr_debug("%s: zl %u, zr %u\n", __func__, zl, zr);
-	ucontrol->value.integer.value[0] = hphr ? zr : zl;
-#endif
-#endif
-	ucontrol->value.integer.value[0] = 0;
-	return 0;
-}
-
-static const struct snd_kcontrol_new impedance_detect_controls[] = {
-	SOC_SINGLE_EXT("HPHL Impedance", 0, 0, UINT_MAX, 0,
-		       taiko_hph_impedance_get, NULL),
-	SOC_SINGLE_EXT("HPHR Impedance", 0, 1, UINT_MAX, 0,
-		       taiko_hph_impedance_get, NULL),
-};
-
-static const char * const rx_mix1_text[] = {
-	"ZERO", "SRC1", "SRC2", "IIR1", "IIR2", "RX1", "RX2", "RX3", "RX4",
-		"RX5", "RX6", "RX7"
-};
-
-static const char * const rx_mix2_text[] = {
-	"ZERO", "SRC1", "SRC2", "IIR1", "IIR2"
-};
-
-static const char * const rx_rdac5_text[] = {
-	"DEM4", "DEM3_INV"
-};
-
-static const char * const rx_rdac7_text[] = {
-	"DEM6", "DEM5_INV"
-};
-
-
-static const char * const sb_tx1_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC1"
-};
-
-static const char * const sb_tx2_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC2"
-};
-
-static const char * const sb_tx3_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC3"
-};
-
-static const char * const sb_tx4_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC4"
-};
-
-static const char * const sb_tx5_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC5"
-};
-
-static const char * const sb_tx6_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC6"
-};
-
-static const char * const sb_tx7_to_tx10_mux_text[] = {
-	"ZERO", "RMIX1", "RMIX2", "RMIX3", "RMIX4", "RMIX5", "RMIX6", "RMIX7",
-		"DEC1", "DEC2", "DEC3", "DEC4", "DEC5", "DEC6", "DEC7", "DEC8",
-		"DEC9", "DEC10"
-};
-
-static const char * const dec1_mux_text[] = {
-	"ZERO", "DMIC1", "ADC6",
-};
-
-static const char * const dec2_mux_text[] = {
-	"ZERO", "DMIC2", "ADC5",
-};
-
-static const char * const dec3_mux_text[] = {
-	"ZERO", "DMIC3", "ADC4",
-};
-
-static const char * const dec4_mux_text[] = {
-	"ZERO", "DMIC4", "ADC3",
-};
-
-static const char * const dec5_mux_text[] = {
-	"ZERO", "DMIC5", "ADC2",
-};
-
-static const char * const dec6_mux_text[] = {
-	"ZERO", "DMIC6", "ADC1",
-};
-
-static const char * const dec7_mux_text[] = {
-	"ZERO", "DMIC1", "DMIC6", "ADC1", "ADC6", "ANC1_FB", "ANC2_FB",
-};
-
-static const char * const dec8_mux_text[] = {
-	"ZERO", "DMIC2", "DMIC5", "ADC2", "ADC5",
-};
-
-static const char * const dec9_mux_text[] = {
-	"ZERO", "DMIC4", "DMIC5", "ADC2", "ADC3", "ADCMB", "ANC1_FB", "ANC2_FB",
-};
-
-static const char * const dec10_mux_text[] = {
-	"ZERO", "DMIC3", "DMIC6", "ADC1", "ADC4", "ADCMB", "ANC1_FB", "ANC2_FB",
-};
-
-static const char * const anc_mux_text[] = {
-	"ZERO", "ADC1", "ADC2", "ADC3", "ADC4", "ADC5", "ADC6", "ADC_MB",
-		"RSVD_1", "DMIC1", "DMIC2", "DMIC3", "DMIC4", "DMIC5", "DMIC6"
-};
-
-static const char * const anc1_fb_mux_text[] = {
-	"ZERO", "EAR_HPH_L", "EAR_LINE_1",
-};
-
-static const char * const iir_inp1_text[] = {
-	"ZERO", "DEC1", "DEC2", "DEC3", "DEC4", "DEC5", "DEC6", "DEC7", "DEC8",
-	"DEC9", "DEC10", "RX1", "RX2", "RX3", "RX4", "RX5", "RX6", "RX7"
-};
-
-static const struct soc_enum rx_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx_mix1_inp3_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B2_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx2_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx2_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx3_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX3_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx3_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX3_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx4_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX4_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx4_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX4_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx5_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX5_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx5_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX5_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx6_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX6_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx6_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX6_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx7_mix1_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B1_CTL, 0, 12, rx_mix1_text);
-
-static const struct soc_enum rx7_mix1_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B1_CTL, 4, 12, rx_mix1_text);
-
-static const struct soc_enum rx1_mix2_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B3_CTL, 0, 5, rx_mix2_text);
-
-static const struct soc_enum rx1_mix2_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX1_B3_CTL, 3, 5, rx_mix2_text);
-
-static const struct soc_enum rx2_mix2_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B3_CTL, 0, 5, rx_mix2_text);
-
-static const struct soc_enum rx2_mix2_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX2_B3_CTL, 3, 5, rx_mix2_text);
-
-static const struct soc_enum rx7_mix2_inp1_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B3_CTL, 0, 5, rx_mix2_text);
-
-static const struct soc_enum rx7_mix2_inp2_chain_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_RX7_B3_CTL, 3, 5, rx_mix2_text);
-
-static const struct soc_enum rx_rdac5_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_MISC, 2, 2, rx_rdac5_text);
-
-static const struct soc_enum rx_rdac7_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_MISC, 1, 2, rx_rdac7_text);
-
-static const struct soc_enum sb_tx1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B1_CTL, 0, 9, sb_tx1_mux_text);
-
-static const struct soc_enum sb_tx2_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B2_CTL, 0, 9, sb_tx2_mux_text);
-
-static const struct soc_enum sb_tx3_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B3_CTL, 0, 9, sb_tx3_mux_text);
-
-static const struct soc_enum sb_tx4_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B4_CTL, 0, 9, sb_tx4_mux_text);
-
-static const struct soc_enum sb_tx5_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B5_CTL, 0, 9, sb_tx5_mux_text);
-
-static const struct soc_enum sb_tx6_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B6_CTL, 0, 9, sb_tx6_mux_text);
-
-static const struct soc_enum sb_tx7_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B7_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum sb_tx8_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B8_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum sb_tx9_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B9_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum sb_tx10_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_SB_B10_CTL, 0, 18,
-			sb_tx7_to_tx10_mux_text);
-
-static const struct soc_enum dec1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 0, 3, dec1_mux_text);
-
-static const struct soc_enum dec2_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 2, 3, dec2_mux_text);
-
-static const struct soc_enum dec3_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 4, 3, dec3_mux_text);
-
-static const struct soc_enum dec4_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B1_CTL, 6, 3, dec4_mux_text);
-
-static const struct soc_enum dec5_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B2_CTL, 0, 3, dec5_mux_text);
-
-static const struct soc_enum dec6_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B2_CTL, 2, 3, dec6_mux_text);
-
-static const struct soc_enum dec7_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B2_CTL, 4, 7, dec7_mux_text);
-
-static const struct soc_enum dec8_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B3_CTL, 0, 7, dec8_mux_text);
-
-static const struct soc_enum dec9_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B3_CTL, 3, 8, dec9_mux_text);
-
-static const struct soc_enum dec10_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_TX_B4_CTL, 0, 8, dec10_mux_text);
-
-static const struct soc_enum anc1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_ANC_B1_CTL, 0, 16, anc_mux_text);
-
-static const struct soc_enum anc2_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_ANC_B1_CTL, 4, 16, anc_mux_text);
-
-static const struct soc_enum anc1_fb_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_ANC_B2_CTL, 0, 3, anc1_fb_mux_text);
-
-static const struct soc_enum iir1_inp1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_EQ1_B1_CTL, 0, 18, iir_inp1_text);
-
-static const struct soc_enum iir2_inp1_mux_enum =
-	SOC_ENUM_SINGLE(TAIKO_A_CDC_CONN_EQ2_B1_CTL, 0, 18, iir_inp1_text);
-
-static const struct snd_kcontrol_new rx_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX1 MIX1 INP1 Mux", rx_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX1 MIX1 INP2 Mux", rx_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx_mix1_inp3_mux =
-	SOC_DAPM_ENUM("RX1 MIX1 INP3 Mux", rx_mix1_inp3_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX2 MIX1 INP1 Mux", rx2_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX2 MIX1 INP2 Mux", rx2_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx3_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX3 MIX1 INP1 Mux", rx3_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx3_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX3 MIX1 INP2 Mux", rx3_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx4_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX4 MIX1 INP1 Mux", rx4_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx4_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX4 MIX1 INP2 Mux", rx4_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx5_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX5 MIX1 INP1 Mux", rx5_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx5_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX5 MIX1 INP2 Mux", rx5_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx6_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX6 MIX1 INP1 Mux", rx6_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx6_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX6 MIX1 INP2 Mux", rx6_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix1_inp1_mux =
-	SOC_DAPM_ENUM("RX7 MIX1 INP1 Mux", rx7_mix1_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix1_inp2_mux =
-	SOC_DAPM_ENUM("RX7 MIX1 INP2 Mux", rx7_mix1_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx1_mix2_inp1_mux =
-	SOC_DAPM_ENUM("RX1 MIX2 INP1 Mux", rx1_mix2_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx1_mix2_inp2_mux =
-	SOC_DAPM_ENUM("RX1 MIX2 INP2 Mux", rx1_mix2_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix2_inp1_mux =
-	SOC_DAPM_ENUM("RX2 MIX2 INP1 Mux", rx2_mix2_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx2_mix2_inp2_mux =
-	SOC_DAPM_ENUM("RX2 MIX2 INP2 Mux", rx2_mix2_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix2_inp1_mux =
-	SOC_DAPM_ENUM("RX7 MIX2 INP1 Mux", rx7_mix2_inp1_chain_enum);
-
-static const struct snd_kcontrol_new rx7_mix2_inp2_mux =
-	SOC_DAPM_ENUM("RX7 MIX2 INP2 Mux", rx7_mix2_inp2_chain_enum);
-
-static const struct snd_kcontrol_new rx_dac5_mux =
-	SOC_DAPM_ENUM("RDAC5 MUX Mux", rx_rdac5_enum);
-
-static const struct snd_kcontrol_new rx_dac7_mux =
-	SOC_DAPM_ENUM("RDAC7 MUX Mux", rx_rdac7_enum);
-
-static const struct snd_kcontrol_new sb_tx1_mux =
-	SOC_DAPM_ENUM("SLIM TX1 MUX Mux", sb_tx1_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx2_mux =
-	SOC_DAPM_ENUM("SLIM TX2 MUX Mux", sb_tx2_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx3_mux =
-	SOC_DAPM_ENUM("SLIM TX3 MUX Mux", sb_tx3_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx4_mux =
-	SOC_DAPM_ENUM("SLIM TX4 MUX Mux", sb_tx4_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx5_mux =
-	SOC_DAPM_ENUM("SLIM TX5 MUX Mux", sb_tx5_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx6_mux =
-	SOC_DAPM_ENUM("SLIM TX6 MUX Mux", sb_tx6_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx7_mux =
-	SOC_DAPM_ENUM("SLIM TX7 MUX Mux", sb_tx7_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx8_mux =
-	SOC_DAPM_ENUM("SLIM TX8 MUX Mux", sb_tx8_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx9_mux =
-	SOC_DAPM_ENUM("SLIM TX9 MUX Mux", sb_tx9_mux_enum);
-
-static const struct snd_kcontrol_new sb_tx10_mux =
-	SOC_DAPM_ENUM("SLIM TX10 MUX Mux", sb_tx10_mux_enum);
-
-
-static int wcd9320_put_dec_enum(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_widget *w = wlist->widgets[0];
-	struct snd_soc_codec *codec = w->codec;
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int dec_mux, decimator;
-	char *dec_name = NULL;
-	char *widget_name = NULL;
-	char *temp;
-	u16 tx_mux_ctl_reg;
-	u8 adc_dmic_sel = 0x0;
-	int ret = 0;
-
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
-		return -EINVAL;
-
-	dec_mux = ucontrol->value.enumerated.item[0];
-
-	widget_name = kstrndup(w->name, 15, GFP_KERNEL);
-	if (!widget_name)
-		return -ENOMEM;
-	temp = widget_name;
-
-	dec_name = strsep(&widget_name, " ");
-	widget_name = temp;
-	if (!dec_name) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, w->name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	ret = kstrtouint(strpbrk(dec_name, "123456789"), 10, &decimator);
-	if (ret < 0) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	dev_dbg(w->dapm->dev, "%s(): widget = %s decimator = %u dec_mux = %u\n"
-		, __func__, w->name, decimator, dec_mux);
-
-
-	switch (decimator) {
-	case 1:
-	case 2:
-	case 3:
-	case 4:
-	case 5:
-	case 6:
-		if (dec_mux == 1)
-			adc_dmic_sel = 0x1;
-		else
-			adc_dmic_sel = 0x0;
-		break;
-	case 7:
-	case 8:
-	case 9:
-	case 10:
-		if ((dec_mux == 1) || (dec_mux == 2))
-			adc_dmic_sel = 0x1;
-		else
-			adc_dmic_sel = 0x0;
-		break;
-	default:
-		pr_err("%s: Invalid Decimator = %u\n", __func__, decimator);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	tx_mux_ctl_reg = TAIKO_A_CDC_TX1_MUX_CTL + 8 * (decimator - 1);
-
-	snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x1, adc_dmic_sel);
-
-	ret = snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
-
-out:
-	kfree(widget_name);
-	return ret;
-}
-
-#define WCD9320_DEC_ENUM(xname, xenum) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-	.info = snd_soc_info_enum_double, \
-	.get = snd_soc_dapm_get_enum_double, \
-	.put = wcd9320_put_dec_enum, \
-	.private_value = (unsigned long)&xenum }
-
-static const struct snd_kcontrol_new dec1_mux =
-	WCD9320_DEC_ENUM("DEC1 MUX Mux", dec1_mux_enum);
-
-static const struct snd_kcontrol_new dec2_mux =
-	WCD9320_DEC_ENUM("DEC2 MUX Mux", dec2_mux_enum);
-
-static const struct snd_kcontrol_new dec3_mux =
-	WCD9320_DEC_ENUM("DEC3 MUX Mux", dec3_mux_enum);
-
-static const struct snd_kcontrol_new dec4_mux =
-	WCD9320_DEC_ENUM("DEC4 MUX Mux", dec4_mux_enum);
-
-static const struct snd_kcontrol_new dec5_mux =
-	WCD9320_DEC_ENUM("DEC5 MUX Mux", dec5_mux_enum);
-
-static const struct snd_kcontrol_new dec6_mux =
-	WCD9320_DEC_ENUM("DEC6 MUX Mux", dec6_mux_enum);
-
-static const struct snd_kcontrol_new dec7_mux =
-	WCD9320_DEC_ENUM("DEC7 MUX Mux", dec7_mux_enum);
-
-static const struct snd_kcontrol_new dec8_mux =
-	WCD9320_DEC_ENUM("DEC8 MUX Mux", dec8_mux_enum);
-
-static const struct snd_kcontrol_new dec9_mux =
-	WCD9320_DEC_ENUM("DEC9 MUX Mux", dec9_mux_enum);
-
-static const struct snd_kcontrol_new dec10_mux =
-	WCD9320_DEC_ENUM("DEC10 MUX Mux", dec10_mux_enum);
-
-static const struct snd_kcontrol_new iir1_inp1_mux =
-	SOC_DAPM_ENUM("IIR1 INP1 Mux", iir1_inp1_mux_enum);
-
-static const struct snd_kcontrol_new iir2_inp1_mux =
-	SOC_DAPM_ENUM("IIR2 INP1 Mux", iir2_inp1_mux_enum);
-
-static const struct snd_kcontrol_new anc1_mux =
-	SOC_DAPM_ENUM("ANC1 MUX Mux", anc1_mux_enum);
-
-static const struct snd_kcontrol_new anc2_mux =
-	SOC_DAPM_ENUM("ANC2 MUX Mux", anc2_mux_enum);
-
-static const struct snd_kcontrol_new anc1_fb_mux =
-	SOC_DAPM_ENUM("ANC1 FB MUX Mux", anc1_fb_mux_enum);
-
-static const struct snd_kcontrol_new dac1_switch[] = {
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_EAR_EN, 5, 1, 0)
-};
-static const struct snd_kcontrol_new hphl_switch[] = {
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_HPH_L_DAC_CTL, 6, 1, 0)
-};
-
-static const struct snd_kcontrol_new hphl_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					7, 1, 0),
-};
-
-static const struct snd_kcontrol_new hphr_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_R Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					6, 1, 0),
-};
-
-static const struct snd_kcontrol_new ear_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					5, 1, 0),
-};
-static const struct snd_kcontrol_new lineout1_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					4, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout2_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_R Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					3, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout3_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_L Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					2, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout4_pa_mix[] = {
-	SOC_DAPM_SINGLE("AUX_PGA_R Switch", TAIKO_A_RX_PA_AUX_IN_CONN,
-					1, 1, 0),
-};
-
-static const struct snd_kcontrol_new lineout3_ground_switch =
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_LINE_3_DAC_CTL, 6, 1, 0);
-
-static const struct snd_kcontrol_new lineout4_ground_switch =
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_RX_LINE_4_DAC_CTL, 6, 1, 0);
-
-static const struct snd_kcontrol_new aif4_mad_switch =
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_CDC_CLK_OTHR_CTL, 4, 1, 0);
-
-static const struct snd_kcontrol_new aif4_vi_switch =
-	SOC_DAPM_SINGLE("Switch", TAIKO_A_SPKR_PROT_EN, 3, 1, 0);
-/* virtual port entries */
-static int slim_tx_mixer_get(struct snd_kcontrol *kcontrol,
-			     struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
-
-	ucontrol->value.integer.value[0] = widget->value;
-	return 0;
-}
-
-static int slim_tx_mixer_put(struct snd_kcontrol *kcontrol,
-			     struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
-	struct snd_soc_codec *codec = widget->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
-	struct soc_multi_mixer_control *mixer =
-		((struct soc_multi_mixer_control *)kcontrol->private_value);
-	u32 dai_id = widget->shift;
-	u32 port_id = mixer->shift;
-	u32 enable = ucontrol->value.integer.value[0];
-	u32 vtable = vport_check_table[dai_id];
-
-
-	pr_debug("%s: wname %s cname %s value %u shift %d item %ld\n", __func__,
-		widget->name, ucontrol->id.name, widget->value, widget->shift,
-		ucontrol->value.integer.value[0]);
-
-	mutex_lock(&codec->mutex);
-
-	if (taiko_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
-		if (dai_id != AIF1_CAP) {
-			dev_err(codec->dev, "%s: invalid AIF for I2C mode\n",
-				__func__);
-			mutex_unlock(&codec->mutex);
-			return -EINVAL;
-		}
-	}
-		switch (dai_id) {
-		case AIF1_CAP:
-		case AIF2_CAP:
-		case AIF3_CAP:
-			/* only add to the list if value not set
-			 */
-			if (enable && !(widget->value & 1 << port_id)) {
-
-				if (taiko_p->intf_type ==
-					WCD9XXX_INTERFACE_TYPE_SLIMBUS)
-					vtable = vport_check_table[dai_id];
-				if (taiko_p->intf_type ==
-					WCD9XXX_INTERFACE_TYPE_I2C)
-					vtable = vport_i2s_check_table[dai_id];
-
-				if (wcd9xxx_tx_vport_validation(
-						vtable,
-						port_id,
-						taiko_p->dai, NUM_CODEC_DAIS)) {
-					dev_dbg(codec->dev, "%s: TX%u is used by other virtual port\n",
-						__func__, port_id + 1);
-					mutex_unlock(&codec->mutex);
-					return 0;
-				}
-				widget->value |= 1 << port_id;
-				list_add_tail(&core->tx_chs[port_id].list,
-				      &taiko_p->dai[dai_id].wcd9xxx_ch_list
-					      );
-			} else if (!enable && (widget->value & 1 << port_id)) {
-				widget->value &= ~(1 << port_id);
-				list_del_init(&core->tx_chs[port_id].list);
-			} else {
-				if (enable)
-					dev_dbg(codec->dev, "%s: TX%u port is used by\n"
-						"this virtual port\n",
-						__func__, port_id + 1);
-				else
-					dev_dbg(codec->dev, "%s: TX%u port is not used by\n"
-						"this virtual port\n",
-						__func__, port_id + 1);
-				/* avoid update power function */
-				mutex_unlock(&codec->mutex);
-				return 0;
-			}
-			break;
-		default:
-			pr_err("Unknown AIF %d\n", dai_id);
-			mutex_unlock(&codec->mutex);
-			return -EINVAL;
-		}
-	pr_debug("%s: name %s sname %s updated value %u shift %d\n", __func__,
-		widget->name, widget->sname, widget->value, widget->shift);
-
-	snd_soc_dapm_mixer_update_power(widget, kcontrol, enable);
-
-	mutex_unlock(&codec->mutex);
-	return 0;
-}
-
-static int slim_rx_mux_get(struct snd_kcontrol *kcontrol,
-			   struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
-
-	ucontrol->value.enumerated.item[0] = widget->value;
-	return 0;
-}
-
-static const char *const slim_rx_mux_text[] = {
-	"ZERO", "AIF1_PB", "AIF2_PB", "AIF3_PB"
-};
-
-static int slim_rx_mux_put(struct snd_kcontrol *kcontrol,
-			   struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
-	struct snd_soc_codec *codec = widget->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	u32 port_id = widget->shift;
-
-	pr_debug("%s: wname %s cname %s value %u shift %d item %ld\n", __func__,
-		widget->name, ucontrol->id.name, widget->value, widget->shift,
-		ucontrol->value.integer.value[0]);
-
-	widget->value = ucontrol->value.enumerated.item[0];
-
-	mutex_lock(&codec->mutex);
-
-	if (taiko_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
-		if (widget->value > 2) {
-			dev_err(codec->dev, "%s: invalid AIF for I2C mode\n",
-				__func__);
-			goto err;
-		}
-	}
-	/* value need to match the Virtual port and AIF number
-	 */
-	switch (widget->value) {
-	case 0:
-		list_del_init(&core->rx_chs[port_id].list);
-	break;
-	case 1:
-		if (wcd9xxx_rx_vport_validation(port_id +
-			TAIKO_RX_PORT_START_NUMBER,
-			&taiko_p->dai[AIF1_PB].wcd9xxx_ch_list)) {
-			dev_dbg(codec->dev, "%s: RX%u is used by current requesting AIF_PB itself\n",
-				__func__, port_id + 1);
-			goto rtn;
-		}
-		list_add_tail(&core->rx_chs[port_id].list,
-			      &taiko_p->dai[AIF1_PB].wcd9xxx_ch_list);
-	break;
-	case 2:
-		if (wcd9xxx_rx_vport_validation(port_id +
-			TAIKO_RX_PORT_START_NUMBER,
-			&taiko_p->dai[AIF2_PB].wcd9xxx_ch_list)) {
-			dev_dbg(codec->dev, "%s: RX%u is used by current requesting AIF_PB itself\n",
-				__func__, port_id + 1);
-			goto rtn;
-		}
-		list_add_tail(&core->rx_chs[port_id].list,
-			      &taiko_p->dai[AIF2_PB].wcd9xxx_ch_list);
-	break;
-	case 3:
-		if (wcd9xxx_rx_vport_validation(port_id +
-			TAIKO_RX_PORT_START_NUMBER,
-			&taiko_p->dai[AIF3_PB].wcd9xxx_ch_list)) {
-			dev_dbg(codec->dev, "%s: RX%u is used by current requesting AIF_PB itself\n",
-				__func__, port_id + 1);
-			goto rtn;
-		}
-		list_add_tail(&core->rx_chs[port_id].list,
-			      &taiko_p->dai[AIF3_PB].wcd9xxx_ch_list);
-	break;
-	default:
-		pr_err("Unknown AIF %d\n", widget->value);
-		goto err;
-	}
-rtn:
-	snd_soc_dapm_mux_update_power(widget, kcontrol, 1, widget->value, e);
-
-	mutex_unlock(&codec->mutex);
-	return 0;
-err:
-	mutex_unlock(&codec->mutex);
-	return -EINVAL;
-}
-
-static const struct soc_enum slim_rx_mux_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(slim_rx_mux_text), slim_rx_mux_text);
-
-static const struct snd_kcontrol_new slim_rx_mux[TAIKO_RX_MAX] = {
-	SOC_DAPM_ENUM_EXT("SLIM RX1 Mux", slim_rx_mux_enum,
-			  slim_rx_mux_get, slim_rx_mux_put),
-	SOC_DAPM_ENUM_EXT("SLIM RX2 Mux", slim_rx_mux_enum,
-			  slim_rx_mux_get, slim_rx_mux_put),
-	SOC_DAPM_ENUM_EXT("SLIM RX3 Mux", slim_rx_mux_enum,
-			  slim_rx_mux_get, slim_rx_mux_put),
-	SOC_DAPM_ENUM_EXT("SLIM RX4 Mux", slim_rx_mux_enum,
-			  slim_rx_mux_get, slim_rx_mux_put),
-	SOC_DAPM_ENUM_EXT("SLIM RX5 Mux", slim_rx_mux_enum,
-			  slim_rx_mux_get, slim_rx_mux_put),
-	SOC_DAPM_ENUM_EXT("SLIM RX6 Mux", slim_rx_mux_enum,
-			  slim_rx_mux_get, slim_rx_mux_put),
-	SOC_DAPM_ENUM_EXT("SLIM RX7 Mux", slim_rx_mux_enum,
-			  slim_rx_mux_get, slim_rx_mux_put),
-};
-
-static const struct snd_kcontrol_new aif_cap_mixer[] = {
-	SOC_SINGLE_EXT("SLIM TX1", SND_SOC_NOPM, TAIKO_TX1, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX2", SND_SOC_NOPM, TAIKO_TX2, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX3", SND_SOC_NOPM, TAIKO_TX3, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX4", SND_SOC_NOPM, TAIKO_TX4, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX5", SND_SOC_NOPM, TAIKO_TX5, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX6", SND_SOC_NOPM, TAIKO_TX6, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX7", SND_SOC_NOPM, TAIKO_TX7, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX8", SND_SOC_NOPM, TAIKO_TX8, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX9", SND_SOC_NOPM, TAIKO_TX9, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-	SOC_SINGLE_EXT("SLIM TX10", SND_SOC_NOPM, TAIKO_TX10, 1, 0,
-			slim_tx_mixer_get, slim_tx_mixer_put),
-};
-
-static void taiko_codec_enable_adc_block(struct snd_soc_codec *codec,
-					 int enable)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s %d\n", __func__, enable);
-
-	if (enable) {
-		taiko->adc_count++;
-		snd_soc_update_bits(codec, WCD9XXX_A_CDC_CLK_OTHR_CTL,
-						0x2, 0x2);
-	} else {
-		taiko->adc_count--;
-		if (!taiko->adc_count)
-			snd_soc_update_bits(codec, WCD9XXX_A_CDC_CLK_OTHR_CTL,
-					    0x2, 0x0);
-	}
-}
-
-static int taiko_codec_enable_adc(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	u16 adc_reg;
-	u8 init_bit_shift;
-	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
-
-	pr_debug("%s %d\n", __func__, event);
-
-	if (TAIKO_IS_1_0(core->version)) {
-		if (w->reg == TAIKO_A_TX_1_2_EN) {
-			adc_reg = TAIKO_A_TX_1_2_TEST_CTL;
-		} else if (w->reg == TAIKO_A_TX_3_4_EN) {
-			adc_reg = TAIKO_A_TX_3_4_TEST_CTL;
-		} else if (w->reg == TAIKO_A_TX_5_6_EN) {
-			adc_reg = TAIKO_A_TX_5_6_TEST_CTL;
-		} else {
-			pr_err("%s: Error, invalid adc register\n", __func__);
-			return -EINVAL;
-		}
-
-		if (w->shift == 3) {
-			init_bit_shift = 6;
-		} else if  (w->shift == 7) {
-			init_bit_shift = 7;
-		} else {
-			pr_err("%s: Error, invalid init bit postion adc register\n",
-			       __func__);
-			return -EINVAL;
-		}
-	} else {
-		switch (w->reg) {
-		case TAIKO_A_CDC_TX_1_GAIN:
-			adc_reg = TAIKO_A_TX_1_2_TEST_CTL;
-			init_bit_shift = 7;
-			break;
-		case TAIKO_A_CDC_TX_2_GAIN:
-			adc_reg = TAIKO_A_TX_1_2_TEST_CTL;
-			init_bit_shift = 6;
-			break;
-		case TAIKO_A_CDC_TX_3_GAIN:
-			adc_reg = TAIKO_A_TX_3_4_TEST_CTL;
-			init_bit_shift = 7;
-			break;
-		case TAIKO_A_CDC_TX_4_GAIN:
-			adc_reg = TAIKO_A_TX_3_4_TEST_CTL;
-			init_bit_shift = 6;
-			break;
-		case TAIKO_A_CDC_TX_5_GAIN:
-			adc_reg = TAIKO_A_TX_5_6_TEST_CTL;
-			init_bit_shift = 7;
-			break;
-		case TAIKO_A_CDC_TX_6_GAIN:
-			adc_reg = TAIKO_A_TX_5_6_TEST_CTL;
-			init_bit_shift = 6;
-			break;
-		default:
-			pr_err("%s: Error, invalid adc register\n", __func__);
-			return -EINVAL;
-		}
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-#if defined(CONFIG_SEC_JACTIVE_PROJECT)
-		if ((sub_mic_rec_delay == 1) && ((w->reg) == TAIKO_A_CDC_TX_3_GAIN))
-				usleep_range(400000, 400000);
-#endif
-		taiko_codec_enable_adc_block(codec, 1);
-		snd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift,
-				1 << init_bit_shift);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		snd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift, 0x00);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		taiko_codec_enable_adc_block(codec, 0);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_aux_pga(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: %d\n", __func__, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		WCD9XXX_BG_CLK_LOCK(&taiko->resmgr);
-		wcd9xxx_resmgr_get_bandgap(&taiko->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-		/* AUX PGA requires RCO or MCLK */
-		wcd9xxx_resmgr_get_clk_block(&taiko->resmgr, WCD9XXX_CLK_RCO);
-		wcd9xxx_resmgr_enable_rx_bias(&taiko->resmgr, 1);
-		WCD9XXX_BG_CLK_UNLOCK(&taiko->resmgr);
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		WCD9XXX_BG_CLK_LOCK(&taiko->resmgr);
-		wcd9xxx_resmgr_enable_rx_bias(&taiko->resmgr, 0);
-		wcd9xxx_resmgr_put_bandgap(&taiko->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-		wcd9xxx_resmgr_put_clk_block(&taiko->resmgr, WCD9XXX_CLK_RCO);
-		WCD9XXX_BG_CLK_UNLOCK(&taiko->resmgr);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_lineout(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u16 lineout_gain_reg;
-
-	pr_debug("%s %d %s\n", __func__, event, w->name);
-
-	switch (w->shift) {
-	case 0:
-		lineout_gain_reg = TAIKO_A_RX_LINE_1_GAIN;
-		break;
-	case 1:
-		lineout_gain_reg = TAIKO_A_RX_LINE_2_GAIN;
-		break;
-	case 2:
-		lineout_gain_reg = TAIKO_A_RX_LINE_3_GAIN;
-		break;
-	case 3:
-		lineout_gain_reg = TAIKO_A_RX_LINE_4_GAIN;
-		break;
-	default:
-		pr_err("%s: Error, incorrect lineout register value\n",
-			__func__);
-		return -EINVAL;
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, lineout_gain_reg, 0x40, 0x40);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
-						 WCD9XXX_CLSH_STATE_LO,
-						 WCD9XXX_CLSH_REQ_ENABLE,
-						 WCD9XXX_CLSH_EVENT_POST_PA);
-		pr_debug("%s: sleeping 5 ms after %s PA turn on\n",
-				__func__, w->name);
-		/* Wait for CnP time after PA enable */
-		usleep_range(5000, 5100);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
-						 WCD9XXX_CLSH_STATE_LO,
-						 WCD9XXX_CLSH_REQ_DISABLE,
-						 WCD9XXX_CLSH_EVENT_POST_PA);
-		snd_soc_update_bits(codec, lineout_gain_reg, 0x40, 0x00);
-		pr_debug("%s: sleeping 5 ms after %s PA turn off\n",
-				__func__, w->name);
-		/* Wait for CnP time after PA disable */
-		usleep_range(5000, 5100);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_spk_pa(struct snd_soc_dapm_widget *w,
-				     struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: %d %s\n", __func__, event, w->name);
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		taiko->spkr_pa_widget_on = true;
-		snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_EN, 0x80, 0x80);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		taiko->spkr_pa_widget_on = false;
-		snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_EN, 0x80, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_dmic(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u8  dmic_clk_en;
-	u16 dmic_clk_reg;
-	s32 *dmic_clk_cnt;
-	unsigned int dmic;
-	int ret;
-
-	ret = kstrtouint(strpbrk(w->name, "123456"), 10, &dmic);
-	if (ret < 0) {
-		pr_err("%s: Invalid DMIC line on the codec\n", __func__);
-		return -EINVAL;
-	}
-
-	switch (dmic) {
-	case 1:
-	case 2:
-		dmic_clk_en = 0x01;
-		dmic_clk_cnt = &(taiko->dmic_1_2_clk_cnt);
-		dmic_clk_reg = TAIKO_A_CDC_CLK_DMIC_B1_CTL;
-		pr_debug("%s() event %d DMIC%d dmic_1_2_clk_cnt %d\n",
-			__func__, event,  dmic, *dmic_clk_cnt);
-
-		break;
-
-	case 3:
-	case 4:
-		dmic_clk_en = 0x10;
-		dmic_clk_cnt = &(taiko->dmic_3_4_clk_cnt);
-		dmic_clk_reg = TAIKO_A_CDC_CLK_DMIC_B1_CTL;
-
-		pr_debug("%s() event %d DMIC%d dmic_3_4_clk_cnt %d\n",
-			__func__, event,  dmic, *dmic_clk_cnt);
-		break;
-
-	case 5:
-	case 6:
-		dmic_clk_en = 0x01;
-		dmic_clk_cnt = &(taiko->dmic_5_6_clk_cnt);
-		dmic_clk_reg = TAIKO_A_CDC_CLK_DMIC_B2_CTL;
-
-		pr_debug("%s() event %d DMIC%d dmic_5_6_clk_cnt %d\n",
-			__func__, event,  dmic, *dmic_clk_cnt);
-
-		break;
-
-	default:
-		pr_err("%s: Invalid DMIC Selection\n", __func__);
-		return -EINVAL;
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-
-		(*dmic_clk_cnt)++;
-		if (*dmic_clk_cnt == 1)
-			snd_soc_update_bits(codec, dmic_clk_reg,
-					dmic_clk_en, dmic_clk_en);
-
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-
-		(*dmic_clk_cnt)--;
-		if (*dmic_clk_cnt  == 0)
-			snd_soc_update_bits(codec, dmic_clk_reg,
-					dmic_clk_en, 0);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_config_mad(struct snd_soc_codec *codec)
-{
-	int ret;
-	const struct firmware *fw;
-	struct mad_audio_cal *mad_cal;
-	struct firmware_cal *hwdep_cal = NULL;
-	const void *data;
-	const char *filename = TAIKO_MAD_AUDIO_FIRMWARE_PATH;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	size_t cal_size;
-
-	pr_debug("%s: enter\n", __func__);
-	/* wakeup for codec calibration access */
-	pm_qos_add_request(&taiko->pm_qos_req,
-			   PM_QOS_CPU_DMA_LATENCY,
-			   PM_QOS_DEFAULT_VALUE);
-	pm_qos_update_request(&taiko->pm_qos_req,
-			      msm_cpuidle_get_deep_idle_latency());
-	if (!taiko->fw_data) {
-		dev_err(codec->dev, "%s: invalid cal data\n",
-				 __func__);
-		return -ENODEV;
-	}
-	hwdep_cal = wcdcal_get_fw_cal(taiko->fw_data, WCD9XXX_MAD_CAL);
-	if (hwdep_cal) {
-		data = hwdep_cal->data;
-		cal_size = hwdep_cal->size;
-		dev_dbg(codec->dev, "%s: using hwdep calibration\n",
-				__func__);
-	} else {
-		ret = request_firmware(&fw, filename, codec->dev);
-		if (ret != 0) {
-			pr_err("Failed to acquire MAD firwmare data %s: %d\n",
-				filename, ret);
-			return -ENODEV;
-		}
-		if (!fw) {
-			dev_err(codec->dev, "failed to get mad fw");
-			return -ENODEV;
-		}
-		data = fw->data;
-		cal_size = fw->size;
-		dev_dbg(codec->dev, "%s: using request_firmware calibration\n",
-				__func__);
-	}
-	if (cal_size < sizeof(struct mad_audio_cal)) {
-		pr_err("%s: incorrect hwdep cal size %zu\n",
-			__func__, cal_size);
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	mad_cal = (struct mad_audio_cal *)(data);
-	if (!mad_cal) {
-		dev_err(codec->dev, "%s: Invalid calibration data\n",
-				__func__);
-		ret =  -EINVAL;
-		goto err;
-	}
-
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_MAIN_CTL_2,
-		      mad_cal->microphone_info.cycle_time);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MAD_MAIN_CTL_1, 0xFF << 3,
-			    ((uint16_t)mad_cal->microphone_info.settle_time)
-			    << 3);
-
-	/* Audio */
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_AUDIO_CTL_8,
-		      mad_cal->audio_info.rms_omit_samples);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MAD_AUDIO_CTL_1,
-			    0x07 << 4, mad_cal->audio_info.rms_comp_time << 4);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MAD_AUDIO_CTL_2, 0x03 << 2,
-			    mad_cal->audio_info.detection_mechanism << 2);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_AUDIO_CTL_7,
-		      mad_cal->audio_info.rms_diff_threshold & 0x3F);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_AUDIO_CTL_5,
-		      mad_cal->audio_info.rms_threshold_lsb);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_AUDIO_CTL_6,
-		      mad_cal->audio_info.rms_threshold_msb);
-
-
-	/* Beacon */
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_BEACON_CTL_8,
-		      mad_cal->beacon_info.rms_omit_samples);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MAD_BEACON_CTL_1,
-			    0x07 << 4, mad_cal->beacon_info.rms_comp_time);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MAD_BEACON_CTL_2, 0x03 << 2,
-			    mad_cal->beacon_info.detection_mechanism << 2);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_BEACON_CTL_7,
-		      mad_cal->beacon_info.rms_diff_threshold & 0x1F);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_BEACON_CTL_5,
-		      mad_cal->beacon_info.rms_threshold_lsb);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_BEACON_CTL_6,
-		      mad_cal->beacon_info.rms_threshold_msb);
-
-	/* Ultrasound */
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MAD_BEACON_CTL_1,
-			    0x07 << 4, mad_cal->beacon_info.rms_comp_time);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_MAD_ULTR_CTL_2, 0x03 << 2,
-			    mad_cal->ultrasound_info.detection_mechanism);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_ULTR_CTL_7,
-		      mad_cal->ultrasound_info.rms_diff_threshold & 0x1F);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_ULTR_CTL_5,
-		      mad_cal->ultrasound_info.rms_threshold_lsb);
-	snd_soc_write(codec, TAIKO_A_CDC_MAD_ULTR_CTL_6,
-		      mad_cal->ultrasound_info.rms_threshold_msb);
-
-	pr_debug("%s: leave ret %d\n", __func__, ret);
-	pm_qos_update_request(&taiko->pm_qos_req,
-			      PM_QOS_DEFAULT_VALUE);
-	pm_qos_remove_request(&taiko->pm_qos_req);
-err:
-	if (!hwdep_cal)
-		release_firmware(fw);
-	return ret;
-}
-
-static int taiko_codec_enable_mad(struct snd_soc_dapm_widget *w,
-				  struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	int ret = 0;
-
-	pr_debug("%s %d\n", __func__, event);
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		ret = taiko_codec_config_mad(codec);
-		if (ret) {
-			pr_err("%s: Failed to config MAD\n", __func__);
-			break;
-		}
-		break;
-	}
-	return ret;
-}
-
-static int taiko_codec_enable_micbias(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u16 micb_int_reg = 0, micb_ctl_reg = 0;
-	u8 cfilt_sel_val = 0;
-	char *internal1_text = "Internal1";
-	char *internal2_text = "Internal2";
-	char *internal3_text = "Internal3";
-	enum wcd9xxx_notify_event e_post_off, e_pre_on, e_post_on;
-
-	pr_debug("%s: w->name %s event %d\n", __func__, w->name, event);
-	if (strnstr(w->name, "MIC BIAS1", sizeof("MIC BIAS1"))) {
-		micb_ctl_reg = TAIKO_A_MICB_1_CTL;
-		micb_int_reg = TAIKO_A_MICB_1_INT_RBIAS;
-		cfilt_sel_val = taiko->resmgr.pdata->micbias.bias1_cfilt_sel;
-		e_pre_on = WCD9XXX_EVENT_PRE_MICBIAS_1_ON;
-		e_post_on = WCD9XXX_EVENT_POST_MICBIAS_1_ON;
-		e_post_off = WCD9XXX_EVENT_POST_MICBIAS_1_OFF;
-	} else if (strnstr(w->name, "MIC BIAS2", sizeof("MIC BIAS2"))) {
-		micb_ctl_reg = TAIKO_A_MICB_2_CTL;
-		micb_int_reg = TAIKO_A_MICB_2_INT_RBIAS;
-		cfilt_sel_val = taiko->resmgr.pdata->micbias.bias2_cfilt_sel;
-		e_pre_on = WCD9XXX_EVENT_PRE_MICBIAS_2_ON;
-		e_post_on = WCD9XXX_EVENT_POST_MICBIAS_2_ON;
-		e_post_off = WCD9XXX_EVENT_POST_MICBIAS_2_OFF;
-	} else if (strnstr(w->name, "MIC BIAS3", sizeof("MIC BIAS3"))) {
-		micb_ctl_reg = TAIKO_A_MICB_3_CTL;
-		micb_int_reg = TAIKO_A_MICB_3_INT_RBIAS;
-		cfilt_sel_val = taiko->resmgr.pdata->micbias.bias3_cfilt_sel;
-		e_pre_on = WCD9XXX_EVENT_PRE_MICBIAS_3_ON;
-		e_post_on = WCD9XXX_EVENT_POST_MICBIAS_3_ON;
-		e_post_off = WCD9XXX_EVENT_POST_MICBIAS_3_OFF;
-	} else if (strnstr(w->name, "MIC BIAS4", sizeof("MIC BIAS4"))) {
-		micb_ctl_reg = TAIKO_A_MICB_4_CTL;
-		micb_int_reg = taiko->resmgr.reg_addr->micb_4_int_rbias;
-		cfilt_sel_val = taiko->resmgr.pdata->micbias.bias4_cfilt_sel;
-		e_pre_on = WCD9XXX_EVENT_PRE_MICBIAS_4_ON;
-		e_post_on = WCD9XXX_EVENT_POST_MICBIAS_4_ON;
-		e_post_off = WCD9XXX_EVENT_POST_MICBIAS_4_OFF;
-	} else {
-		pr_err("%s: Error, invalid micbias %s\n", __func__, w->name);
-		return -EINVAL;
-	}
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		/* Let MBHC module know so micbias switch to be off */
-		wcd9xxx_resmgr_notifier_call(&taiko->resmgr, e_pre_on);
-
-		/* Get cfilt */
-		wcd9xxx_resmgr_cfilt_get(&taiko->resmgr, cfilt_sel_val);
-
-		if (strnstr(w->name, internal1_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0xE0, 0xE0);
-		else if (strnstr(w->name, internal2_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x1C, 0x1C);
-		else if (strnstr(w->name, internal3_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x3, 0x3);
-
-		if (taiko->mbhc_started && micb_ctl_reg == TAIKO_A_MICB_2_CTL) {
-			if (++taiko->micb_2_users == 1) {
-				if (taiko->resmgr.pdata->
-				    micbias.bias2_is_headset_only)
-					wcd9xxx_resmgr_add_cond_update_bits(
-							 &taiko->resmgr,
-							 WCD9XXX_COND_HPH_MIC,
-							 micb_ctl_reg, w->shift,
-							 false);
-				else
-					snd_soc_update_bits(codec, micb_ctl_reg,
-							    1 << w->shift,
-							    1 << w->shift);
-			}
-			pr_debug("%s: micb_2_users %d\n", __func__,
-				 taiko->micb_2_users);
-		} else {
-			snd_soc_update_bits(codec, micb_ctl_reg, 1 << w->shift,
-					    1 << w->shift);
-		}
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		usleep_range(20000, 20000);
-		/* Let MBHC module know so micbias is on */
-		wcd9xxx_resmgr_notifier_call(&taiko->resmgr, e_post_on);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		if (taiko->mbhc_started && micb_ctl_reg == TAIKO_A_MICB_2_CTL) {
-			if (--taiko->micb_2_users == 0) {
-				if (taiko->resmgr.pdata->
-				    micbias.bias2_is_headset_only)
-					wcd9xxx_resmgr_rm_cond_update_bits(
-							&taiko->resmgr,
-							WCD9XXX_COND_HPH_MIC,
-							micb_ctl_reg, 7, false);
-				else
-					snd_soc_update_bits(codec, micb_ctl_reg,
-							    1 << w->shift, 0);
-			}
-			pr_debug("%s: micb_2_users %d\n", __func__,
-				 taiko->micb_2_users);
-			WARN(taiko->micb_2_users < 0,
-			     "Unexpected micbias users %d\n",
-			     taiko->micb_2_users);
-		} else {
-			snd_soc_update_bits(codec, micb_ctl_reg, 1 << w->shift,
-					    0);
-		}
-
-		/* Let MBHC module know so micbias switch to be off */
-		wcd9xxx_resmgr_notifier_call(&taiko->resmgr, e_post_off);
-
-		if (strnstr(w->name, internal1_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x80, 0x00);
-		else if (strnstr(w->name, internal2_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x10, 0x00);
-		else if (strnstr(w->name, internal3_text, 30))
-			snd_soc_update_bits(codec, micb_int_reg, 0x2, 0x0);
-
-		/* Put cfilt */
-		wcd9xxx_resmgr_cfilt_put(&taiko->resmgr, cfilt_sel_val);
-		break;
-	}
-
-	return 0;
-}
-
-/* called under codec_resource_lock acquisition */
-static int taiko_enable_mbhc_micbias(struct snd_soc_codec *codec, bool enable,
-				     enum wcd9xxx_micbias_num micb_num)
-{
-	int rc;
-	const char *micbias;
-
-	if (micb_num != MBHC_MICBIAS3 &&
-	    micb_num != MBHC_MICBIAS2)
-		return -EINVAL;
-
-	micbias = (micb_num == MBHC_MICBIAS3) ?
-			DAPM_MICBIAS3_EXTERNAL_STANDALONE :
-			DAPM_MICBIAS2_EXTERNAL_STANDALONE;
-
-	if (enable)
-		rc = snd_soc_dapm_force_enable_pin(&codec->dapm,
-					     micbias);
-	else
-		rc = snd_soc_dapm_disable_pin(&codec->dapm,
-					     micbias);
-	if (!rc)
-		snd_soc_dapm_sync(&codec->dapm);
-	pr_debug("%s: leave ret %d\n", __func__, rc);
-	return rc;
-}
-
-static void tx_hpf_corner_freq_callback(struct work_struct *work)
-{
-	struct delayed_work *hpf_delayed_work;
-	struct hpf_work *hpf_work;
-	struct taiko_priv *taiko;
-	struct snd_soc_codec *codec;
-	u16 tx_mux_ctl_reg;
-	u8 hpf_cut_of_freq;
-
-	hpf_delayed_work = to_delayed_work(work);
-	hpf_work = container_of(hpf_delayed_work, struct hpf_work, dwork);
-	taiko = hpf_work->taiko;
-	codec = hpf_work->taiko->codec;
-	hpf_cut_of_freq = hpf_work->tx_hpf_cut_of_freq;
-
-	tx_mux_ctl_reg = TAIKO_A_CDC_TX1_MUX_CTL +
-			(hpf_work->decimator - 1) * 8;
-
-	pr_debug("%s(): decimator %u hpf_cut_of_freq 0x%x\n", __func__,
-		hpf_work->decimator, (unsigned int)hpf_cut_of_freq);
-
-	snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x30, hpf_cut_of_freq << 4);
-}
-
-#define  TX_MUX_CTL_CUT_OFF_FREQ_MASK	0x30
-#define  CF_MIN_3DB_4HZ			0x0
-#define  CF_MIN_3DB_75HZ		0x1
-#define  CF_MIN_3DB_150HZ		0x2
-
-static int taiko_codec_enable_dec(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	unsigned int decimator;
-	char *dec_name = NULL;
-	char *widget_name = NULL;
-	char *temp;
-	int ret = 0;
-	u16 dec_reset_reg, tx_vol_ctl_reg, tx_mux_ctl_reg;
-	u8 dec_hpf_cut_of_freq;
-	int offset;
-
-
-	pr_debug("%s %d\n", __func__, event);
-
-	widget_name = kstrndup(w->name, 15, GFP_KERNEL);
-	if (!widget_name)
-		return -ENOMEM;
-	temp = widget_name;
-
-	dec_name = strsep(&widget_name, " ");
-	widget_name = temp;
-	if (!dec_name) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, w->name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	ret = kstrtouint(strpbrk(dec_name, "123456789"), 10, &decimator);
-	if (ret < 0) {
-		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
-		ret =  -EINVAL;
-		goto out;
-	}
-
-	pr_debug("%s(): widget = %s dec_name = %s decimator = %u\n", __func__,
-			w->name, dec_name, decimator);
-
-	if (w->reg == TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL) {
-		dec_reset_reg = TAIKO_A_CDC_CLK_TX_RESET_B1_CTL;
-		offset = 0;
-	} else if (w->reg == TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL) {
-		dec_reset_reg = TAIKO_A_CDC_CLK_TX_RESET_B2_CTL;
-		offset = 8;
-	} else {
-		pr_err("%s: Error, incorrect dec\n", __func__);
-		return -EINVAL;
-	}
-
-	tx_vol_ctl_reg = TAIKO_A_CDC_TX1_VOL_CTL_CFG + 8 * (decimator - 1);
-	tx_mux_ctl_reg = TAIKO_A_CDC_TX1_MUX_CTL + 8 * (decimator - 1);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-
-		/* Enableable TX digital mute */
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
-
-		snd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift,
-			1 << w->shift);
-		snd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift, 0x0);
-
-		dec_hpf_cut_of_freq = snd_soc_read(codec, tx_mux_ctl_reg);
-
-		dec_hpf_cut_of_freq = (dec_hpf_cut_of_freq & 0x30) >> 4;
-
-		tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq =
-			dec_hpf_cut_of_freq;
-
-		if ((dec_hpf_cut_of_freq != CF_MIN_3DB_150HZ)) {
-
-			/* set cut of freq to CF_MIN_3DB_150HZ (0x1); */
-			snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x30,
-					    CF_MIN_3DB_150HZ << 4);
-		}
-
-		/* enable HPF */
-		snd_soc_update_bits(codec, tx_mux_ctl_reg , 0x08, 0x00);
-
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-
-		/* Disable TX digital mute */
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x00);
-
-		if (tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq !=
-				CF_MIN_3DB_150HZ) {
-
-			schedule_delayed_work(&tx_hpf_work[decimator - 1].dwork,
-					msecs_to_jiffies(300));
-		}
-		/* apply the digital gain after the decimator is enabled*/
-		if ((w->shift + offset) < ARRAY_SIZE(tx_digital_gain_reg))
-			snd_soc_write(codec,
-				  tx_digital_gain_reg[w->shift + offset],
-				  snd_soc_read(codec,
-				  tx_digital_gain_reg[w->shift + offset])
-				  );
-
-		break;
-
-	case SND_SOC_DAPM_PRE_PMD:
-
-		snd_soc_update_bits(codec, tx_vol_ctl_reg, 0x01, 0x01);
-		cancel_delayed_work_sync(&tx_hpf_work[decimator - 1].dwork);
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-
-		snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x08, 0x08);
-		snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x30,
-			(tx_hpf_work[decimator - 1].tx_hpf_cut_of_freq) << 4);
-
-		break;
-	}
-out:
-	kfree(widget_name);
-	return ret;
-}
-
-static int taiko_codec_enable_vdd_spkr(struct snd_soc_dapm_widget *w,
-				       struct snd_kcontrol *kcontrol, int event)
-{
-	int ret = 0;
-	struct snd_soc_codec *codec = w->codec;
-	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
-	struct taiko_priv *priv = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: %d %s\n", __func__, event, w->name);
-
-	WARN_ONCE(!priv->spkdrv_reg, "SPKDRV supply %s isn't defined\n",
-		  WCD9XXX_VDD_SPKDRV_NAME);
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		if (priv->spkdrv_reg) {
-			ret = regulator_enable(priv->spkdrv_reg);
-			if (ret)
-				pr_err("%s: Failed to enable spkdrv_reg %s\n",
-				       __func__, WCD9XXX_VDD_SPKDRV_NAME);
-		}
-		if (spkr_drv_wrnd > 0) {
-			WARN_ON(!(snd_soc_read(codec, TAIKO_A_SPKR_DRV_EN) &
-				  0x80));
-			snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_EN, 0x80,
-					    0x00);
-		}
-		if (TAIKO_IS_1_0(core->version))
-			snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_DBG_PWRSTG,
-					    0x24, 0x00);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		if (TAIKO_IS_1_0(core->version))
-			snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_DBG_PWRSTG,
-					    0x24, 0x24);
-		if (spkr_drv_wrnd > 0) {
-			WARN_ON(!!(snd_soc_read(codec, TAIKO_A_SPKR_DRV_EN) &
-				   0x80));
-			snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_EN, 0x80,
-					    0x80);
-		}
-		if (priv->spkdrv_reg) {
-			ret = regulator_disable(priv->spkdrv_reg);
-			if (ret)
-				pr_err("%s: Failed to disable spkdrv_reg %s\n",
-				       __func__, WCD9XXX_VDD_SPKDRV_NAME);
-		}
-		break;
-	}
-
-	return ret;
-}
-
-static int taiko_codec_enable_interpolator(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	pr_debug("%s %d %s\n", __func__, event, w->name);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_RESET_CTL,
-			1 << w->shift, 1 << w->shift);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_RESET_CTL,
-			1 << w->shift, 0x0);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		/* apply the digital gain after the interpolator is enabled*/
-		if ((w->shift) < ARRAY_SIZE(rx_digital_gain_reg))
-			snd_soc_write(codec,
-				  rx_digital_gain_reg[w->shift],
-				  snd_soc_read(codec,
-				  rx_digital_gain_reg[w->shift])
-				  );
-		break;
-	}
-	return 0;
-}
-
-/* called under codec_resource_lock acquisition */
-static int __taiko_codec_enable_ldo_h(struct snd_soc_dapm_widget *w,
-				      struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *priv = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: enter\n", __func__);
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		/*
-		 * ldo_h_users is protected by codec->mutex, don't need
-		 * additional mutex
-		 */
-		if (++priv->ldo_h_users == 1) {
-			WCD9XXX_BG_CLK_LOCK(&priv->resmgr);
-			wcd9xxx_resmgr_get_bandgap(&priv->resmgr,
-						   WCD9XXX_BANDGAP_AUDIO_MODE);
-			wcd9xxx_resmgr_get_clk_block(&priv->resmgr,
-						     WCD9XXX_CLK_RCO);
-			snd_soc_update_bits(codec, TAIKO_A_LDO_H_MODE_1, 1 << 7,
-					    1 << 7);
-			wcd9xxx_resmgr_put_clk_block(&priv->resmgr,
-						     WCD9XXX_CLK_RCO);
-			WCD9XXX_BG_CLK_UNLOCK(&priv->resmgr);
-			pr_debug("%s: ldo_h_users %d\n", __func__,
-				 priv->ldo_h_users);
-			/* LDO enable requires 1ms to settle down */
-			usleep_range(1000, 1000);
-		}
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		if (--priv->ldo_h_users == 0) {
-			WCD9XXX_BG_CLK_LOCK(&priv->resmgr);
-			wcd9xxx_resmgr_get_clk_block(&priv->resmgr,
-						     WCD9XXX_CLK_RCO);
-			snd_soc_update_bits(codec, TAIKO_A_LDO_H_MODE_1, 1 << 7,
-					    0);
-			wcd9xxx_resmgr_put_clk_block(&priv->resmgr,
-						     WCD9XXX_CLK_RCO);
-			wcd9xxx_resmgr_put_bandgap(&priv->resmgr,
-						   WCD9XXX_BANDGAP_AUDIO_MODE);
-			WCD9XXX_BG_CLK_UNLOCK(&priv->resmgr);
-			pr_debug("%s: ldo_h_users %d\n", __func__,
-				 priv->ldo_h_users);
-		}
-		WARN(priv->ldo_h_users < 0, "Unexpected ldo_h users %d\n",
-		     priv->ldo_h_users);
-		break;
-	}
-	pr_debug("%s: leave\n", __func__);
-	return 0;
-}
-
-static int taiko_codec_enable_ldo_h(struct snd_soc_dapm_widget *w,
-				    struct snd_kcontrol *kcontrol, int event)
-{
-	int rc;
-	rc = __taiko_codec_enable_ldo_h(w, kcontrol, event);
-	return rc;
-}
-
-static int taiko_codec_enable_rx_bias(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s %d\n", __func__, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		wcd9xxx_resmgr_enable_rx_bias(&taiko->resmgr, 1);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		wcd9xxx_resmgr_enable_rx_bias(&taiko->resmgr, 0);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_hphl_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	/* uint32_t impedl, impedr; */
-	/* int ret = 0; */
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
-							0x02, 0x02);
-		wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
-						 WCD9XXX_CLSH_STATE_HPHL,
-						 WCD9XXX_CLSH_REQ_ENABLE,
-						 WCD9XXX_CLSH_EVENT_PRE_DAC);
-
-		/*ret = wcd9xxx_mbhc_get_impedance(&taiko_p->mbhc,
-					&impedl, &impedr);
-		if (!ret) */
-		wcd9xxx_clsh_imped_config(codec, 0);
-		/* else
-			dev_err(codec->dev, "Failed to get mbhc impedance %d\n",
-						ret); */
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
-							0x02, 0x00);
-	}
-	return 0;
-}
-
-static int taiko_hphr_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
-							0x04, 0x04);
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x40);
-		wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
-						 WCD9XXX_CLSH_STATE_HPHR,
-						 WCD9XXX_CLSH_REQ_ENABLE,
-						 WCD9XXX_CLSH_EVENT_PRE_DAC);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
-							0x04, 0x00);
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_anc(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	const char *filename;
-	const struct firmware *fw;
-	int i;
-	int ret =0;
-	int num_anc_slots;
-	struct wcd9xxx_anc_header *anc_head;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	struct firmware_cal *hwdep_cal = NULL;
-	u32 anc_writes_size = 0;
-	int anc_size_remaining;
-	u32 *anc_ptr;
-	u16 reg;
-	u8 mask, val, old_val;
-	size_t cal_size;
-	const void *data;
-
-
-	if (taiko->anc_func == 0)
-		return 0;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		filename = "wcd9320/wcd9320_anc.bin";
-		hwdep_cal = wcdcal_get_fw_cal(taiko->fw_data, WCD9XXX_ANC_CAL);
-		if (hwdep_cal) {
-			data = hwdep_cal->data;
-			cal_size = hwdep_cal->size;
-			dev_dbg(codec->dev, "%s: using hwdep calibration\n",
-				__func__);
-		} else {
-			ret = request_firmware(&fw, filename, codec->dev);
-			if (ret != 0) {
-				dev_err(codec->dev, "Failed to acquire ANC data: %d\n",
-					ret);
-				return -ENODEV;
-			}
-			if (!fw) {
-				dev_err(codec->dev, "failed to get anc fw");
-				return -ENODEV;
-			}
-			data = fw->data;
-			cal_size = fw->size;
-			dev_dbg(codec->dev, "%s: using request_firmware calibration\n",
-					 __func__);
-
-		}
-
-		if (cal_size < sizeof(struct wcd9xxx_anc_header)) {
-			dev_err(codec->dev, "Not enough data\n");
-			goto err;
-		}
-
-		/* First number is the number of register writes */
-		anc_head = (struct wcd9xxx_anc_header *)(data);
-		anc_ptr = (u32 *)(data +
-				  sizeof(struct wcd9xxx_anc_header));
-		anc_size_remaining = cal_size -
-				     sizeof(struct wcd9xxx_anc_header);
-		num_anc_slots = anc_head->num_anc_slots;
-
-		if (taiko->anc_slot >= num_anc_slots) {
-			dev_err(codec->dev, "Invalid ANC slot selected\n");
-			ret = -EINVAL;
-			goto err;
-		}
-		for (i = 0; i < num_anc_slots; i++) {
-			if (anc_size_remaining < TAIKO_PACKED_REG_SIZE) {
-				dev_err(codec->dev, "Invalid register format\n");
-				ret = -EINVAL;
-				goto err;
-			}
-			anc_writes_size = (u32)(*anc_ptr);
-			anc_size_remaining -= sizeof(u32);
-			anc_ptr += 1;
-
-			if (anc_writes_size * TAIKO_PACKED_REG_SIZE
-				> anc_size_remaining) {
-				dev_err(codec->dev, "Invalid register format\n");
-				ret = -EINVAL;
-				goto err;
-			}
-
-			if (taiko->anc_slot == i)
-				break;
-
-			anc_size_remaining -= (anc_writes_size *
-				TAIKO_PACKED_REG_SIZE);
-			anc_ptr += anc_writes_size;
-		}
-		if (i == num_anc_slots) {
-			dev_err(codec->dev, "Selected ANC slot not present\n");
-			ret = -EINVAL;
-			goto err;
-		}
-		for (i = 0; i < anc_writes_size; i++) {
-			TAIKO_CODEC_UNPACK_ENTRY(anc_ptr[i], reg,
-				mask, val);
-			old_val = snd_soc_read(codec, reg);
-			snd_soc_write(codec, reg, (old_val & ~mask) |
-				(val & mask));
-		}
-		if (!hwdep_cal)
-			release_firmware(fw);
-		break;
-	case SND_SOC_DAPM_PRE_PMD:
-		msleep(40);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_ANC1_B1_CTL, 0x01, 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_CDC_ANC2_B1_CTL, 0x02, 0x00);
-		msleep(20);
-		snd_soc_write(codec, TAIKO_A_CDC_CLK_ANC_RESET_CTL, 0x0F);
-		snd_soc_write(codec, TAIKO_A_CDC_CLK_ANC_CLK_EN_CTL, 0);
-		snd_soc_write(codec, TAIKO_A_CDC_CLK_ANC_RESET_CTL, 0xFF);
-		break;
-	}
-	return 0;
-err:
-	if (!hwdep_cal)
-		release_firmware(fw);
-	return ret;
-
-}
-
-static int taiko_hph_pa_event(struct snd_soc_dapm_widget *w,
-			      struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	enum wcd9xxx_notify_event e_pre_on, e_post_off;
-	u8 req_clsh_state;
-	u32 pa_settle_time = TAIKO_HPH_PA_SETTLE_COMP_OFF;
-
-	pr_debug("%s: %s event = %d\n", __func__, w->name, event);
-	if (w->shift == 5) {
-		e_pre_on = WCD9XXX_EVENT_PRE_HPHL_PA_ON;
-		e_post_off = WCD9XXX_EVENT_POST_HPHL_PA_OFF;
-		req_clsh_state = WCD9XXX_CLSH_STATE_HPHL;
-	} else if (w->shift == 4) {
-		e_pre_on = WCD9XXX_EVENT_PRE_HPHR_PA_ON;
-		e_post_off = WCD9XXX_EVENT_POST_HPHR_PA_OFF;
-		req_clsh_state = WCD9XXX_CLSH_STATE_HPHR;
-	} else {
-		pr_err("%s: Invalid w->shift %d\n", __func__, w->shift);
-		return -EINVAL;
-	}
-
-	if (taiko->comp_enabled[COMPANDER_1])
-		pa_settle_time = TAIKO_HPH_PA_SETTLE_COMP_ON;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		/* Let MBHC module know PA is turning on */
-		wcd9xxx_resmgr_notifier_call(&taiko->resmgr, e_pre_on);
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-		usleep_range(pa_settle_time, pa_settle_time + 1000);
-		pr_debug("%s: sleep %d us after %s PA enable\n", __func__,
-				pa_settle_time, w->name);
-		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
-						 req_clsh_state,
-						 WCD9XXX_CLSH_REQ_ENABLE,
-						 WCD9XXX_CLSH_EVENT_POST_PA);
-
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		usleep_range(pa_settle_time, pa_settle_time + 1000);
-		pr_debug("%s: sleep %d us after %s PA disable\n", __func__,
-				pa_settle_time, w->name);
-
-		/* Let MBHC module know PA turned off */
-		wcd9xxx_resmgr_notifier_call(&taiko->resmgr, e_post_off);
-
-		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
-						 req_clsh_state,
-						 WCD9XXX_CLSH_REQ_DISABLE,
-						 WCD9XXX_CLSH_EVENT_POST_PA);
-
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_anc_hph(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	int ret = 0;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		ret = taiko_hph_pa_event(w, kcontrol, event);
-		if (w->shift == 4) {
-			ret |= taiko_codec_enable_anc(w, kcontrol, event);
-			msleep(50);
-		}
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		if (w->shift == 4) {
-			snd_soc_update_bits(codec,
-					TAIKO_A_RX_HPH_CNP_EN, 0x30, 0x30);
-			msleep(30);
-		}
-		ret = taiko_hph_pa_event(w, kcontrol, event);
-		break;
-	case SND_SOC_DAPM_PRE_PMD:
-		if (w->shift == 5) {
-			snd_soc_update_bits(codec,
-					TAIKO_A_RX_HPH_CNP_EN, 0x30, 0x00);
-			msleep(40);
-			snd_soc_update_bits(codec,
-					TAIKO_A_TX_7_MBHC_EN, 0x80, 00);
-			ret |= taiko_codec_enable_anc(w, kcontrol, event);
-		}
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		ret = taiko_hph_pa_event(w, kcontrol, event);
-		break;
-	}
-	return ret;
-}
-
-static const struct snd_soc_dapm_widget taiko_dapm_i2s_widgets[] = {
-	SND_SOC_DAPM_SUPPLY("RX_I2S_CLK", TAIKO_A_CDC_CLK_RX_I2S_CTL,
-	4, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("TX_I2S_CLK", TAIKO_A_CDC_CLK_TX_I2S_CTL, 4,
-	0, NULL, 0),
-};
-
-static int taiko_lineout_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
-						 WCD9XXX_CLSH_STATE_LO,
-						 WCD9XXX_CLSH_REQ_ENABLE,
-						 WCD9XXX_CLSH_EVENT_PRE_DAC);
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x40);
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, w->reg, 0x40, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_spk_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-	return 0;
-}
-
-static const struct snd_soc_dapm_route audio_i2s_map[] = {
-	{"SLIM RX1", NULL, "RX_I2S_CLK"},
-	{"SLIM RX2", NULL, "RX_I2S_CLK"},
-	{"SLIM RX3", NULL, "RX_I2S_CLK"},
-	{"SLIM RX4", NULL, "RX_I2S_CLK"},
-
-	{"SLIM TX7 MUX", NULL, "TX_I2S_CLK"},
-	{"SLIM TX8 MUX", NULL, "TX_I2S_CLK"},
-	{"SLIM TX9 MUX", NULL, "TX_I2S_CLK"},
-	{"SLIM TX10 MUX", NULL, "TX_I2S_CLK"},
-};
-
-static const struct snd_soc_dapm_route audio_i2s_map_1_0[] = {
-	{"RX_I2S_CLK", NULL, "CDC_CONN"},
-};
-
-static const struct snd_soc_dapm_route audio_i2s_map_2_0[] = {
-	{"RX_I2S_CLK", NULL, "CDC_I2S_RX_CONN"},
-};
-
-static const struct snd_soc_dapm_route audio_map[] = {
-	/* SLIMBUS Connections */
-	{"AIF1 CAP", NULL, "AIF1_CAP Mixer"},
-	{"AIF2 CAP", NULL, "AIF2_CAP Mixer"},
-	{"AIF3 CAP", NULL, "AIF3_CAP Mixer"},
-	/* VI Feedback */
-	{"AIF4 VI", NULL, "VIONOFF"},
-	{"VIONOFF", "Switch", "VIINPUT"},
-
-	/* MAD */
-	{"AIF4 MAD", NULL, "CDC_CONN"},
-	{"MADONOFF", "Switch", "MADINPUT"},
-	{"AIF4 MAD", NULL, "MADONOFF"},
-
-	/* SLIM_MIXER("AIF1_CAP Mixer"),*/
-	{"AIF1_CAP Mixer", "SLIM TX1", "SLIM TX1 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX2", "SLIM TX2 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX3", "SLIM TX3 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX4", "SLIM TX4 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX5", "SLIM TX5 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX6", "SLIM TX6 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX7", "SLIM TX7 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX8", "SLIM TX8 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX9", "SLIM TX9 MUX"},
-	{"AIF1_CAP Mixer", "SLIM TX10", "SLIM TX10 MUX"},
-	/* SLIM_MIXER("AIF2_CAP Mixer"),*/
-	{"AIF2_CAP Mixer", "SLIM TX1", "SLIM TX1 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX2", "SLIM TX2 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX3", "SLIM TX3 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX4", "SLIM TX4 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX5", "SLIM TX5 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX6", "SLIM TX6 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX7", "SLIM TX7 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX8", "SLIM TX8 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX9", "SLIM TX9 MUX"},
-	{"AIF2_CAP Mixer", "SLIM TX10", "SLIM TX10 MUX"},
-	/* SLIM_MIXER("AIF3_CAP Mixer"),*/
-	{"AIF3_CAP Mixer", "SLIM TX1", "SLIM TX1 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX2", "SLIM TX2 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX3", "SLIM TX3 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX4", "SLIM TX4 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX5", "SLIM TX5 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX6", "SLIM TX6 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX7", "SLIM TX7 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX8", "SLIM TX8 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX9", "SLIM TX9 MUX"},
-	{"AIF3_CAP Mixer", "SLIM TX10", "SLIM TX10 MUX"},
-
-	{"SLIM TX1 MUX", "DEC1", "DEC1 MUX"},
-
-	{"SLIM TX2 MUX", "DEC2", "DEC2 MUX"},
-
-	{"SLIM TX3 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX3 MUX", "RMIX1", "RX1 MIX1"},
-	{"SLIM TX3 MUX", "RMIX2", "RX2 MIX1"},
-	{"SLIM TX3 MUX", "RMIX3", "RX3 MIX1"},
-	{"SLIM TX3 MUX", "RMIX4", "RX4 MIX1"},
-	{"SLIM TX3 MUX", "RMIX5", "RX5 MIX1"},
-	{"SLIM TX3 MUX", "RMIX6", "RX6 MIX1"},
-	{"SLIM TX3 MUX", "RMIX7", "RX7 MIX1"},
-
-	{"SLIM TX4 MUX", "DEC4", "DEC4 MUX"},
-
-	{"SLIM TX5 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX5 MUX", "RMIX1", "RX1 MIX1"},
-	{"SLIM TX5 MUX", "RMIX2", "RX2 MIX1"},
-	{"SLIM TX5 MUX", "RMIX3", "RX3 MIX1"},
-	{"SLIM TX5 MUX", "RMIX4", "RX4 MIX1"},
-	{"SLIM TX5 MUX", "RMIX5", "RX5 MIX1"},
-	{"SLIM TX5 MUX", "RMIX6", "RX6 MIX1"},
-	{"SLIM TX5 MUX", "RMIX7", "RX7 MIX1"},
-
-	{"SLIM TX6 MUX", "DEC6", "DEC6 MUX"},
-
-	{"SLIM TX7 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX7 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX7 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX7 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX7 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX7 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX7 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX7 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX7 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX7 MUX", "DEC10", "DEC10 MUX"},
-	{"SLIM TX7 MUX", "RMIX1", "RX1 MIX1"},
-	{"SLIM TX7 MUX", "RMIX2", "RX2 MIX1"},
-	{"SLIM TX7 MUX", "RMIX3", "RX3 MIX1"},
-	{"SLIM TX7 MUX", "RMIX4", "RX4 MIX1"},
-	{"SLIM TX7 MUX", "RMIX5", "RX5 MIX1"},
-	{"SLIM TX7 MUX", "RMIX6", "RX6 MIX1"},
-	{"SLIM TX7 MUX", "RMIX7", "RX7 MIX1"},
-
-	{"SLIM TX8 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX8 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX8 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX8 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX8 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX8 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX8 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX8 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX8 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX8 MUX", "DEC10", "DEC10 MUX"},
-
-	{"SLIM TX9 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX9 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX9 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX9 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX9 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX9 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX9 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX9 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX9 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX9 MUX", "DEC10", "DEC10 MUX"},
-
-	{"SLIM TX10 MUX", "DEC1", "DEC1 MUX"},
-	{"SLIM TX10 MUX", "DEC2", "DEC2 MUX"},
-	{"SLIM TX10 MUX", "DEC3", "DEC3 MUX"},
-	{"SLIM TX10 MUX", "DEC4", "DEC4 MUX"},
-	{"SLIM TX10 MUX", "DEC5", "DEC5 MUX"},
-	{"SLIM TX10 MUX", "DEC6", "DEC6 MUX"},
-	{"SLIM TX10 MUX", "DEC7", "DEC7 MUX"},
-	{"SLIM TX10 MUX", "DEC8", "DEC8 MUX"},
-	{"SLIM TX10 MUX", "DEC9", "DEC9 MUX"},
-	{"SLIM TX10 MUX", "DEC10", "DEC10 MUX"},
-
-	/* Earpiece (RX MIX1) */
-	{"EAR", NULL, "EAR PA"},
-	{"EAR PA", NULL, "EAR_PA_MIXER"},
-	{"EAR_PA_MIXER", NULL, "DAC1"},
-	{"DAC1", NULL, "RX_BIAS"},
-
-	{"ANC EAR", NULL, "ANC EAR PA"},
-	{"ANC EAR PA", NULL, "EAR_PA_MIXER"},
-	{"ANC1 FB MUX", "EAR_HPH_L", "RX1 MIX2"},
-	{"ANC1 FB MUX", "EAR_LINE_1", "RX2 MIX2"},
-
-	/* Headset (RX MIX1 and RX MIX2) */
-	{"HEADPHONE", NULL, "HPHL"},
-	{"HEADPHONE", NULL, "HPHR"},
-
-	{"HPHL", NULL, "HPHL_PA_MIXER"},
-	{"HPHL_PA_MIXER", NULL, "HPHL DAC"},
-	{"HPHL DAC", NULL, "RX_BIAS"},
-
-	{"HPHR", NULL, "HPHR_PA_MIXER"},
-	{"HPHR_PA_MIXER", NULL, "HPHR DAC"},
-	{"HPHR DAC", NULL, "RX_BIAS"},
-
-	{"ANC HEADPHONE", NULL, "ANC HPHL"},
-	{"ANC HEADPHONE", NULL, "ANC HPHR"},
-
-	{"ANC HPHL", NULL, "HPHL_PA_MIXER"},
-	{"ANC HPHR", NULL, "HPHR_PA_MIXER"},
-
-	{"ANC1 MUX", "ADC1", "ADC1"},
-	{"ANC1 MUX", "ADC2", "ADC2"},
-	{"ANC1 MUX", "ADC3", "ADC3"},
-	{"ANC1 MUX", "ADC4", "ADC4"},
-	{"ANC1 MUX", "DMIC1", "DMIC1"},
-	{"ANC1 MUX", "DMIC2", "DMIC2"},
-	{"ANC1 MUX", "DMIC3", "DMIC3"},
-	{"ANC1 MUX", "DMIC4", "DMIC4"},
-	{"ANC1 MUX", "DMIC5", "DMIC5"},
-	{"ANC1 MUX", "DMIC6", "DMIC6"},
-	{"ANC2 MUX", "ADC1", "ADC1"},
-	{"ANC2 MUX", "ADC2", "ADC2"},
-	{"ANC2 MUX", "ADC3", "ADC3"},
-	{"ANC2 MUX", "ADC4", "ADC4"},
-
-	{"ANC HPHR", NULL, "CDC_CONN"},
-
-	{"DAC1", "Switch", "CLASS_H_DSM MUX"},
-	{"HPHL DAC", "Switch", "CLASS_H_DSM MUX"},
-	{"HPHR DAC", NULL, "RX2 CHAIN"},
-
-	{"LINEOUT1", NULL, "LINEOUT1 PA"},
-	{"LINEOUT2", NULL, "LINEOUT2 PA"},
-	{"LINEOUT3", NULL, "LINEOUT3 PA"},
-	{"LINEOUT4", NULL, "LINEOUT4 PA"},
-	{"SPK_OUT", NULL, "SPK PA"},
-
-	{"LINEOUT1 PA", NULL, "LINEOUT1_PA_MIXER"},
-	{"LINEOUT1_PA_MIXER", NULL, "LINEOUT1 DAC"},
-
-	{"LINEOUT2 PA", NULL, "LINEOUT2_PA_MIXER"},
-	{"LINEOUT2_PA_MIXER", NULL, "LINEOUT2 DAC"},
-
-	{"LINEOUT3 PA", NULL, "LINEOUT3_PA_MIXER"},
-	{"LINEOUT3_PA_MIXER", NULL, "LINEOUT3 DAC"},
-
-	{"LINEOUT4 PA", NULL, "LINEOUT4_PA_MIXER"},
-	{"LINEOUT4_PA_MIXER", NULL, "LINEOUT4 DAC"},
-
-	{"LINEOUT1 DAC", NULL, "RX3 MIX1"},
-
-	{"RDAC5 MUX", "DEM3_INV", "RX3 MIX1"},
-	{"RDAC5 MUX", "DEM4", "RX4 MIX1"},
-
-	{"LINEOUT3 DAC", NULL, "RDAC5 MUX"},
-
-	{"LINEOUT2 DAC", NULL, "RX5 MIX1"},
-
-	{"RDAC7 MUX", "DEM5_INV", "RX5 MIX1"},
-	{"RDAC7 MUX", "DEM6", "RX6 MIX1"},
-
-	{"LINEOUT4 DAC", NULL, "RDAC7 MUX"},
-
-	{"SPK PA", NULL, "SPK DAC"},
-	{"SPK DAC", NULL, "RX7 MIX2"},
-	{"SPK DAC", NULL, "VDD_SPKDRV"},
-
-	{"CLASS_H_DSM MUX", "DSM_HPHL_RX1", "RX1 CHAIN"},
-
-	{"RX1 CHAIN", NULL, "RX1 MIX2"},
-	{"RX2 CHAIN", NULL, "RX2 MIX2"},
-
-	{"RX1 MIX2", NULL, "ANC1 MUX"},
-	{"RX2 MIX2", NULL, "ANC2 MUX"},
-
-	{"LINEOUT1 DAC", NULL, "RX_BIAS"},
-	{"LINEOUT2 DAC", NULL, "RX_BIAS"},
-	{"LINEOUT3 DAC", NULL, "RX_BIAS"},
-	{"LINEOUT4 DAC", NULL, "RX_BIAS"},
-	{"SPK DAC", NULL, "RX_BIAS"},
-
-	{"RX7 MIX1", NULL, "COMP0_CLK"},
-	{"RX1 MIX1", NULL, "COMP1_CLK"},
-	{"RX2 MIX1", NULL, "COMP1_CLK"},
-	{"RX3 MIX1", NULL, "COMP2_CLK"},
-	{"RX5 MIX1", NULL, "COMP2_CLK"},
-
-	{"RX1 MIX1", NULL, "RX1 MIX1 INP1"},
-	{"RX1 MIX1", NULL, "RX1 MIX1 INP2"},
-	{"RX1 MIX1", NULL, "RX1 MIX1 INP3"},
-	{"RX2 MIX1", NULL, "RX2 MIX1 INP1"},
-	{"RX2 MIX1", NULL, "RX2 MIX1 INP2"},
-	{"RX3 MIX1", NULL, "RX3 MIX1 INP1"},
-	{"RX3 MIX1", NULL, "RX3 MIX1 INP2"},
-	{"RX4 MIX1", NULL, "RX4 MIX1 INP1"},
-	{"RX4 MIX1", NULL, "RX4 MIX1 INP2"},
-	{"RX5 MIX1", NULL, "RX5 MIX1 INP1"},
-	{"RX5 MIX1", NULL, "RX5 MIX1 INP2"},
-	{"RX6 MIX1", NULL, "RX6 MIX1 INP1"},
-	{"RX6 MIX1", NULL, "RX6 MIX1 INP2"},
-	{"RX7 MIX1", NULL, "RX7 MIX1 INP1"},
-	{"RX7 MIX1", NULL, "RX7 MIX1 INP2"},
-	{"RX1 MIX2", NULL, "RX1 MIX1"},
-	{"RX1 MIX2", NULL, "RX1 MIX2 INP1"},
-	{"RX1 MIX2", NULL, "RX1 MIX2 INP2"},
-	{"RX2 MIX2", NULL, "RX2 MIX1"},
-	{"RX2 MIX2", NULL, "RX2 MIX2 INP1"},
-	{"RX2 MIX2", NULL, "RX2 MIX2 INP2"},
-	{"RX7 MIX2", NULL, "RX7 MIX1"},
-	{"RX7 MIX2", NULL, "RX7 MIX2 INP1"},
-	{"RX7 MIX2", NULL, "RX7 MIX2 INP2"},
-
-	/* SLIM_MUX("AIF1_PB", "AIF1 PB"),*/
-	{"SLIM RX1 MUX", "AIF1_PB", "AIF1 PB"},
-	{"SLIM RX2 MUX", "AIF1_PB", "AIF1 PB"},
-	{"SLIM RX3 MUX", "AIF1_PB", "AIF1 PB"},
-	{"SLIM RX4 MUX", "AIF1_PB", "AIF1 PB"},
-	{"SLIM RX5 MUX", "AIF1_PB", "AIF1 PB"},
-	{"SLIM RX6 MUX", "AIF1_PB", "AIF1 PB"},
-	{"SLIM RX7 MUX", "AIF1_PB", "AIF1 PB"},
-	/* SLIM_MUX("AIF2_PB", "AIF2 PB"),*/
-	{"SLIM RX1 MUX", "AIF2_PB", "AIF2 PB"},
-	{"SLIM RX2 MUX", "AIF2_PB", "AIF2 PB"},
-	{"SLIM RX3 MUX", "AIF2_PB", "AIF2 PB"},
-	{"SLIM RX4 MUX", "AIF2_PB", "AIF2 PB"},
-	{"SLIM RX5 MUX", "AIF2_PB", "AIF2 PB"},
-	{"SLIM RX6 MUX", "AIF2_PB", "AIF2 PB"},
-	{"SLIM RX7 MUX", "AIF2_PB", "AIF2 PB"},
-	/* SLIM_MUX("AIF3_PB", "AIF3 PB"),*/
-	{"SLIM RX1 MUX", "AIF3_PB", "AIF3 PB"},
-	{"SLIM RX2 MUX", "AIF3_PB", "AIF3 PB"},
-	{"SLIM RX3 MUX", "AIF3_PB", "AIF3 PB"},
-	{"SLIM RX4 MUX", "AIF3_PB", "AIF3 PB"},
-	{"SLIM RX5 MUX", "AIF3_PB", "AIF3 PB"},
-	{"SLIM RX6 MUX", "AIF3_PB", "AIF3 PB"},
-	{"SLIM RX7 MUX", "AIF3_PB", "AIF3 PB"},
-
-	{"SLIM RX1", NULL, "SLIM RX1 MUX"},
-	{"SLIM RX2", NULL, "SLIM RX2 MUX"},
-	{"SLIM RX3", NULL, "SLIM RX3 MUX"},
-	{"SLIM RX4", NULL, "SLIM RX4 MUX"},
-	{"SLIM RX5", NULL, "SLIM RX5 MUX"},
-	{"SLIM RX6", NULL, "SLIM RX6 MUX"},
-	{"SLIM RX7", NULL, "SLIM RX7 MUX"},
-
-	{"RX1 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX1 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX1 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX1 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX1 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX1 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX1 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX1 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX1 MIX1 INP1", "IIR2", "IIR2"},
-	{"RX1 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX1 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX1 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX1 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX1 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX1 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX1 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX1 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX1 MIX1 INP2", "IIR2", "IIR2"},
-	{"RX1 MIX1 INP3", "RX1", "SLIM RX1"},
-	{"RX1 MIX1 INP3", "RX2", "SLIM RX2"},
-	{"RX1 MIX1 INP3", "RX3", "SLIM RX3"},
-	{"RX1 MIX1 INP3", "RX4", "SLIM RX4"},
-	{"RX1 MIX1 INP3", "RX5", "SLIM RX5"},
-	{"RX1 MIX1 INP3", "RX6", "SLIM RX6"},
-	{"RX1 MIX1 INP3", "RX7", "SLIM RX7"},
-	{"RX2 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX2 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX2 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX2 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX2 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX2 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX2 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX2 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX2 MIX1 INP1", "IIR2", "IIR2"},
-	{"RX2 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX2 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX2 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX2 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX2 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX2 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX2 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX2 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX2 MIX1 INP2", "IIR2", "IIR2"},
-	{"RX3 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX3 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX3 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX3 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX3 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX3 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX3 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX3 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX3 MIX1 INP1", "IIR2", "IIR2"},
-	{"RX3 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX3 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX3 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX3 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX3 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX3 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX3 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX3 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX3 MIX1 INP2", "IIR2", "IIR2"},
-	{"RX4 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX4 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX4 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX4 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX4 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX4 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX4 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX4 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX4 MIX1 INP1", "IIR2", "IIR2"},
-	{"RX4 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX4 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX4 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX4 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX4 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX4 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX4 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX4 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX4 MIX1 INP2", "IIR2", "IIR2"},
-	{"RX5 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX5 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX5 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX5 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX5 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX5 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX5 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX5 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX5 MIX1 INP1", "IIR2", "IIR2"},
-	{"RX5 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX5 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX5 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX5 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX5 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX5 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX5 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX5 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX5 MIX1 INP2", "IIR2", "IIR2"},
-	{"RX6 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX6 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX6 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX6 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX6 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX6 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX6 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX6 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX6 MIX1 INP1", "IIR2", "IIR2"},
-	{"RX6 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX6 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX6 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX6 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX6 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX6 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX6 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX6 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX6 MIX1 INP2", "IIR2", "IIR2"},
-	{"RX7 MIX1 INP1", "RX1", "SLIM RX1"},
-	{"RX7 MIX1 INP1", "RX2", "SLIM RX2"},
-	{"RX7 MIX1 INP1", "RX3", "SLIM RX3"},
-	{"RX7 MIX1 INP1", "RX4", "SLIM RX4"},
-	{"RX7 MIX1 INP1", "RX5", "SLIM RX5"},
-	{"RX7 MIX1 INP1", "RX6", "SLIM RX6"},
-	{"RX7 MIX1 INP1", "RX7", "SLIM RX7"},
-	{"RX7 MIX1 INP1", "IIR1", "IIR1"},
-	{"RX7 MIX1 INP1", "IIR2", "IIR2"},
-	{"RX7 MIX1 INP2", "RX1", "SLIM RX1"},
-	{"RX7 MIX1 INP2", "RX2", "SLIM RX2"},
-	{"RX7 MIX1 INP2", "RX3", "SLIM RX3"},
-	{"RX7 MIX1 INP2", "RX4", "SLIM RX4"},
-	{"RX7 MIX1 INP2", "RX5", "SLIM RX5"},
-	{"RX7 MIX1 INP2", "RX6", "SLIM RX6"},
-	{"RX7 MIX1 INP2", "RX7", "SLIM RX7"},
-	{"RX7 MIX1 INP2", "IIR1", "IIR1"},
-	{"RX7 MIX1 INP2", "IIR2", "IIR2"},
-
-	/* IIR1, IIR2 inputs to Second RX Mixer on RX1, RX2 and RX7 chains. */
-	{"RX1 MIX2 INP1", "IIR1", "IIR1"},
-	{"RX1 MIX2 INP2", "IIR1", "IIR1"},
-	{"RX2 MIX2 INP1", "IIR1", "IIR1"},
-	{"RX2 MIX2 INP2", "IIR1", "IIR1"},
-	{"RX7 MIX2 INP1", "IIR1", "IIR1"},
-	{"RX7 MIX2 INP2", "IIR1", "IIR1"},
-	{"RX1 MIX2 INP1", "IIR2", "IIR2"},
-	{"RX1 MIX2 INP2", "IIR2", "IIR2"},
-	{"RX2 MIX2 INP1", "IIR2", "IIR2"},
-	{"RX2 MIX2 INP2", "IIR2", "IIR2"},
-	{"RX7 MIX2 INP1", "IIR2", "IIR2"},
-	{"RX7 MIX2 INP2", "IIR2", "IIR2"},
-
-	/* Decimator Inputs */
-	{"DEC1 MUX", "DMIC1", "DMIC1"},
-	{"DEC1 MUX", "ADC6", "ADC6"},
-	{"DEC1 MUX", NULL, "CDC_CONN"},
-	{"DEC2 MUX", "DMIC2", "DMIC2"},
-	{"DEC2 MUX", "ADC5", "ADC5"},
-	{"DEC2 MUX", NULL, "CDC_CONN"},
-	{"DEC3 MUX", "DMIC3", "DMIC3"},
-	{"DEC3 MUX", "ADC4", "ADC4"},
-	{"DEC3 MUX", NULL, "CDC_CONN"},
-	{"DEC4 MUX", "DMIC4", "DMIC4"},
-	{"DEC4 MUX", "ADC3", "ADC3"},
-	{"DEC4 MUX", NULL, "CDC_CONN"},
-	{"DEC5 MUX", "DMIC5", "DMIC5"},
-	{"DEC5 MUX", "ADC2", "ADC2"},
-	{"DEC5 MUX", NULL, "CDC_CONN"},
-	{"DEC6 MUX", "DMIC6", "DMIC6"},
-	{"DEC6 MUX", "ADC1", "ADC1"},
-	{"DEC6 MUX", NULL, "CDC_CONN"},
-	{"DEC7 MUX", "DMIC1", "DMIC1"},
-	{"DEC7 MUX", "DMIC6", "DMIC6"},
-	{"DEC7 MUX", "ADC1", "ADC1"},
-	{"DEC7 MUX", "ADC6", "ADC6"},
-	{"DEC7 MUX", NULL, "CDC_CONN"},
-	{"DEC8 MUX", "DMIC2", "DMIC2"},
-	{"DEC8 MUX", "DMIC5", "DMIC5"},
-	{"DEC8 MUX", "ADC2", "ADC2"},
-	{"DEC8 MUX", "ADC5", "ADC5"},
-	{"DEC8 MUX", NULL, "CDC_CONN"},
-	{"DEC9 MUX", "DMIC4", "DMIC4"},
-	{"DEC9 MUX", "DMIC5", "DMIC5"},
-	{"DEC9 MUX", "ADC2", "ADC2"},
-	{"DEC9 MUX", "ADC3", "ADC3"},
-	{"DEC9 MUX", NULL, "CDC_CONN"},
-	{"DEC10 MUX", "DMIC3", "DMIC3"},
-	{"DEC10 MUX", "DMIC6", "DMIC6"},
-	{"DEC10 MUX", "ADC1", "ADC1"},
-	{"DEC10 MUX", "ADC4", "ADC4"},
-	{"DEC10 MUX", NULL, "CDC_CONN"},
-
-	/* ADC Connections */
-	{"ADC1", NULL, "AMIC1"},
-	{"ADC2", NULL, "AMIC2"},
-	{"ADC3", NULL, "AMIC3"},
-	{"ADC4", NULL, "AMIC4"},
-	{"ADC5", NULL, "AMIC5"},
-	{"ADC6", NULL, "AMIC6"},
-
-	/* AUX PGA Connections */
-	{"EAR_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"HPHL_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"HPHR_PA_MIXER", "AUX_PGA_R Switch", "AUX_PGA_Right"},
-	{"LINEOUT1_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"LINEOUT2_PA_MIXER", "AUX_PGA_R Switch", "AUX_PGA_Right"},
-	{"LINEOUT3_PA_MIXER", "AUX_PGA_L Switch", "AUX_PGA_Left"},
-	{"LINEOUT4_PA_MIXER", "AUX_PGA_R Switch", "AUX_PGA_Right"},
-	{"AUX_PGA_Left", NULL, "AMIC5"},
-	{"AUX_PGA_Right", NULL, "AMIC6"},
-
-	{"IIR1", NULL, "IIR1 INP1 MUX"},
-	{"IIR1 INP1 MUX", "DEC1", "DEC1 MUX"},
-	{"IIR1 INP1 MUX", "DEC2", "DEC2 MUX"},
-	{"IIR1 INP1 MUX", "DEC3", "DEC3 MUX"},
-	{"IIR1 INP1 MUX", "DEC4", "DEC4 MUX"},
-	{"IIR1 INP1 MUX", "DEC5", "DEC5 MUX"},
-	{"IIR1 INP1 MUX", "DEC6", "DEC6 MUX"},
-	{"IIR1 INP1 MUX", "DEC7", "DEC7 MUX"},
-	{"IIR1 INP1 MUX", "DEC8", "DEC8 MUX"},
-	{"IIR1 INP1 MUX", "DEC9", "DEC9 MUX"},
-	{"IIR1 INP1 MUX", "DEC10", "DEC10 MUX"},
-	{"IIR1 INP1 MUX", "RX1", "SLIM RX1"},
-	{"IIR1 INP1 MUX", "RX2", "SLIM RX2"},
-	{"IIR1 INP1 MUX", "RX3", "SLIM RX3"},
-	{"IIR1 INP1 MUX", "RX4", "SLIM RX4"},
-	{"IIR1 INP1 MUX", "RX5", "SLIM RX5"},
-	{"IIR1 INP1 MUX", "RX6", "SLIM RX6"},
-	{"IIR1 INP1 MUX", "RX7", "SLIM RX7"},
-
-	{"IIR2", NULL, "IIR2 INP1 MUX"},
-	{"IIR2 INP1 MUX", "DEC1", "DEC1 MUX"},
-	{"IIR2 INP1 MUX", "DEC2", "DEC2 MUX"},
-	{"IIR2 INP1 MUX", "DEC3", "DEC3 MUX"},
-	{"IIR2 INP1 MUX", "DEC4", "DEC4 MUX"},
-	{"IIR2 INP1 MUX", "DEC5", "DEC5 MUX"},
-	{"IIR2 INP1 MUX", "DEC6", "DEC6 MUX"},
-	{"IIR2 INP1 MUX", "DEC7", "DEC7 MUX"},
-	{"IIR2 INP1 MUX", "DEC8", "DEC8 MUX"},
-	{"IIR2 INP1 MUX", "DEC9", "DEC9 MUX"},
-	{"IIR2 INP1 MUX", "DEC10", "DEC10 MUX"},
-	{"IIR2 INP1 MUX", "RX1", "SLIM RX1"},
-	{"IIR2 INP1 MUX", "RX2", "SLIM RX2"},
-	{"IIR2 INP1 MUX", "RX3", "SLIM RX3"},
-	{"IIR2 INP1 MUX", "RX4", "SLIM RX4"},
-	{"IIR2 INP1 MUX", "RX5", "SLIM RX5"},
-	{"IIR2 INP1 MUX", "RX6", "SLIM RX6"},
-	{"IIR2 INP1 MUX", "RX7", "SLIM RX7"},
-
-	{"MIC BIAS1 Internal1", NULL, "LDO_H"},
-	{"MIC BIAS1 Internal2", NULL, "LDO_H"},
-	{"MIC BIAS1 External", NULL, "LDO_H"},
-	{"MIC BIAS2 Internal1", NULL, "LDO_H"},
-	{"MIC BIAS2 Internal2", NULL, "LDO_H"},
-	{"MIC BIAS2 Internal3", NULL, "LDO_H"},
-	{"MIC BIAS2 External", NULL, "LDO_H"},
-	{"MIC BIAS3 Internal1", NULL, "LDO_H"},
-	{"MIC BIAS3 Internal2", NULL, "LDO_H"},
-	{"MIC BIAS3 External", NULL, "LDO_H"},
-	{"MIC BIAS4 External", NULL, "LDO_H"},
-	{"Main Mic Bias", NULL, "LDO_H"},
-	{DAPM_MICBIAS2_EXTERNAL_STANDALONE, NULL, "LDO_H Standalone"},
-	{DAPM_MICBIAS3_EXTERNAL_STANDALONE, NULL, "LDO_H Standalone"},
-	{"Ear Mic Bias", NULL, "LDO_H"},
-};
-
-static int taiko_readable(struct snd_soc_codec *ssc, unsigned int reg)
-{
-	return taiko_reg_readable[reg];
-}
-
-static bool taiko_is_digital_gain_register(unsigned int reg)
-{
-	bool rtn = false;
-	switch (reg) {
-	case TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL:
-	case TAIKO_A_CDC_TX1_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX2_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX3_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX4_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX5_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX6_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX7_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX8_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX9_VOL_CTL_GAIN:
-	case TAIKO_A_CDC_TX10_VOL_CTL_GAIN:
-		rtn = true;
-		break;
-	default:
-		break;
-	}
-	return rtn;
-}
-
-static int taiko_volatile(struct snd_soc_codec *ssc, unsigned int reg)
-{
-	int i;
-
-	/* Registers lower than 0x100 are top level registers which can be
-	 * written by the Taiko core driver.
-	 */
-
-	if ((reg >= TAIKO_A_CDC_MBHC_EN_CTL) || (reg < 0x100))
-		return 1;
-
-	/* IIR Coeff registers are not cacheable */
-	if ((reg >= TAIKO_A_CDC_IIR1_COEF_B1_CTL) &&
-		(reg <= TAIKO_A_CDC_IIR2_COEF_B2_CTL))
-		return 1;
-
-	/* ANC filter registers are not cacheable */
-	if ((reg >= TAIKO_A_CDC_ANC1_IIR_B1_CTL) &&
-		(reg <= TAIKO_A_CDC_ANC1_LPF_B2_CTL))
-		return 1;
-	if ((reg >= TAIKO_A_CDC_ANC2_IIR_B1_CTL) &&
-		(reg <= TAIKO_A_CDC_ANC2_LPF_B2_CTL))
-		return 1;
-
-	/* Digital gain register is not cacheable so we have to write
-	 * the setting even it is the same
-	 */
-	if (taiko_is_digital_gain_register(reg))
-		return 1;
-
-	/* HPH status registers */
-	if (reg == TAIKO_A_RX_HPH_L_STATUS || reg == TAIKO_A_RX_HPH_R_STATUS)
-		return 1;
-
-	/* HPH PA Enable */
-	if (reg == TAIKO_A_RX_HPH_CNP_EN)
-		return 1;
-
-	if (reg == TAIKO_A_MBHC_INSERT_DET_STATUS)
-		return 1;
-
-	switch (reg) {
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL0:
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL1:
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL2:
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL3:
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL4:
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL5:
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL6:
-	case TAIKO_A_CDC_SPKR_CLIPDET_VAL7:
-	case TAIKO_A_CDC_VBAT_GAIN_MON_VAL:
-		return 1;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(audio_reg_cfg); i++)
-		if (audio_reg_cfg[i].reg_logical_addr -
-		    TAIKO_REGISTER_START_OFFSET == reg)
-			return 1;
-
-	return 0;
-}
-
-static int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
-	unsigned int value)
-{
-	int ret;
-	struct wcd9xxx *wcd9xxx = codec->control_data;
-
-	if (reg == SND_SOC_NOPM)
-		return 0;
-
-	BUG_ON(reg > TAIKO_MAX_REGISTER);
-
-	if (!taiko_volatile(codec, reg)) {
-		ret = snd_soc_cache_write(codec, reg, value);
-		if (ret != 0)
-			dev_err(codec->dev, "Cache write to %x failed: %d\n",
-				reg, ret);
-	}
-
-	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, value);
-}
-static unsigned int taiko_read(struct snd_soc_codec *codec,
-				unsigned int reg)
-{
-	unsigned int val;
-	int ret;
-
-	struct wcd9xxx *wcd9xxx = codec->control_data;
-
-	if (reg == SND_SOC_NOPM)
-		return 0;
-
-	BUG_ON(reg > TAIKO_MAX_REGISTER);
-
-	if (!taiko_volatile(codec, reg) && taiko_readable(codec, reg) &&
-		reg < codec->driver->reg_cache_size) {
-		ret = snd_soc_cache_read(codec, reg, &val);
-		if (ret >= 0) {
-			return val;
-		} else
-			dev_err(codec->dev, "Cache read from %x failed: %d\n",
-				reg, ret);
-	}
-
-	val = wcd9xxx_reg_read(&wcd9xxx->core_res, reg);
-	return val;
-}
-
-#ifdef CONFIG_SND_SOC_ES325
-static int taiko_startup(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	struct wcd9xxx *taiko_core = dev_get_drvdata(dai->codec->dev->parent);
-	pr_debug("%s(): substream = %s  stream = %d\n" , __func__,
-		 substream->name, substream->stream);
-	if ((taiko_core != NULL) &&
-	    (taiko_core->dev != NULL) &&
-	    (taiko_core->dev->parent != NULL)) {
-		es325_wrapper_wakeup(dai);
-	}
-
-	return 0;
-}
-#else
-static int taiko_startup(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-//	struct wcd9xxx *taiko_core = dev_get_drvdata(dai->codec->dev->parent);
-	pr_debug("%s(): substream = %s  stream = %d\n" , __func__,
-		 substream->name, substream->stream);
-	return 0;
-}
-#endif
-
-static void taiko_shutdown(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	struct wcd9xxx *taiko_core = dev_get_drvdata(dai->codec->dev->parent);
-	pr_debug("%s(): substream = %s  stream = %d\n" , __func__,
-		 substream->name, substream->stream);
-	if ((taiko_core != NULL) &&
-	    (taiko_core->dev != NULL) &&
-	    (taiko_core->dev->parent != NULL)) {
-#ifdef CONFIG_SND_SOC_ES325
-		es325_wrapper_sleep(dai->id);
-#endif
-	}
-}
-
-static int taiko_prepare(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	int paths, i;
-	struct snd_soc_dapm_widget_list *wlist;
-	struct snd_soc_codec *codec = dai->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	int found_hs_pa = 0;
-
-	if (substream->stream)
-		return 0;
-
-	pr_debug("%s(): substream = %s. stream = %d. dai->name = %s."
-		" dai->driver->name = %s. dai stream_name = %s\n",
-		__func__, substream->name, substream->stream,
-		dai->name, dai->driver->name,
-		substream->stream ? dai->driver->capture.stream_name :
-		dai->driver->playback.stream_name);
-
-	pr_debug("%s(): dai AIF widget = %s. dai playback stream_name = %s.\n"
-		"  rate = %u. bit_width = %u.  hs compander_enabled = %u\n",
-		__func__, dai->playback_aif ? dai->playback_aif->name : "NULL",
-		dai->driver->playback.stream_name, taiko_p->dai[dai->id].rate,
-			taiko_p->dai[dai->id].bit_width,
-			taiko_p->comp_enabled[COMPANDER_1]);
-
-	if ((!(taiko_p->dai[dai->id].rate == 192000 ||
-		 taiko_p->dai[dai->id].rate == 96000)) ||
-	    !(taiko_p->dai[dai->id].bit_width == 24) ||
-	    !(taiko_p->comp_enabled[COMPANDER_1])) {
-
-		taiko_p->clsh_d.hs_perf_mode_enabled = false;
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_CHOP_CTL, 0x20, 0x20);
-
-		dev_dbg(dai->dev ,"%s(): high performnce mode not needed\n",
-				__func__);
-		return 0;
-	}
-
-	paths = snd_soc_dapm_codec_dai_get_playback_connected_widgets(dai, &wlist);
-
-	if (!paths) {
-		dev_err(dai->dev, "%s(): found no audio playback paths\n",
-			__func__);
-		return 0;
-	}
-
-	for (i = 0; i < wlist->num_widgets; i++) {
-		dev_dbg(dai->dev, " dai stream_name = %s, widget name = %s\n",
-			dai->driver->playback.stream_name, wlist->widgets[i]->name);
-
-		if (!strcmp(wlist->widgets[i]->name, "HPHL") ||
-		    !strcmp(wlist->widgets[i]->name, "HPHR")) {
-			found_hs_pa = 1;
-			break;
-		}
-	}
-
-	kfree(wlist);
-
-	if (!found_hs_pa)
-		return 0;
-
-	pr_debug("%s(): rate = %u. bit_width = %u.  hs compander_enabled = %u",
-			__func__, taiko_p->dai[dai->id].rate,
-			taiko_p->dai[dai->id].bit_width,
-			taiko_p->comp_enabled[COMPANDER_1]);
-
-	if ((taiko_p->dai[dai->id].rate == 192000 ||
-		taiko_p->dai[dai->id].rate == 96000) &&
-	    (taiko_p->dai[dai->id].bit_width == 24) &&
-	    (taiko_p->comp_enabled[COMPANDER_1])) {
-
-		pr_debug("%s(): HS peformance mode enabled", __func__);
-		taiko_p->clsh_d.hs_perf_mode_enabled = true;
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_CHOP_CTL, 0x20, 0x00);
-	} else {
-		taiko_p->clsh_d.hs_perf_mode_enabled = false;
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_CHOP_CTL, 0x20, 0x20);
-	}
-
-	return 0;
-}
-
-int taiko_mclk_enable(struct snd_soc_codec *codec, int mclk_enable, bool dapm)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s: mclk_enable = %u, dapm = %d\n", __func__, mclk_enable,
-		 dapm);
-
-	WCD9XXX_BG_CLK_LOCK(&taiko->resmgr);
-	if (mclk_enable) {
-		wcd9xxx_resmgr_get_bandgap(&taiko->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-		wcd9xxx_resmgr_get_clk_block(&taiko->resmgr, WCD9XXX_CLK_MCLK);
-	} else {
-		/* Put clock and BG */
-		wcd9xxx_resmgr_put_clk_block(&taiko->resmgr, WCD9XXX_CLK_MCLK);
-		wcd9xxx_resmgr_put_bandgap(&taiko->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-	}
-	WCD9XXX_BG_CLK_UNLOCK(&taiko->resmgr);
-
-	return 0;
-}
-
-static int taiko_set_dai_sysclk(struct snd_soc_dai *dai,
-		int clk_id, unsigned int freq, int dir)
-{
-	pr_debug("%s\n", __func__);
-	return 0;
-}
-
-static int taiko_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
-{
-	u8 val = 0;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(dai->codec);
-
-	pr_debug("%s\n", __func__);
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBS_CFS:
-		/* CPU is master */
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			if (dai->id == AIF1_CAP)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL,
-					TAIKO_I2S_MASTER_MODE_MASK, 0);
-			else if (dai->id == AIF1_PB)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL,
-					TAIKO_I2S_MASTER_MODE_MASK, 0);
-		}
-		break;
-	case SND_SOC_DAIFMT_CBM_CFM:
-	/* CPU is slave */
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			val = TAIKO_I2S_MASTER_MODE_MASK;
-			if (dai->id == AIF1_CAP)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL, val, val);
-			else if (dai->id == AIF1_PB)
-				snd_soc_update_bits(dai->codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL, val, val);
-		}
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int taiko_set_channel_map(struct snd_soc_dai *dai,
-				unsigned int tx_num, unsigned int *tx_slot,
-				unsigned int rx_num, unsigned int *rx_slot)
-
-{
-	struct wcd9xxx_codec_dai_data *dai_data = NULL;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(dai->codec);
-	struct wcd9xxx *core = dev_get_drvdata(dai->codec->dev->parent);
-	if (!tx_slot && !rx_slot) {
-		pr_err("%s: Invalid\n", __func__);
-		return -EINVAL;
-	}
-	pr_debug("%s(): dai_name = %s DAI-ID %x tx_ch %d rx_ch %d\n"
-		 "taiko->intf_type %d\n",
-		 __func__, dai->name, dai->id, tx_num, rx_num,
-		 taiko->intf_type);
-
-	if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
-		wcd9xxx_init_slimslave(core, core->slim->laddr,
-					   tx_num, tx_slot, rx_num, rx_slot);
-		/*Reserve tx11 and tx12 for VI feedback path*/
-		dai_data = &taiko->dai[AIF4_VIFEED];
-		if (dai_data) {
-			list_add_tail(&core->tx_chs[TAIKO_TX11].list,
-			&dai_data->wcd9xxx_ch_list);
-			list_add_tail(&core->tx_chs[TAIKO_TX12].list,
-			&dai_data->wcd9xxx_ch_list);
-		}
-	}
-	return 0;
-}
-
-static int taiko_get_channel_map(struct snd_soc_dai *dai,
-				 unsigned int *tx_num, unsigned int *tx_slot,
-				 unsigned int *rx_num, unsigned int *rx_slot)
-
-{
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(dai->codec);
-	u32 i = 0;
-	struct wcd9xxx_ch *ch;
-
-	switch (dai->id) {
-	case AIF1_PB:
-	case AIF2_PB:
-	case AIF3_PB:
-		if (!rx_slot || !rx_num) {
-			pr_err("%s: Invalid rx_slot %d or rx_num %d\n",
-				 __func__, (u32) rx_slot, (u32) rx_num);
-			return -EINVAL;
-		}
-		list_for_each_entry(ch, &taiko_p->dai[dai->id].wcd9xxx_ch_list,
-				    list) {
-			pr_debug("%s: slot_num %u ch->ch_num %d\n",
-				 __func__, i, ch->ch_num);
-			rx_slot[i++] = ch->ch_num;
-		}
-		pr_debug("%s: rx_num %d\n", __func__, i);
-		*rx_num = i;
-		break;
-	case AIF1_CAP:
-	case AIF2_CAP:
-	case AIF3_CAP:
-	case AIF4_VIFEED:
-	case AIF4_MAD_TX:
-		if (!tx_slot || !tx_num) {
-			pr_err("%s: Invalid tx_slot %d or tx_num %d\n",
-				 __func__, (u32) tx_slot, (u32) tx_num);
-			return -EINVAL;
-		}
-		list_for_each_entry(ch, &taiko_p->dai[dai->id].wcd9xxx_ch_list,
-				    list) {
-			pr_debug("%s: slot_num %u ch->ch_num %d\n",
-				 __func__, i,  ch->ch_num);
-			tx_slot[i++] = ch->ch_num;
-		}
-		pr_debug("%s: tx_num %d\n", __func__, i);
-		*tx_num = i;
-		break;
-
-	default:
-		pr_err("%s: Invalid DAI ID %x\n", __func__, dai->id);
-		break;
-	}
-
-	return 0;
-}
-
-static int taiko_set_interpolator_rate(struct snd_soc_dai *dai,
-	u8 rx_fs_rate_reg_val, u32 compander_fs, u32 sample_rate)
-{
-	u32 j;
-	u8 rx_mix1_inp;
-	u16 rx_mix_1_reg_1, rx_mix_1_reg_2;
-	u16 rx_fs_reg;
-	u8 rx_mix_1_reg_1_val, rx_mix_1_reg_2_val;
-	struct snd_soc_codec *codec = dai->codec;
-	struct wcd9xxx_ch *ch;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-
-	list_for_each_entry(ch, &taiko->dai[dai->id].wcd9xxx_ch_list, list) {
-		/* for RX port starting from 16 instead of 10 like tabla */
-		rx_mix1_inp = ch->port + RX_MIX1_INP_SEL_RX1 -
-			      TAIKO_TX_PORT_NUMBER;
-		if ((rx_mix1_inp < RX_MIX1_INP_SEL_RX1) ||
-			(rx_mix1_inp > RX_MIX1_INP_SEL_RX7)) {
-			pr_err("%s: Invalid TAIKO_RX%u port. Dai ID is %d\n",
-				__func__,  rx_mix1_inp - 5 , dai->id);
-			return -EINVAL;
-		}
-
-		rx_mix_1_reg_1 = TAIKO_A_CDC_CONN_RX1_B1_CTL;
-
-		for (j = 0; j < NUM_INTERPOLATORS; j++) {
-			rx_mix_1_reg_2 = rx_mix_1_reg_1 + 1;
-
-			rx_mix_1_reg_1_val = snd_soc_read(codec,
-							  rx_mix_1_reg_1);
-			rx_mix_1_reg_2_val = snd_soc_read(codec,
-							  rx_mix_1_reg_2);
-
-			if (((rx_mix_1_reg_1_val & 0x0F) == rx_mix1_inp) ||
-			    (((rx_mix_1_reg_1_val >> 4) & 0x0F)
-				== rx_mix1_inp) ||
-			    ((rx_mix_1_reg_2_val & 0x0F) == rx_mix1_inp)) {
-
-				rx_fs_reg = TAIKO_A_CDC_RX1_B5_CTL + 8 * j;
-
-				pr_debug("%s: AIF_PB DAI(%d) connected to RX%u\n",
-					__func__, dai->id, j + 1);
-
-				pr_debug("%s: set RX%u sample rate to %u\n",
-					__func__, j + 1, sample_rate);
-
-				snd_soc_update_bits(codec, rx_fs_reg,
-						0xE0, rx_fs_rate_reg_val);
-
-				if (comp_rx_path[j] < COMPANDER_MAX)
-					taiko->comp_fs[comp_rx_path[j]]
-					= compander_fs;
-			}
-			if (j < 2)
-				rx_mix_1_reg_1 += 3;
-			else
-				rx_mix_1_reg_1 += 2;
-		}
-	}
-	return 0;
-}
-
-static int taiko_set_decimator_rate(struct snd_soc_dai *dai,
-	u8 tx_fs_rate_reg_val, u32 sample_rate)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	struct wcd9xxx_ch *ch;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	u32 tx_port;
-	u16 tx_port_reg, tx_fs_reg;
-	u8 tx_port_reg_val;
-	s8 decimator;
-
-	list_for_each_entry(ch, &taiko->dai[dai->id].wcd9xxx_ch_list, list) {
-
-		tx_port = ch->port + 1;
-		pr_debug("%s: dai->id = %d, tx_port = %d",
-			__func__, dai->id, tx_port);
-
-		if ((tx_port < 1) || (tx_port > NUM_DECIMATORS)) {
-			pr_err("%s: Invalid SLIM TX%u port. DAI ID is %d\n",
-				__func__, tx_port, dai->id);
-			return -EINVAL;
-		}
-
-		tx_port_reg = TAIKO_A_CDC_CONN_TX_SB_B1_CTL + (tx_port - 1);
-		tx_port_reg_val =  snd_soc_read(codec, tx_port_reg);
-
-		decimator = 0;
-
-		if ((tx_port >= 1) && (tx_port <= 6)) {
-
-			tx_port_reg_val =  tx_port_reg_val & 0x0F;
-			if (tx_port_reg_val == 0x8)
-				decimator = tx_port;
-
-		} else if ((tx_port >= 7) && (tx_port <= NUM_DECIMATORS)) {
-
-			tx_port_reg_val =  tx_port_reg_val & 0x1F;
-
-			if ((tx_port_reg_val >= 0x8) &&
-			    (tx_port_reg_val <= 0x11)) {
-
-				decimator = (tx_port_reg_val - 0x8) + 1;
-			}
-		}
-
-		if (decimator) { /* SLIM_TX port has a DEC as input */
-
-			tx_fs_reg = TAIKO_A_CDC_TX1_CLK_FS_CTL +
-				    8 * (decimator - 1);
-
-			pr_debug("%s: set DEC%u (-> SLIM_TX%u) rate to %u\n",
-				__func__, decimator, tx_port, sample_rate);
-
-			snd_soc_update_bits(codec, tx_fs_reg, 0x07,
-					    tx_fs_rate_reg_val);
-
-		} else {
-			if ((tx_port_reg_val >= 0x1) &&
-			    (tx_port_reg_val <= 0x7)) {
-
-				pr_debug("%s: RMIX%u going to SLIM TX%u\n",
-					__func__, tx_port_reg_val, tx_port);
-
-			} else if  ((tx_port_reg_val >= 0x8) &&
-				    (tx_port_reg_val <= 0x11)) {
-
-				pr_err("%s: ERROR: Should not be here\n",
-				       __func__);
-				pr_err("%s: ERROR: DEC connected to SLIM TX%u\n",
-					__func__, tx_port);
-				return -EINVAL;
-
-			} else if (tx_port_reg_val == 0) {
-				pr_debug("%s: no signal to SLIM TX%u\n",
-					__func__, tx_port);
-			} else {
-				pr_err("%s: ERROR: wrong signal to SLIM TX%u\n",
-					__func__, tx_port);
-				pr_err("%s: ERROR: wrong signal = %u\n",
-					__func__, tx_port_reg_val);
-				return -EINVAL;
-			}
-		}
-	}
-	return 0;
-}
-
-static void taiko_set_rxsb_port_format(struct snd_pcm_hw_params *params,
-				       struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	struct wcd9xxx_codec_dai_data *cdc_dai;
-	struct wcd9xxx_ch *ch;
-	int port;
-	u8 bit_sel;
-	u16 sb_ctl_reg, field_shift;
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S16_LE:
-		bit_sel = 0x2;
-		taiko_p->dai[dai->id].bit_width = 16;
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		bit_sel = 0x0;
-		taiko_p->dai[dai->id].bit_width = 24;
-		break;
-	default:
-		dev_err(codec->dev, "Invalid format\n");
-		return;
-	}
-
-	cdc_dai = &taiko_p->dai[dai->id];
-
-	list_for_each_entry(ch, &cdc_dai->wcd9xxx_ch_list, list) {
-		port = wcd9xxx_get_slave_port(ch->ch_num);
-
-		if (IS_ERR_VALUE(port) ||
-		    !TAIKO_VALIDATE_RX_SBPORT_RANGE(port)) {
-			dev_warn(codec->dev,
-				 "%s: invalid port ID %d returned for RX DAI\n",
-				 __func__, port);
-			return;
-		}
-
-		port = TAIKO_CONVERT_RX_SBPORT_ID(port);
-
-		if (port <= 3) {
-			sb_ctl_reg = TAIKO_A_CDC_CONN_RX_SB_B1_CTL;
-			field_shift = port << 1;
-		} else if (port <= 6) {
-			sb_ctl_reg = TAIKO_A_CDC_CONN_RX_SB_B2_CTL;
-			field_shift = (port - 4) << 1;
-		} else { /* should not happen */
-			dev_warn(codec->dev,
-				 "%s: bad port ID %d\n", __func__, port);
-			return;
-		}
-
-		dev_dbg(codec->dev, "%s: sb_ctl_reg %x field_shift %x\n",
-			__func__, sb_ctl_reg, field_shift);
-		snd_soc_update_bits(codec, sb_ctl_reg, 0x3 << field_shift,
-				    bit_sel << field_shift);
-	}
-}
-
-static int taiko_hw_params(struct snd_pcm_substream *substream,
-			    struct snd_pcm_hw_params *params,
-			    struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(dai->codec);
-	u8 tx_fs_rate, rx_fs_rate;
-	u32 compander_fs;
-	int ret;
-
-	pr_info("%s: dai_name = %s DAI-ID %x rate %d num_ch %d\n", __func__,
-		 dai->name, dai->id, params_rate(params),
-		 params_channels(params));
-
-	switch (params_rate(params)) {
-	case 8000:
-		tx_fs_rate = 0x00;
-		rx_fs_rate = 0x00;
-		compander_fs = COMPANDER_FS_8KHZ;
-		break;
-	case 16000:
-		tx_fs_rate = 0x01;
-		rx_fs_rate = 0x20;
-		compander_fs = COMPANDER_FS_16KHZ;
-		break;
-	case 32000:
-		tx_fs_rate = 0x02;
-		rx_fs_rate = 0x40;
-		compander_fs = COMPANDER_FS_32KHZ;
-		break;
-	case 48000:
-		tx_fs_rate = 0x03;
-		rx_fs_rate = 0x60;
-		compander_fs = COMPANDER_FS_48KHZ;
-		break;
-	case 96000:
-		tx_fs_rate = 0x04;
-		rx_fs_rate = 0x80;
-		compander_fs = COMPANDER_FS_96KHZ;
-		break;
-	case 192000:
-		tx_fs_rate = 0x05;
-		rx_fs_rate = 0xA0;
-		compander_fs = COMPANDER_FS_192KHZ;
-		break;
-	default:
-		pr_err("%s: Invalid sampling rate %d\n", __func__,
-			params_rate(params));
-		return -EINVAL;
-	}
-
-	switch (substream->stream) {
-	case SNDRV_PCM_STREAM_CAPTURE:
-		if (dai->id != AIF4_VIFEED) {
-			ret = taiko_set_decimator_rate(dai, tx_fs_rate,
-							   params_rate(params));
-			if (ret < 0) {
-				pr_err("%s: set decimator rate failed %d\n",
-					__func__, ret);
-				return ret;
-			}
-		}
-
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			switch (params_format(params)) {
-			case SNDRV_PCM_FORMAT_S16_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL,
-					0x20, 0x20);
-				break;
-			case SNDRV_PCM_FORMAT_S32_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_TX_I2S_CTL,
-					0x20, 0x00);
-				break;
-			default:
-				pr_err("invalid format\n");
-				break;
-			}
-			snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_TX_I2S_CTL,
-					    0x07, tx_fs_rate);
-		} else {
-			taiko->dai[dai->id].rate   = params_rate(params);
-		}
-		break;
-
-	case SNDRV_PCM_STREAM_PLAYBACK:
-		ret = taiko_set_interpolator_rate(dai, rx_fs_rate,
-						  compander_fs,
-						  params_rate(params));
-		if (ret < 0) {
-			pr_err("%s: set decimator rate failed %d\n", __func__,
-				ret);
-			return ret;
-		}
-		if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-			switch (params_format(params)) {
-			case SNDRV_PCM_FORMAT_S16_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL,
-					0x20, 0x20);
-				break;
-			case SNDRV_PCM_FORMAT_S32_LE:
-				snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CLK_RX_I2S_CTL,
-					0x20, 0x00);
-				break;
-			default:
-				pr_err("invalid format\n");
-				break;
-			}
-			snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_I2S_CTL,
-					    0x03, (rx_fs_rate >> 0x05));
-		} else {
-			taiko_set_rxsb_port_format(params, dai);
-			taiko->dai[dai->id].rate   = params_rate(params);
-		}
-		break;
-	default:
-		pr_err("%s: Invalid stream type %d\n", __func__,
-			substream->stream);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-#if defined(CONFIG_SND_SOC_ESXXX)
-int (*remote_route_enable)(struct snd_soc_dai *dai) = REMOTE_ROUTE_ENABLE_CB;
-int (*slim_get_channel_map)(struct snd_soc_dai *dai,
-		unsigned int *tx_num, unsigned int *tx_slot,
-		unsigned int *rx_num, unsigned int *rx_slot)
-			= SLIM_GET_CHANNEL_MAP_CB;
-int (*slim_set_channel_map)(struct snd_soc_dai *dai,
-		unsigned int tx_num, unsigned int *tx_slot,
-		unsigned int rx_num, unsigned int *rx_slot)
-			= SLIM_SET_CHANNEL_MAP_CB;
-int (*slim_hw_params)(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params,
-		struct snd_soc_dai *dai)
-		= SLIM_HW_PARAMS_CB;
-int (*remote_cfg_slim_rx)(int dai_id)	=	REMOTE_CFG_SLIM_RX_CB;
-int (*remote_close_slim_rx)(int dai_id)	=	REMOTE_CLOSE_SLIM_RX_CB;
-int (*remote_cfg_slim_tx)(int dai_id)	=	REMOTE_CFG_SLIM_TX_CB;
-int (*remote_close_slim_tx)(int dai_id)	=	REMOTE_CLOSE_SLIM_TX_CB;
-int (*remote_add_codec_controls)(struct snd_soc_codec *codec)
-		= REMOTE_ADD_CODEC_CONTROLS_CB;
-
-static int taiko_esxxx_startup(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	taiko_startup(substream, dai);
-/*
-	if (es705_remote_route_enable(dai))
-		es705_slim_startup(substream, dai);
-*/
-
-	return 0;
-}
-
-static void taiko_esxxx_shutdown(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	taiko_shutdown(substream, dai);
-
-/*
-	if (es705_remote_route_enable(dai))
-		es705_slim_shutdown(substream, dai);
-*/
-}
-
-static int taiko_esxxx_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params,
-		struct snd_soc_dai *dai)
-{
-	int rc = 0;
-	pr_info("%s: dai_name = %s DAI-ID %x rate %d num_ch %d\n", __func__,
-			dai->name, dai->id, params_rate(params),
-			params_channels(params));
-
-	rc = taiko_hw_params(substream, params, dai);
-
-	if (remote_route_enable(dai))
-		rc = slim_hw_params(substream, params, dai);
-
-	return rc;
-}
-static int taiko_esxxx_set_channel_map(struct snd_soc_dai *dai,
-				unsigned int tx_num, unsigned int *tx_slot,
-				unsigned int rx_num, unsigned int *rx_slot)
-
-{
-	unsigned int taiko_tx_num = 0;
-	unsigned int taiko_tx_slot[6];
-	unsigned int taiko_rx_num = 0;
-	unsigned int taiko_rx_slot[6];
-	int rc = 0;
-	pr_info("%s(): dai_name = %s DAI-ID %x tx_ch %d rx_ch %d\n",
-			__func__, dai->name, dai->id, tx_num, rx_num);
-
-	if (remote_route_enable(dai)) {
-		rc = taiko_get_channel_map(dai, &taiko_tx_num, taiko_tx_slot,
-					&taiko_rx_num, taiko_rx_slot);
-
-		rc = taiko_set_channel_map(dai, tx_num, taiko_tx_slot, rx_num, taiko_rx_slot);
-
-		rc = slim_set_channel_map(dai, tx_num, tx_slot, rx_num,
-					rx_slot);
-	} else
-		rc = taiko_set_channel_map(dai, tx_num, tx_slot, rx_num, rx_slot);
-
-	return rc;
-}
-
-static int taiko_esxxx_get_channel_map(struct snd_soc_dai *dai,
-				unsigned int *tx_num, unsigned int *tx_slot,
-				unsigned int *rx_num, unsigned int *rx_slot)
-
-{
-	int rc = 0;
-
-	pr_info("%s(): dai_name = %s DAI-ID %d tx_ch %d rx_ch %d\n",
-			__func__, dai->name, dai->id, *tx_num, *rx_num);
-
-	if (remote_route_enable(dai))
-		rc = slim_get_channel_map(dai, tx_num, tx_slot, rx_num,
-					rx_slot);
-	else
-		rc = taiko_get_channel_map(dai, tx_num, tx_slot, rx_num, rx_slot);
-
-	return rc;
-}
-static struct snd_soc_dai_ops taiko_dai_ops = {
-	.startup = taiko_esxxx_startup, /* taiko_startup, */
-	.shutdown = taiko_esxxx_shutdown, /* taiko_shutdown, */
-	.prepare = taiko_prepare,
-	.hw_params = taiko_esxxx_hw_params, /* taiko_hw_params, */
-	.set_sysclk = taiko_set_dai_sysclk,
-	.set_fmt = taiko_set_dai_fmt,
-	.set_channel_map = taiko_esxxx_set_channel_map,
-			/* taiko_set_channel_map, */
-	.get_channel_map = taiko_esxxx_get_channel_map,
-			/* taiko_get_channel_map, */
-};
-#elif defined(CONFIG_SND_SOC_ES325)
-static int taiko_es325_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params,
-		struct snd_soc_dai *dai)
-{
-	int rc = 0;
-	dev_info(dai->dev,"%s: dai_name = %s DAI-ID %x rate %d num_ch %d\n", __func__,
-			dai->name, dai->id, params_rate(params),
-			params_channels(params));
-
-	rc = taiko_hw_params(substream, params, dai);
-
-	if (es325_remote_route_enable(dai))
-		rc = es325_slim_hw_params(substream, params, dai);
-
-	return rc;
-}
-
-#define SLIM_BUGFIX
-static int taiko_es325_set_channel_map(struct snd_soc_dai *dai,
-				unsigned int tx_num, unsigned int *tx_slot,
-				unsigned int rx_num, unsigned int *rx_slot)
-
-{
-#if !defined(SLIM_BUGFIX)
-	unsigned int taiko_tx_num = 0;
-#endif
-	unsigned int taiko_tx_slot[6];
-#if !defined(SLIM_BUGFIX)
-	unsigned int taiko_rx_num = 0;
-#endif
-	unsigned int taiko_rx_slot[6];
-#if defined(SLIM_BUGFIX)
-	unsigned int temp_tx_num = 0;
-	unsigned int temp_rx_num = 0;
-#endif
-	int rc = 0;
-
-	if (es325_remote_route_enable(dai)) {
-#if defined(SLIM_BUGFIX)
-		rc = taiko_get_channel_map(dai, &temp_tx_num, taiko_tx_slot,
-					&temp_rx_num, taiko_rx_slot);
-#else
-		rc = taiko_get_channel_map(dai, &taiko_tx_num, taiko_tx_slot,
-					&taiko_rx_num, taiko_rx_slot);
-#endif
-
-		rc = taiko_set_channel_map(dai, tx_num, taiko_tx_slot, rx_num, taiko_rx_slot);
-
-		rc = es325_slim_set_channel_map(dai, tx_num, tx_slot, rx_num, rx_slot);
-	} else
-		rc = taiko_set_channel_map(dai, tx_num, tx_slot, rx_num, rx_slot);
-
-	return rc;
-}
-
-static int taiko_es325_get_channel_map(struct snd_soc_dai *dai,
-				unsigned int *tx_num, unsigned int *tx_slot,
-				unsigned int *rx_num, unsigned int *rx_slot)
-
-{
-	int rc = 0;
-
-	if (es325_remote_route_enable(dai))
-		rc = es325_slim_get_channel_map(dai, tx_num, tx_slot, rx_num, rx_slot);
-	else
-		rc = taiko_get_channel_map(dai, tx_num, tx_slot, rx_num, rx_slot);
-
-	return rc;
-}
-
-static struct snd_soc_dai_ops taiko_dai_ops = {
-	.startup = taiko_startup,
-	.shutdown = taiko_shutdown,
-	.prepare = taiko_prepare,
-	.hw_params = taiko_es325_hw_params, /* tabla_hw_params, */
-	.set_sysclk = taiko_set_dai_sysclk,
-	.set_fmt = taiko_set_dai_fmt,
-	.set_channel_map = taiko_set_channel_map, /* tabla_set_channel_map, */
-	.get_channel_map = taiko_es325_get_channel_map, /* tabla_get_channel_map, */
-};
-
-static struct snd_soc_dai_ops taiko_es325_dai_ops = {
-	.startup = taiko_startup,
-	.hw_params = taiko_es325_hw_params,
-	.set_channel_map = taiko_es325_set_channel_map,
-	.get_channel_map = taiko_es325_get_channel_map,
-};
-#else
-static struct snd_soc_dai_ops taiko_dai_ops = {
-	.startup = taiko_startup,
-	.shutdown = taiko_shutdown,
-	.prepare = taiko_prepare,
-	.hw_params = taiko_hw_params,
-	.set_sysclk = taiko_set_dai_sysclk,
-	.set_fmt = taiko_set_dai_fmt,
-	.set_channel_map = taiko_set_channel_map,
-	.get_channel_map = taiko_get_channel_map,
-};
-#endif
-
-static struct snd_soc_dai_driver taiko_dai[] = {
-	{
-		.name = "taiko_rx1",
-		.id = AIF1_PB,
-		.playback = {
-			.stream_name = "AIF1 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS_S16_S24_LE,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_tx1",
-		.id = AIF1_CAP,
-		.capture = {
-			.stream_name = "AIF1 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_rx2",
-		.id = AIF2_PB,
-		.playback = {
-			.stream_name = "AIF2 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS_S16_S24_LE,
-			.rate_min = 8000,
-			.rate_max = 192000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_tx2",
-		.id = AIF2_CAP,
-		.capture = {
-			.stream_name = "AIF2 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 8,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_tx3",
-		.id = AIF3_CAP,
-		.capture = {
-			.stream_name = "AIF3 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 48000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_rx3",
-		.id = AIF3_PB,
-		.playback = {
-			.stream_name = "AIF3 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS_S16_S24_LE,
-			.rate_min = 8000,
-			.rate_max = 192000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_vifeedback",
-		.id = AIF4_VIFEED,
-		.capture = {
-			.stream_name = "VIfeed",
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 48000,
-			.rate_min = 48000,
-			.channels_min = 2,
-			.channels_max = 2,
-	 },
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_mad1",
-		.id = AIF4_MAD_TX,
-		.capture = {
-			.stream_name = "AIF4 MAD TX",
-			.rates = SNDRV_PCM_RATE_16000,
-			.formats = TAIKO_FORMATS,
-			.rate_min = 16000,
-			.rate_max = 16000,
-			.channels_min = 1,
-			.channels_max = 1,
-		},
-		.ops = &taiko_dai_ops,
-	},
-#ifdef CONFIG_SND_SOC_ES325
-	{
-		.name = "taiko_es325_rx1",
-		.id = AIF1_PB + ES325_DAI_ID_OFFSET,
-		.playback = {
-			.stream_name = "AIF1 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_es325_dai_ops,
-	},
-	{
-		.name = "taiko_es325_tx1",
-		.id = AIF1_CAP + ES325_DAI_ID_OFFSET,
-		.capture = {
-			.stream_name = "AIF1 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_es325_dai_ops,
-	},
-	{
-		.name = "taiko_es325_rx2",
-		.id = AIF2_PB + ES325_DAI_ID_OFFSET,
-		.playback = {
-			.stream_name = "AIF2 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &taiko_es325_dai_ops,
-	},
-#endif
-};
-
-static struct snd_soc_dai_driver taiko_i2s_dai[] = {
-	{
-		.name = "taiko_i2s_rx1",
-		.id = AIF1_PB,
-		.playback = {
-			.stream_name = "AIF1 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_i2s_tx1",
-		.id = AIF1_CAP,
-		.capture = {
-			.stream_name = "AIF1 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_i2s_rx2",
-		.id = AIF1_PB,
-		.playback = {
-			.stream_name = "AIF2 Playback",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-	{
-		.name = "taiko_i2s_tx2",
-		.id = AIF1_CAP,
-		.capture = {
-			.stream_name = "AIF2 Capture",
-			.rates = WCD9320_RATES,
-			.formats = TAIKO_FORMATS,
-			.rate_max = 192000,
-			.rate_min = 8000,
-			.channels_min = 1,
-			.channels_max = 4,
-		},
-		.ops = &taiko_dai_ops,
-	},
-};
-
-static int taiko_codec_enable_slim_chmask(struct wcd9xxx_codec_dai_data *dai,
-					  bool up)
-{
-	int ret = 0;
-	struct wcd9xxx_ch *ch;
-
-	if (up) {
-		list_for_each_entry(ch, &dai->wcd9xxx_ch_list, list) {
-			ret = wcd9xxx_get_slave_port(ch->ch_num);
-			if (ret < 0) {
-				pr_err("%s: Invalid slave port ID: %d\n",
-				       __func__, ret);
-				ret = -EINVAL;
-			} else {
-				set_bit(ret, &dai->ch_mask);
-			}
-		}
-	} else {
-		ret = wait_event_timeout(dai->dai_wait, (dai->ch_mask == 0),
-					 msecs_to_jiffies(
-						     TAIKO_SLIM_CLOSE_TIMEOUT));
-		if (!ret) {
-			pr_err("%s: Slim close tx/rx wait timeout\n", __func__);
-			ret = -ETIMEDOUT;
-		} else {
-			ret = 0;
-		}
-	}
-	return ret;
-}
-
-static void taiko_codec_enable_int_port(struct wcd9xxx_codec_dai_data *dai,
-					  struct snd_soc_codec *codec)
-{
-	struct wcd9xxx_ch *ch;
-	int port_num = 0;
-	unsigned short reg = 0;
-	u8 val = 0;
-	if (!dai || !codec) {
-		pr_err("%s: Invalid params\n", __func__);
-		return;
-	}
-	list_for_each_entry(ch, &dai->wcd9xxx_ch_list, list) {
-		if (ch->port >= TAIKO_RX_PORT_START_NUMBER) {
-			port_num = ch->port - TAIKO_RX_PORT_START_NUMBER;
-			reg = TAIKO_SLIM_PGD_PORT_INT_EN0 + (port_num / 8);
-			val = wcd9xxx_interface_reg_read(codec->control_data,
-				reg);
-			if (!(val & (1 << (port_num % 8)))) {
-				val |= (1 << (port_num % 8));
-				wcd9xxx_interface_reg_write(
-					codec->control_data, reg, val);
-				val = wcd9xxx_interface_reg_read(
-					codec->control_data, reg);
-			}
-		} else {
-			port_num = ch->port;
-			reg = TAIKO_SLIM_PGD_PORT_INT_TX_EN0 + (port_num / 8);
-			val = wcd9xxx_interface_reg_read(codec->control_data,
-				reg);
-			if (!(val & (1 << (port_num % 8)))) {
-				val |= (1 << (port_num % 8));
-				wcd9xxx_interface_reg_write(codec->control_data,
-					reg, val);
-				val = wcd9xxx_interface_reg_read(
-					codec->control_data, reg);
-			}
-		}
-	}
-}
-
-static int taiko_codec_enable_slimrx(struct snd_soc_dapm_widget *w,
-				     struct snd_kcontrol *kcontrol,
-				     int event)
-{
-	struct wcd9xxx *core;
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	int ret = 0;
-	struct wcd9xxx_codec_dai_data *dai;
-
-	core = dev_get_drvdata(codec->dev->parent);
-
-	pr_debug("%s: event called! codec name %s num_dai %d\n"
-		"stream name %s event %d\n",
-		__func__, w->codec->name, w->codec->num_dai, w->sname, event);
-
-	/* Execute the callback only if interface type is slimbus */
-	if (taiko_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS)
-		return 0;
-
-	dai = &taiko_p->dai[w->shift];
-	pr_debug("%s: w->name %s w->shift %d event %d\n",
-		 __func__, w->name, w->shift, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		dai->bus_down_in_recovery = false;
-		taiko_codec_enable_int_port(dai, codec);
-		(void) taiko_codec_enable_slim_chmask(dai, true);
-#if defined(CONFIG_SND_SOC_ESXXX)
-		ret = remote_cfg_slim_rx(w->shift);
-#elif defined(CONFIG_SND_SOC_ES325)
-		ret = es325_remote_cfg_slim_rx(w->shift);
-#endif
-		ret = wcd9xxx_cfg_slim_sch_rx(core, &dai->wcd9xxx_ch_list,
-					      dai->rate, dai->bit_width,
-					      &dai->grph);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-#if defined(CONFIG_SND_SOC_ESXXX)
-		ret = remote_close_slim_rx(w->shift);
-#elif defined(CONFIG_SND_SOC_ES325)
-		ret = es325_remote_close_slim_rx(w->shift);
-#endif
-		ret = wcd9xxx_close_slim_sch_rx(core, &dai->wcd9xxx_ch_list,
-						dai->grph);
-		if (!dai->bus_down_in_recovery)
-			ret = taiko_codec_enable_slim_chmask(dai, false);
-
-		if (ret < 0) {
-			ret = wcd9xxx_disconnect_port(core,
-						      &dai->wcd9xxx_ch_list,
-						      dai->grph);
-			pr_debug("%s: Disconnect RX port, ret = %d\n",
-				 __func__, ret);
-		}
-		dai->bus_down_in_recovery = false;
-		break;
-	}
-	return ret;
-}
-
-static int taiko_codec_enable_slimvi_feedback(struct snd_soc_dapm_widget *w,
-				struct snd_kcontrol *kcontrol,
-				int event)
-{
-	struct wcd9xxx *core = NULL;
-	struct snd_soc_codec *codec = NULL;
-	struct taiko_priv *taiko_p = NULL;
-	u32 ret = 0;
-	struct wcd9xxx_codec_dai_data *dai = NULL;
-
-	if (!w || !w->codec) {
-		pr_err("%s invalid params\n", __func__);
-		return -EINVAL;
-	}
-	codec = w->codec;
-	taiko_p = snd_soc_codec_get_drvdata(codec);
-	core = dev_get_drvdata(codec->dev->parent);
-
-	pr_debug("%s: event called! codec name %s num_dai %d stream name %s\n",
-		__func__, w->codec->name, w->codec->num_dai, w->sname);
-
-	/* Execute the callback only if interface type is slimbus */
-	if (taiko_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
-		pr_err("%s Interface is not correct", __func__);
-		return 0;
-	}
-
-	pr_debug("%s(): w->name %s event %d w->shift %d\n",
-		__func__, w->name, event, w->shift);
-	if (w->shift != AIF4_VIFEED) {
-		pr_err("%s Error in enabling the tx path\n", __func__);
-		ret = -EINVAL;
-		goto out_vi;
-	}
-	dai = &taiko_p->dai[w->shift];
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		/*Enable V&I sensing*/
-		snd_soc_update_bits(codec, TAIKO_A_SPKR_PROT_EN,
-				0x88, 0x88);
-		/*Enable spkr VI clocks*/
-		snd_soc_update_bits(codec,
-		TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL, 0xC, 0xC);
-		taiko_codec_enable_int_port(dai, codec);
-		dai->bus_down_in_recovery = false;
-		(void) taiko_codec_enable_slim_chmask(dai, true);
-		ret = wcd9xxx_cfg_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
-					dai->rate, dai->bit_width,
-					&dai->grph);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		ret = wcd9xxx_close_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
-						dai->grph);
-		if (ret)
-			pr_err("%s error in close_slim_sch_tx %d\n",
-				__func__, ret);
-		ret = taiko_codec_enable_slim_chmask(dai, false);
-		if (ret < 0) {
-			ret = wcd9xxx_disconnect_port(core,
-						      &dai->wcd9xxx_ch_list,
-						      dai->grph);
-			pr_debug("%s: Disconnect RX port, ret = %d\n",
-				 __func__, ret);
-		}
-
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL,
-				0xC, 0x0);
-		/*Disable V&I sensing*/
-		snd_soc_update_bits(codec, TAIKO_A_SPKR_PROT_EN,
-				0x88, 0x00);
-
-		dai->bus_down_in_recovery = false;
-		break;
-	}
-out_vi:
-	return ret;
-}
-
-static int taiko_codec_enable_slimtx(struct snd_soc_dapm_widget *w,
-				     struct snd_kcontrol *kcontrol,
-				     int event)
-{
-	struct wcd9xxx *core;
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-	u32  ret = 0;
-	struct wcd9xxx_codec_dai_data *dai;
-
-	core = dev_get_drvdata(codec->dev->parent);
-
-	pr_debug("%s: event called! codec name %s num_dai %d stream name %s\n",
-		__func__, w->codec->name, w->codec->num_dai, w->sname);
-
-	/* Execute the callback only if interface type is slimbus */
-	if (taiko_p->intf_type != WCD9XXX_INTERFACE_TYPE_SLIMBUS)
-		return 0;
-
-	pr_debug("%s(): w->name %s event %d w->shift %d\n",
-		__func__, w->name, event, w->shift);
-
-	dai = &taiko_p->dai[w->shift];
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		taiko_codec_enable_int_port(dai, codec);
-		dai->bus_down_in_recovery = false;
-		(void) taiko_codec_enable_slim_chmask(dai, true);
-		ret = wcd9xxx_cfg_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
-					      dai->rate, dai->bit_width,
-					      &dai->grph);
-#if defined(CONFIG_SND_SOC_ESXXX)
-			ret = remote_cfg_slim_tx(w->shift);
-#elif defined(CONFIG_SND_SOC_ES325)
-		ret = es325_remote_cfg_slim_tx(w->shift);
-#endif
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-#if defined(CONFIG_SND_SOC_ESXXX)
-		ret = remote_close_slim_tx(w->shift);
-#elif defined(CONFIG_SND_SOC_ES325)
-		ret = es325_remote_close_slim_tx(w->shift);
-#endif
-		ret = wcd9xxx_close_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
-						dai->grph);
-		if (!dai->bus_down_in_recovery)
-			ret = taiko_codec_enable_slim_chmask(dai, false);
-
-		if (ret < 0) {
-			ret = wcd9xxx_disconnect_port(core,
-						      &dai->wcd9xxx_ch_list,
-						      dai->grph);
-			pr_debug("%s: Disconnect RX port, ret = %d\n",
-				 __func__, ret);
-		}
-
-		dai->bus_down_in_recovery = false;
-		break;
-	}
-	return ret;
-}
-
-static int taiko_codec_enable_ear_pa(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
-						 WCD9XXX_CLSH_STATE_EAR,
-						 WCD9XXX_CLSH_REQ_ENABLE,
-						 WCD9XXX_CLSH_EVENT_POST_PA);
-
-		usleep_range(5000, 5000);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
-						 WCD9XXX_CLSH_STATE_EAR,
-						 WCD9XXX_CLSH_REQ_DISABLE,
-						 WCD9XXX_CLSH_EVENT_POST_PA);
-		usleep_range(5000, 5000);
-	}
-	return 0;
-}
-
-static int taiko_codec_ear_dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct taiko_priv *taiko_p = snd_soc_codec_get_drvdata(codec);
-
-	pr_debug("%s %s %d\n", __func__, w->name, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
-						 WCD9XXX_CLSH_STATE_EAR,
-						 WCD9XXX_CLSH_REQ_ENABLE,
-						 WCD9XXX_CLSH_EVENT_PRE_DAC);
-		break;
-	}
-
-	return 0;
-}
-
-static int taiko_codec_dsm_mux_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	u8 reg_val, zoh_mux_val = 0x00;
-
-	pr_debug("%s: event = %d\n", __func__, event);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		reg_val = snd_soc_read(codec, TAIKO_A_CDC_CONN_CLSH_CTL);
-
-		if ((reg_val & 0x30) == 0x10)
-			zoh_mux_val = 0x04;
-		else if ((reg_val & 0x30) == 0x20)
-			zoh_mux_val = 0x08;
-
-		if (zoh_mux_val != 0x00)
-			snd_soc_update_bits(codec,
-					TAIKO_A_CDC_CONN_CLSH_CTL,
-					0x0C, zoh_mux_val);
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec, TAIKO_A_CDC_CONN_CLSH_CTL,
-							0x0C, 0x00);
-		break;
-	}
-	return 0;
-}
-
-static int taiko_codec_enable_anc_ear(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	int ret = 0;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		ret = taiko_codec_enable_anc(w, kcontrol, event);
-		msleep(50);
-		snd_soc_update_bits(codec, TAIKO_A_RX_EAR_EN, 0x10, 0x10);
-		break;
-	case SND_SOC_DAPM_POST_PMU:
-		ret = taiko_codec_enable_ear_pa(w, kcontrol, event);
-		break;
-	case SND_SOC_DAPM_PRE_PMD:
-		snd_soc_update_bits(codec, TAIKO_A_RX_EAR_EN, 0x10, 0x00);
-		msleep(40);
-		ret |= taiko_codec_enable_anc(w, kcontrol, event);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		ret = taiko_codec_enable_ear_pa(w, kcontrol, event);
-		break;
-	}
-	return ret;
-}
-#if 0
-static int taiko_codec_set_iir_gain(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	int value = 0;
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		value = snd_soc_read(codec, TAIKO_A_CDC_IIR1_GAIN_B1_CTL);
-		snd_soc_write(codec, TAIKO_A_CDC_IIR1_GAIN_B1_CTL, value);
-		break;
-	default:
-		pr_info("%s: event = %d not expected\n", __func__, event);
-		break;
-	}
-	return 0;
-}
-#endif
-
-/* Todo: Have seperate dapm widgets for I2S and Slimbus.
- * Might Need to have callbacks registered only for slimbus
- */
-static const struct snd_soc_dapm_widget taiko_dapm_widgets[] = {
-	/*RX stuff */
-	SND_SOC_DAPM_OUTPUT("EAR"),
-
-	SND_SOC_DAPM_PGA_E("EAR PA", TAIKO_A_RX_EAR_EN, 4, 0, NULL, 0,
-			taiko_codec_enable_ear_pa, SND_SOC_DAPM_POST_PMU |
-			SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MIXER_E("DAC1", TAIKO_A_RX_EAR_EN, 6, 0, dac1_switch,
-		ARRAY_SIZE(dac1_switch), taiko_codec_ear_dac_event,
-		SND_SOC_DAPM_PRE_PMU),
-
-	SND_SOC_DAPM_AIF_IN_E("AIF1 PB", "AIF1 Playback", 0, SND_SOC_NOPM,
-				AIF1_PB, 0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_AIF_IN_E("AIF2 PB", "AIF2 Playback", 0, SND_SOC_NOPM,
-				AIF2_PB, 0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_AIF_IN_E("AIF3 PB", "AIF3 Playback", 0, SND_SOC_NOPM,
-				AIF3_PB, 0, taiko_codec_enable_slimrx,
-				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("SLIM RX1 MUX", SND_SOC_NOPM, TAIKO_RX1, 0,
-				&slim_rx_mux[TAIKO_RX1]),
-	SND_SOC_DAPM_MUX("SLIM RX2 MUX", SND_SOC_NOPM, TAIKO_RX2, 0,
-				&slim_rx_mux[TAIKO_RX2]),
-	SND_SOC_DAPM_MUX("SLIM RX3 MUX", SND_SOC_NOPM, TAIKO_RX3, 0,
-				&slim_rx_mux[TAIKO_RX3]),
-	SND_SOC_DAPM_MUX("SLIM RX4 MUX", SND_SOC_NOPM, TAIKO_RX4, 0,
-				&slim_rx_mux[TAIKO_RX4]),
-	SND_SOC_DAPM_MUX("SLIM RX5 MUX", SND_SOC_NOPM, TAIKO_RX5, 0,
-				&slim_rx_mux[TAIKO_RX5]),
-	SND_SOC_DAPM_MUX("SLIM RX6 MUX", SND_SOC_NOPM, TAIKO_RX6, 0,
-				&slim_rx_mux[TAIKO_RX6]),
-	SND_SOC_DAPM_MUX("SLIM RX7 MUX", SND_SOC_NOPM, TAIKO_RX7, 0,
-				&slim_rx_mux[TAIKO_RX7]),
-
-	SND_SOC_DAPM_MIXER("SLIM RX1", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("SLIM RX2", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("SLIM RX3", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("SLIM RX4", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("SLIM RX5", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("SLIM RX6", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("SLIM RX7", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-	/* Headphone */
-	SND_SOC_DAPM_OUTPUT("HEADPHONE"),
-	SND_SOC_DAPM_PGA_E("HPHL", TAIKO_A_RX_HPH_CNP_EN, 5, 0, NULL, 0,
-		taiko_hph_pa_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MIXER_E("HPHL DAC", TAIKO_A_RX_HPH_L_DAC_CTL, 7, 0,
-		hphl_switch, ARRAY_SIZE(hphl_switch), taiko_hphl_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_PGA_E("HPHR", TAIKO_A_RX_HPH_CNP_EN, 4, 0, NULL, 0,
-		taiko_hph_pa_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU |	SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_DAC_E("HPHR DAC", NULL, TAIKO_A_RX_HPH_R_DAC_CTL, 7, 0,
-		taiko_hphr_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	/* Speaker */
-	SND_SOC_DAPM_OUTPUT("LINEOUT1"),
-	SND_SOC_DAPM_OUTPUT("LINEOUT2"),
-	SND_SOC_DAPM_OUTPUT("LINEOUT3"),
-	SND_SOC_DAPM_OUTPUT("LINEOUT4"),
-	SND_SOC_DAPM_OUTPUT("SPK_OUT"),
-
-	SND_SOC_DAPM_PGA_E("LINEOUT1 PA", TAIKO_A_RX_LINE_CNP_EN, 0, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("LINEOUT2 PA", TAIKO_A_RX_LINE_CNP_EN, 1, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("LINEOUT3 PA", TAIKO_A_RX_LINE_CNP_EN, 2, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("LINEOUT4 PA", TAIKO_A_RX_LINE_CNP_EN, 3, 0, NULL,
-			0, taiko_codec_enable_lineout, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_PGA_E("SPK PA", SND_SOC_NOPM, 0, 0 , NULL,
-			   0, taiko_codec_enable_spk_pa,
-			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_DAC_E("LINEOUT1 DAC", NULL, TAIKO_A_RX_LINE_1_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_DAC_E("LINEOUT2 DAC", NULL, TAIKO_A_RX_LINE_2_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_DAC_E("LINEOUT3 DAC", NULL, TAIKO_A_RX_LINE_3_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_SWITCH("LINEOUT3 DAC GROUND", SND_SOC_NOPM, 0, 0,
-				&lineout3_ground_switch),
-	SND_SOC_DAPM_DAC_E("LINEOUT4 DAC", NULL, TAIKO_A_RX_LINE_4_DAC_CTL, 7, 0
-		, taiko_lineout_dac_event,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_SWITCH("LINEOUT4 DAC GROUND", SND_SOC_NOPM, 0, 0,
-				&lineout4_ground_switch),
-
-	SND_SOC_DAPM_DAC_E("SPK DAC", NULL, SND_SOC_NOPM, 0, 0,
-			   taiko_spk_dac_event,
-			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_SUPPLY("VDD_SPKDRV", SND_SOC_NOPM, 0, 0,
-			    taiko_codec_enable_vdd_spkr,
-			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MIXER("RX1 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("RX2 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("RX7 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-	SND_SOC_DAPM_MIXER_E("RX1 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 0, 0, NULL,
-		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX2 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 1, 0, NULL,
-		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_MIXER_E("RX3 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 2, 0, NULL,
-		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX4 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 3, 0, NULL,
-		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX5 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 4, 0, NULL,
-		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX6 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 5, 0, NULL,
-		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_MIXER_E("RX7 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 6, 0, NULL,
-		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
-
-	SND_SOC_DAPM_MIXER("RX1 CHAIN", TAIKO_A_CDC_RX1_B6_CTL, 5, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("RX2 CHAIN", TAIKO_A_CDC_RX2_B6_CTL, 5, 0, NULL, 0),
-
-	SND_SOC_DAPM_MUX("RX1 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX1 INP3", SND_SOC_NOPM, 0, 0,
-		&rx_mix1_inp3_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx2_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx2_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX3 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx3_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX3 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx3_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX4 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx4_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX4 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx4_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX5 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx5_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX5 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx5_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX6 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx6_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX6 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx6_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX1 INP1", SND_SOC_NOPM, 0, 0,
-		&rx7_mix1_inp1_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX1 INP2", SND_SOC_NOPM, 0, 0,
-		&rx7_mix1_inp2_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX2 INP1", SND_SOC_NOPM, 0, 0,
-		&rx1_mix2_inp1_mux),
-	SND_SOC_DAPM_MUX("RX1 MIX2 INP2", SND_SOC_NOPM, 0, 0,
-		&rx1_mix2_inp2_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX2 INP1", SND_SOC_NOPM, 0, 0,
-		&rx2_mix2_inp1_mux),
-	SND_SOC_DAPM_MUX("RX2 MIX2 INP2", SND_SOC_NOPM, 0, 0,
-		&rx2_mix2_inp2_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX2 INP1", SND_SOC_NOPM, 0, 0,
-		&rx7_mix2_inp1_mux),
-	SND_SOC_DAPM_MUX("RX7 MIX2 INP2", SND_SOC_NOPM, 0, 0,
-		&rx7_mix2_inp2_mux),
-
-	SND_SOC_DAPM_MUX("RDAC5 MUX", SND_SOC_NOPM, 0, 0,
-		&rx_dac5_mux),
-	SND_SOC_DAPM_MUX("RDAC7 MUX", SND_SOC_NOPM, 0, 0,
-		&rx_dac7_mux),
-
-	SND_SOC_DAPM_MUX_E("CLASS_H_DSM MUX", SND_SOC_NOPM, 0, 0,
-		&class_h_dsm_mux, taiko_codec_dsm_mux_event,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_SUPPLY("RX_BIAS", SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_rx_bias, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_SUPPLY("CDC_I2S_RX_CONN", WCD9XXX_A_CDC_CLK_OTHR_CTL, 5, 0,
-			    NULL, 0),
-
-	/* TX */
-
-	SND_SOC_DAPM_SUPPLY("CDC_CONN", WCD9XXX_A_CDC_CLK_OTHR_CTL, 2, 0, NULL,
-		0),
-
-	SND_SOC_DAPM_SUPPLY("LDO_H", SND_SOC_NOPM, 7, 0,
-			    taiko_codec_enable_ldo_h,
-			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-	/*
-	 * DAPM 'LDO_H Standalone' is to be powered by mbhc driver after
-	 * acquring codec_resource lock.
-	 * So call __taiko_codec_enable_ldo_h instead and avoid deadlock.
-	 */
-	SND_SOC_DAPM_SUPPLY("LDO_H Standalone", SND_SOC_NOPM, 7, 0,
-			    __taiko_codec_enable_ldo_h,
-			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_SUPPLY("COMP0_CLK", SND_SOC_NOPM, 0, 0,
-		taiko_config_compander, SND_SOC_DAPM_PRE_PMU |
-			SND_SOC_DAPM_PRE_PMD),
-	SND_SOC_DAPM_SUPPLY("COMP1_CLK", SND_SOC_NOPM, 1, 0,
-		taiko_config_compander, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_PRE_PMD),
-	SND_SOC_DAPM_SUPPLY("COMP2_CLK", SND_SOC_NOPM, 2, 0,
-		taiko_config_compander, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_PRE_PMD),
-
-
-	SND_SOC_DAPM_INPUT("AMIC1"),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS1 External", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS1 Internal1", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS1 Internal2", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("Main Mic Bias", 0, 0, 0,
-				0, SND_SOC_DAPM_PRE_PMU |SND_SOC_DAPM_POST_PMU |
-				SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_INPUT("AMIC3"),
-
-	SND_SOC_DAPM_INPUT("AMIC4"),
-#if defined(CONFIG_LDO_SUBMIC_BIAS)
-	SND_SOC_DAPM_MICBIAS_E("Sub Mic Bias", 0, 0, 0,
-				0, SND_SOC_DAPM_PRE_PMU |SND_SOC_DAPM_POST_PMU |
-				SND_SOC_DAPM_POST_PMD),
-#endif
-
-	SND_SOC_DAPM_INPUT("AMIC5"),
-
-	SND_SOC_DAPM_INPUT("AMIC6"),
-
-	SND_SOC_DAPM_MUX_E("DEC1 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 0, 0,
-		&dec1_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC2 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 1, 0,
-		&dec2_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC3 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 2, 0,
-		&dec3_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC4 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 3, 0,
-		&dec4_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC5 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 4, 0,
-		&dec5_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC6 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 5, 0,
-		&dec6_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC7 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 6, 0,
-		&dec7_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC8 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B1_CTL, 7, 0,
-		&dec8_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC9 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL, 0, 0,
-		&dec9_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX_E("DEC10 MUX", TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL, 1, 0,
-		&dec10_mux, taiko_codec_enable_dec,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_MUX("ANC1 MUX", SND_SOC_NOPM, 0, 0, &anc1_mux),
-	SND_SOC_DAPM_MUX("ANC2 MUX", SND_SOC_NOPM, 0, 0, &anc2_mux),
-
-	SND_SOC_DAPM_OUTPUT("ANC HEADPHONE"),
-	SND_SOC_DAPM_PGA_E("ANC HPHL", SND_SOC_NOPM, 5, 0, NULL, 0,
-		taiko_codec_enable_anc_hph,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD |
-		SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_PGA_E("ANC HPHR", SND_SOC_NOPM, 4, 0, NULL, 0,
-		taiko_codec_enable_anc_hph, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD |
-		SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_OUTPUT("ANC EAR"),
-	SND_SOC_DAPM_PGA_E("ANC EAR PA", SND_SOC_NOPM, 0, 0, NULL, 0,
-		taiko_codec_enable_anc_ear,
-		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD |
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MUX("ANC1 FB MUX", SND_SOC_NOPM, 0, 0, &anc1_fb_mux),
-
-	SND_SOC_DAPM_INPUT("AMIC2"),
-	SND_SOC_DAPM_MICBIAS_E(DAPM_MICBIAS2_EXTERNAL_STANDALONE, SND_SOC_NOPM,
-			       7, 0, taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 External", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 Internal1", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU |
-			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 Internal2", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS2 Internal3", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E(DAPM_MICBIAS3_EXTERNAL_STANDALONE, SND_SOC_NOPM,
-			       7, 0, taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS3 External", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS3 Internal1", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU |
-			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS3 Internal2", SND_SOC_NOPM, 7, 0,
-			       taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU |
-			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("MIC BIAS4 External", SND_SOC_NOPM, 7,
-			       0, taiko_codec_enable_micbias,
-			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			       SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_MICBIAS_E("Ear Mic Bias", 0, 0, 0,
-				0, SND_SOC_DAPM_PRE_PMU |SND_SOC_DAPM_POST_PMU |
-				SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_AIF_OUT_E("AIF1 CAP", "AIF1 Capture", 0, SND_SOC_NOPM,
-		AIF1_CAP, 0, taiko_codec_enable_slimtx,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_AIF_OUT_E("AIF2 CAP", "AIF2 Capture", 0, SND_SOC_NOPM,
-		AIF2_CAP, 0, taiko_codec_enable_slimtx,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_AIF_OUT_E("AIF3 CAP", "AIF3 Capture", 0, SND_SOC_NOPM,
-		AIF3_CAP, 0, taiko_codec_enable_slimtx,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_AIF_OUT_E("AIF4 VI", "VIfeed", 0, SND_SOC_NOPM,
-		AIF4_VIFEED, 0, taiko_codec_enable_slimvi_feedback,
-		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_AIF_OUT_E("AIF4 MAD", "AIF4 MAD TX", 0,
-			       SND_SOC_NOPM, 0, 0,
-			       taiko_codec_enable_mad, SND_SOC_DAPM_PRE_PMU),
-	SND_SOC_DAPM_SWITCH("MADONOFF", SND_SOC_NOPM, 0, 0,
-			    &aif4_mad_switch),
-	SND_SOC_DAPM_INPUT("MADINPUT"),
-
-	SND_SOC_DAPM_MIXER("AIF1_CAP Mixer", SND_SOC_NOPM, AIF1_CAP, 0,
-		aif_cap_mixer, ARRAY_SIZE(aif_cap_mixer)),
-
-	SND_SOC_DAPM_MIXER("AIF2_CAP Mixer", SND_SOC_NOPM, AIF2_CAP, 0,
-		aif_cap_mixer, ARRAY_SIZE(aif_cap_mixer)),
-
-	SND_SOC_DAPM_MIXER("AIF3_CAP Mixer", SND_SOC_NOPM, AIF3_CAP, 0,
-		aif_cap_mixer, ARRAY_SIZE(aif_cap_mixer)),
-
-	SND_SOC_DAPM_MUX("SLIM TX1 MUX", SND_SOC_NOPM, TAIKO_TX1, 0,
-		&sb_tx1_mux),
-	SND_SOC_DAPM_MUX("SLIM TX2 MUX", SND_SOC_NOPM, TAIKO_TX2, 0,
-		&sb_tx2_mux),
-	SND_SOC_DAPM_MUX("SLIM TX3 MUX", SND_SOC_NOPM, TAIKO_TX3, 0,
-		&sb_tx3_mux),
-	SND_SOC_DAPM_MUX("SLIM TX4 MUX", SND_SOC_NOPM, TAIKO_TX4, 0,
-		&sb_tx4_mux),
-	SND_SOC_DAPM_MUX("SLIM TX5 MUX", SND_SOC_NOPM, TAIKO_TX5, 0,
-		&sb_tx5_mux),
-	SND_SOC_DAPM_MUX("SLIM TX6 MUX", SND_SOC_NOPM, TAIKO_TX6, 0,
-		&sb_tx6_mux),
-	SND_SOC_DAPM_MUX("SLIM TX7 MUX", SND_SOC_NOPM, TAIKO_TX7, 0,
-		&sb_tx7_mux),
-	SND_SOC_DAPM_MUX("SLIM TX8 MUX", SND_SOC_NOPM, TAIKO_TX8, 0,
-		&sb_tx8_mux),
-	SND_SOC_DAPM_MUX("SLIM TX9 MUX", SND_SOC_NOPM, TAIKO_TX9, 0,
-		&sb_tx9_mux),
-	SND_SOC_DAPM_MUX("SLIM TX10 MUX", SND_SOC_NOPM, TAIKO_TX10, 0,
-		&sb_tx10_mux),
-
-	/* Digital Mic Inputs */
-	SND_SOC_DAPM_ADC_E("DMIC1", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC2", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC3", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC4", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("DMIC5", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("DMIC6", NULL, SND_SOC_NOPM, 0, 0,
-		taiko_codec_enable_dmic, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	/* Sidetone */
-	SND_SOC_DAPM_MUX("IIR1 INP1 MUX", SND_SOC_NOPM, 0, 0, &iir1_inp1_mux),
-	SND_SOC_DAPM_MIXER("IIR1", TAIKO_A_CDC_CLK_SD_CTL, 0, 0, NULL, 0),
-
-	SND_SOC_DAPM_MUX("IIR2 INP1 MUX", SND_SOC_NOPM, 0, 0, &iir2_inp1_mux),
-	SND_SOC_DAPM_MIXER("IIR2", TAIKO_A_CDC_CLK_SD_CTL, 1, 0, NULL, 0),
-
-	/* AUX PGA */
-	SND_SOC_DAPM_ADC_E("AUX_PGA_Left", NULL, TAIKO_A_RX_AUX_SW_CTL, 7, 0,
-		taiko_codec_enable_aux_pga, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	SND_SOC_DAPM_ADC_E("AUX_PGA_Right", NULL, TAIKO_A_RX_AUX_SW_CTL, 6, 0,
-		taiko_codec_enable_aux_pga, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
-
-	/* Lineout, ear and HPH PA Mixers */
-
-	SND_SOC_DAPM_MIXER("EAR_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		ear_pa_mix, ARRAY_SIZE(ear_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("HPHL_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		hphl_pa_mix, ARRAY_SIZE(hphl_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("HPHR_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		hphr_pa_mix, ARRAY_SIZE(hphr_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT1_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout1_pa_mix, ARRAY_SIZE(lineout1_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT2_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout2_pa_mix, ARRAY_SIZE(lineout2_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT3_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout3_pa_mix, ARRAY_SIZE(lineout3_pa_mix)),
-
-	SND_SOC_DAPM_MIXER("LINEOUT4_PA_MIXER", SND_SOC_NOPM, 0, 0,
-		lineout4_pa_mix, ARRAY_SIZE(lineout4_pa_mix)),
-	SND_SOC_DAPM_SWITCH("VIONOFF", SND_SOC_NOPM, 0, 0,
-			    &aif4_vi_switch),
-	SND_SOC_DAPM_INPUT("VIINPUT"),
-
-};
-
-static irqreturn_t taiko_slimbus_irq(int irq, void *data)
-{
-	struct taiko_priv *priv = data;
-	struct snd_soc_codec *codec = priv->codec;
-	unsigned long status = 0;
-	int i, j, port_id, k;
-	u32 bit;
-	u8 val, int_val = 0;
-	bool tx, cleared;
-	unsigned short reg = 0;
-
-	for (i = TAIKO_SLIM_PGD_PORT_INT_STATUS_RX_0, j = 0;
-	     i <= TAIKO_SLIM_PGD_PORT_INT_STATUS_TX_1; i++, j++) {
-		val = wcd9xxx_interface_reg_read(codec->control_data, i);
-		status |= ((u32)val << (8 * j));
-	}
-
-	for_each_set_bit(j, &status, 32) {
-		tx = (j >= 16 ? true : false);
-		port_id = (tx ? j - 16 : j);
-		val = wcd9xxx_interface_reg_read(codec->control_data,
-					TAIKO_SLIM_PGD_PORT_INT_RX_SOURCE0 + j);
-		if (val & TAIKO_SLIM_IRQ_OVERFLOW)
-			pr_err_ratelimited(
-			   "%s: overflow error on %s port %d, value %x\n",
-			   __func__, (tx ? "TX" : "RX"), port_id, val);
-		if (val & TAIKO_SLIM_IRQ_UNDERFLOW)
-			pr_err_ratelimited(
-			   "%s: underflow error on %s port %d, value %x\n",
-			   __func__, (tx ? "TX" : "RX"), port_id, val);
-		if ((val & TAIKO_SLIM_IRQ_OVERFLOW) ||
-			(val & TAIKO_SLIM_IRQ_UNDERFLOW)) {
-			if (!tx)
-				reg = TAIKO_SLIM_PGD_PORT_INT_EN0 +
-					(port_id / 8);
-			else
-				reg = TAIKO_SLIM_PGD_PORT_INT_TX_EN0 +
-					(port_id / 8);
-			int_val = wcd9xxx_interface_reg_read(
-				codec->control_data, reg);
-			if (int_val & (1 << (port_id % 8))) {
-				int_val = int_val ^ (1 << (port_id % 8));
-				wcd9xxx_interface_reg_write(codec->control_data,
-					reg, int_val);
-			}
-		}
-		if (val & TAIKO_SLIM_IRQ_PORT_CLOSED) {
-			/*
-			 * INT SOURCE register starts from RX to TX
-			 * but port number in the ch_mask is in opposite way
-			 */
-			bit = (tx ? j - 16 : j + 16);
-			pr_debug("%s: %s port %d closed value %x, bit %u\n",
-				 __func__, (tx ? "TX" : "RX"), port_id, val,
-				 bit);
-			for (k = 0, cleared = false; k < NUM_CODEC_DAIS; k++) {
-				pr_debug("%s: priv->dai[%d].ch_mask = 0x%lx\n",
-					 __func__, k, priv->dai[k].ch_mask);
-				if (test_and_clear_bit(bit,
-						       &priv->dai[k].ch_mask)) {
-					cleared = true;
-					if (!priv->dai[k].ch_mask)
-						wake_up(&priv->dai[k].dai_wait);
-					/*
-					 * There are cases when multiple DAIs
-					 * might be using the same slimbus
-					 * channel. Hence don't break here.
-					 */
-				}
-			}
-			WARN(!cleared,
-			     "Couldn't find slimbus %s port %d for closing\n",
-			     (tx ? "TX" : "RX"), port_id);
-		}
-		wcd9xxx_interface_reg_write(codec->control_data,
-					    TAIKO_SLIM_PGD_PORT_INT_CLR_RX_0 +
-					    (j / 8),
-					    1 << (j % 8));
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int taiko_handle_pdata(struct taiko_priv *taiko)
-{
-	struct snd_soc_codec *codec = taiko->codec;
-	struct wcd9xxx_pdata *pdata = taiko->resmgr.pdata;
-	int k1, k2, k3, rc = 0;
-	u8 leg_mode, txfe_bypass, txfe_buff, flag;
-	u8 i = 0, j = 0;
-	u8 val_txfe = 0, value = 0;
-	u8 dmic_sample_rate_value = 0;
-	u8 dmic_b1_ctl_value = 0, dmic_b2_ctl_value = 0;
-	u8 anc_ctl_value = 0;
-
-	if (!pdata) {
-		pr_err("%s: NULL pdata\n", __func__);
-		rc = -ENODEV;
-		goto done;
-	}
-
-	leg_mode = pdata->amic_settings.legacy_mode;
-	txfe_bypass = pdata->amic_settings.txfe_enable;
-	txfe_buff = pdata->amic_settings.txfe_buff;
-	flag = pdata->amic_settings.use_pdata;
-
-	/* Make sure settings are correct */
-	if ((pdata->micbias.ldoh_v > WCD9XXX_LDOH_3P0_V) ||
-	    (pdata->micbias.bias1_cfilt_sel > WCD9XXX_CFILT3_SEL) ||
-	    (pdata->micbias.bias2_cfilt_sel > WCD9XXX_CFILT3_SEL) ||
-	    (pdata->micbias.bias3_cfilt_sel > WCD9XXX_CFILT3_SEL) ||
-	    (pdata->micbias.bias4_cfilt_sel > WCD9XXX_CFILT3_SEL)) {
-		rc = -EINVAL;
-		goto done;
-	}
-	/* figure out k value */
-	k1 = wcd9xxx_resmgr_get_k_val(&taiko->resmgr, pdata->micbias.cfilt1_mv);
-	k2 = wcd9xxx_resmgr_get_k_val(&taiko->resmgr, pdata->micbias.cfilt2_mv);
-	k3 = wcd9xxx_resmgr_get_k_val(&taiko->resmgr, pdata->micbias.cfilt3_mv);
-
-	if (IS_ERR_VALUE(k1) || IS_ERR_VALUE(k2) || IS_ERR_VALUE(k3)) {
-		rc = -EINVAL;
-		goto done;
-	}
-	/* Set voltage level and always use LDO */
-	snd_soc_update_bits(codec, TAIKO_A_LDO_H_MODE_1, 0x0C,
-			    (pdata->micbias.ldoh_v << 2));
-
-	snd_soc_update_bits(codec, TAIKO_A_MICB_CFILT_1_VAL, 0xFC, (k1 << 2));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_CFILT_2_VAL, 0xFC, (k2 << 2));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_CFILT_3_VAL, 0xFC, (k3 << 2));
-
-	snd_soc_update_bits(codec, TAIKO_A_MICB_1_CTL, 0x60,
-			    (pdata->micbias.bias1_cfilt_sel << 5));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_2_CTL, 0x60,
-			    (pdata->micbias.bias2_cfilt_sel << 5));
-	snd_soc_update_bits(codec, TAIKO_A_MICB_3_CTL, 0x60,
-			    (pdata->micbias.bias3_cfilt_sel << 5));
-	snd_soc_update_bits(codec, taiko->resmgr.reg_addr->micb_4_ctl, 0x60,
-			    (pdata->micbias.bias4_cfilt_sel << 5));
-
-	for (i = 0; i < 6; j++, i += 2) {
-		if (flag & (0x01 << i)) {
-			value = (leg_mode & (0x01 << i)) ? 0x10 : 0x00;
-			val_txfe = (txfe_bypass & (0x01 << i)) ? 0x20 : 0x00;
-			val_txfe = val_txfe |
-				((txfe_buff & (0x01 << i)) ? 0x10 : 0x00);
-			snd_soc_update_bits(codec, TAIKO_A_TX_1_2_EN + j * 10,
-				0x10, value);
-			snd_soc_update_bits(codec,
-				TAIKO_A_TX_1_2_TEST_EN + j * 10,
-				0x30, val_txfe);
-		}
-		if (flag & (0x01 << (i + 1))) {
-			value = (leg_mode & (0x01 << (i + 1))) ? 0x01 : 0x00;
-			val_txfe = (txfe_bypass &
-					(0x01 << (i + 1))) ? 0x02 : 0x00;
-			val_txfe |= (txfe_buff &
-					(0x01 << (i + 1))) ? 0x01 : 0x00;
-			snd_soc_update_bits(codec, TAIKO_A_TX_1_2_EN + j * 10,
-				0x01, value);
-			snd_soc_update_bits(codec,
-				TAIKO_A_TX_1_2_TEST_EN + j * 10,
-				0x03, val_txfe);
-		}
-	}
-	if (flag & 0x40) {
-		value = (leg_mode & 0x40) ? 0x10 : 0x00;
-		value = value | ((txfe_bypass & 0x40) ? 0x02 : 0x00);
-		value = value | ((txfe_buff & 0x40) ? 0x01 : 0x00);
-		snd_soc_update_bits(codec, TAIKO_A_TX_7_MBHC_EN,
-			0x13, value);
-	}
-
-	if (pdata->ocp.use_pdata) {
-		/* not defined in CODEC specification */
-		if (pdata->ocp.hph_ocp_limit == 1 ||
-			pdata->ocp.hph_ocp_limit == 5) {
-			rc = -EINVAL;
-			goto done;
-		}
-		snd_soc_update_bits(codec, TAIKO_A_RX_COM_OCP_CTL,
-			0x0F, pdata->ocp.num_attempts);
-		snd_soc_write(codec, TAIKO_A_RX_COM_OCP_COUNT,
-			((pdata->ocp.run_time << 4) | pdata->ocp.wait_time));
-		snd_soc_update_bits(codec, TAIKO_A_RX_HPH_OCP_CTL,
-			0xE0, (pdata->ocp.hph_ocp_limit << 5));
-	}
-
-	for (i = 0; i < ARRAY_SIZE(pdata->regulator); i++) {
-		if (pdata->regulator[i].name &&
-		    !strncmp(pdata->regulator[i].name, "CDC_VDDA_RX", 11)) {
-			if (pdata->regulator[i].min_uV == 1800000 &&
-			    pdata->regulator[i].max_uV == 1800000) {
-				snd_soc_write(codec, TAIKO_A_BIAS_REF_CTL,
-					      0x1C);
-			} else if (pdata->regulator[i].min_uV == 2200000 &&
-				   pdata->regulator[i].max_uV == 2200000) {
-				snd_soc_write(codec, TAIKO_A_BIAS_REF_CTL,
-					      0x1E);
-			} else {
-				pr_err("%s: unsupported CDC_VDDA_RX voltage\n"
-				       "min %d, max %d\n", __func__,
-				       pdata->regulator[i].min_uV,
-				       pdata->regulator[i].max_uV);
-				rc = -EINVAL;
-			}
-			break;
-		}
-	}
-
-	/* Set micbias capless mode with tail current */
-	value = (pdata->micbias.bias1_cap_mode == MICBIAS_EXT_BYP_CAP ?
-		 0x00 : 0x16);
-	snd_soc_update_bits(codec, TAIKO_A_MICB_1_CTL, 0x1E, value);
-	value = (pdata->micbias.bias2_cap_mode == MICBIAS_EXT_BYP_CAP ?
-		 0x00 : 0x16);
-	snd_soc_update_bits(codec, TAIKO_A_MICB_2_CTL, 0x1E, value);
-	value = (pdata->micbias.bias3_cap_mode == MICBIAS_EXT_BYP_CAP ?
-		 0x00 : 0x16);
-	snd_soc_update_bits(codec, TAIKO_A_MICB_3_CTL, 0x1E, value);
-	value = (pdata->micbias.bias4_cap_mode == MICBIAS_EXT_BYP_CAP ?
-		 0x00 : 0x16);
-	snd_soc_update_bits(codec, TAIKO_A_MICB_4_CTL, 0x1E, value);
-
-	/* Set the DMIC sample rate */
-	if (pdata->mclk_rate == TAIKO_MCLK_CLK_9P6MHZ) {
-		switch (pdata->dmic_sample_rate) {
-		case WCD9XXX_DMIC_SAMPLE_RATE_2P4MHZ:
-			dmic_sample_rate_value = WCD9XXX_DMIC_SAMPLE_RATE_DIV_4;
-			dmic_b1_ctl_value = WCD9XXX_DMIC_B1_CTL_DIV_4;
-			dmic_b2_ctl_value = WCD9XXX_DMIC_B2_CTL_DIV_4;
-			anc_ctl_value = WCD9XXX_ANC_DMIC_X2_OFF;
-			break;
-		case WCD9XXX_DMIC_SAMPLE_RATE_4P8MHZ:
-			dmic_sample_rate_value = WCD9XXX_DMIC_SAMPLE_RATE_DIV_2;
-			dmic_b1_ctl_value = WCD9XXX_DMIC_B1_CTL_DIV_2;
-			dmic_b2_ctl_value = WCD9XXX_DMIC_B2_CTL_DIV_2;
-			anc_ctl_value = WCD9XXX_ANC_DMIC_X2_ON;
-			break;
-		case WCD9XXX_DMIC_SAMPLE_RATE_3P2MHZ:
-		case WCD9XXX_DMIC_SAMPLE_RATE_UNDEFINED:
-			dmic_sample_rate_value = WCD9XXX_DMIC_SAMPLE_RATE_DIV_3;
-			dmic_b1_ctl_value = WCD9XXX_DMIC_B1_CTL_DIV_3;
-			dmic_b2_ctl_value = WCD9XXX_DMIC_B2_CTL_DIV_3;
-			anc_ctl_value = WCD9XXX_ANC_DMIC_X2_OFF;
-			break;
-		default:
-			pr_err("%s Invalid sample rate %d for mclk %d\n",
-			__func__, pdata->dmic_sample_rate, pdata->mclk_rate);
-			rc = -EINVAL;
-			goto done;
-			break;
-		}
-	} else if (pdata->mclk_rate == TAIKO_MCLK_CLK_12P288MHZ) {
-		switch (pdata->dmic_sample_rate) {
-		case WCD9XXX_DMIC_SAMPLE_RATE_3P072MHZ:
-			dmic_sample_rate_value = WCD9XXX_DMIC_SAMPLE_RATE_DIV_4;
-			dmic_b1_ctl_value = WCD9XXX_DMIC_B1_CTL_DIV_4;
-			dmic_b2_ctl_value = WCD9XXX_DMIC_B2_CTL_DIV_4;
-			anc_ctl_value = WCD9XXX_ANC_DMIC_X2_OFF;
-			break;
-		case WCD9XXX_DMIC_SAMPLE_RATE_6P144MHZ:
-			dmic_sample_rate_value = WCD9XXX_DMIC_SAMPLE_RATE_DIV_2;
-			dmic_b1_ctl_value = WCD9XXX_DMIC_B1_CTL_DIV_2;
-			dmic_b2_ctl_value = WCD9XXX_DMIC_B2_CTL_DIV_2;
-			anc_ctl_value = WCD9XXX_ANC_DMIC_X2_ON;
-			break;
-		case WCD9XXX_DMIC_SAMPLE_RATE_4P096MHZ:
-		case WCD9XXX_DMIC_SAMPLE_RATE_UNDEFINED:
-			dmic_sample_rate_value = WCD9XXX_DMIC_SAMPLE_RATE_DIV_3;
-			dmic_b1_ctl_value = WCD9XXX_DMIC_B1_CTL_DIV_3;
-			dmic_b2_ctl_value = WCD9XXX_DMIC_B2_CTL_DIV_3;
-			anc_ctl_value = WCD9XXX_ANC_DMIC_X2_OFF;
-			break;
-		default:
-			pr_err("%s Invalid sample rate %d for mclk %d\n",
-			__func__, pdata->dmic_sample_rate, pdata->mclk_rate);
-			rc = -EINVAL;
-			goto done;
-			break;
-		}
-	} else {
-		pr_err("%s MCLK is not set!\n", __func__);
-		rc = -EINVAL;
-		goto done;
-	}
-
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX1_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX2_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX3_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX4_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX5_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX6_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX7_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX8_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX9_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_TX10_DMIC_CTL,
-		0x7, dmic_sample_rate_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_DMIC_B1_CTL,
-		0xEE, dmic_b1_ctl_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_DMIC_B2_CTL,
-		0xE, dmic_b2_ctl_value);
-	snd_soc_update_bits(codec, TAIKO_A_CDC_ANC1_B2_CTL,
-		0x1, anc_ctl_value);
-
-done:
-	return rc;
-}
-
-static const struct wcd9xxx_reg_mask_val taiko_reg_defaults[] = {
-
-	/* set MCLk to 9.6 */
-	TAIKO_REG_VAL(TAIKO_A_CHIP_CTL, 0x02),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLK_POWER_CTL, 0x03),
-
-	/* EAR PA deafults  */
-	TAIKO_REG_VAL(TAIKO_A_RX_EAR_CMBUFF, 0x05),
-
-	/* RX deafults */
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX1_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX2_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX3_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX4_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX5_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX6_B5_CTL, 0x78),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX7_B5_CTL, 0x78),
-
-	/* RX1 and RX2 defaults */
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX1_B6_CTL, 0xA0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX2_B6_CTL, 0xA0),
-
-	/* RX3 to RX7 defaults */
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX3_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX4_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX5_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX6_B6_CTL, 0x80),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX7_B6_CTL, 0x80),
-
-	/* MAD registers */
-	TAIKO_REG_VAL(TAIKO_A_MAD_ANA_CTRL, 0xF1),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_MAIN_CTL_1, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_MAIN_CTL_2, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_1, 0x00),
-	/* Set SAMPLE_TX_EN bit */
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_2, 0x03),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_3, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_4, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_5, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_6, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_7, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_CTL_8, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_IIR_CTL_PTR, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_MAD_AUDIO_IIR_CTL_VAL, 0x40),
-	TAIKO_REG_VAL(TAIKO_A_CDC_DEBUG_B7_CTL, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLK_OTHR_RESET_B1_CTL, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CLK_OTHR_CTL, 0x00),
-	TAIKO_REG_VAL(TAIKO_A_CDC_CONN_MAD, 0x01),
-#if !defined(CONFIG_MACH_VIENNA_LTE) && !defined(CONFIG_MACH_LT03_LTE) && !defined(CONFIG_MACH_PICASSO_LTE) && !defined(CONFIG_SEC_H_PROJECT) && !defined(CONFIG_SEC_FRESCO_PROJECT) && !defined(CONFIG_MACH_KS01EUR)
-	/* Set HPH Path to low power mode */
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_BIAS_PA, 0x55),
-#endif
-	/* BUCK default */
-	TAIKO_REG_VAL(WCD9XXX_A_BUCK_CTRL_CCL_4, 0x51),
-	TAIKO_REG_VAL(WCD9XXX_A_BUCK_CTRL_CCL_1, 0x5B),
-};
-
-static const struct wcd9xxx_reg_mask_val taiko_1_0_reg_defaults[] = {
-	/*
-	 * The following only need to be written for Taiko 1.0 parts.
-	 * Taiko 2.0 will have appropriate defaults for these registers.
-	 */
-
-	/* Required defaults for class H operation */
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_CHOP_CTL, 0xF4),
-	TAIKO_REG_VAL(TAIKO_A_BIAS_CURR_CTL_2, 0x08),
-	TAIKO_REG_VAL(WCD9XXX_A_BUCK_CTRL_CCL_3, 0x60),
-
-	/* Choose max non-overlap time for NCP */
-	TAIKO_REG_VAL(TAIKO_A_NCP_CLK, 0xFC),
-	/* Use 25mV/50mV for deltap/m to reduce ripple */
-	TAIKO_REG_VAL(WCD9XXX_A_BUCK_CTRL_VCL_1, 0x08),
-	/*
-	 * Set DISABLE_MODE_SEL<1:0> to 0b10 (disable PWM in auto mode).
-	 * Note that the other bits of this register will be changed during
-	 * Rx PA bring up.
-	 */
-	TAIKO_REG_VAL(WCD9XXX_A_BUCK_MODE_3, 0xCE),
-	/*Reduce EAR DAC bias to 70% */
-	TAIKO_REG_VAL(TAIKO_A_RX_EAR_BIAS_PA, 0x76),
-	/* Reduce LINE DAC bias to 70% */
-#if !defined(CONFIG_MACH_VIENNA_LTE) && !defined(CONFIG_MACH_LT03_LTE) && !defined(CONFIG_MACH_PICASSO_LTE) && !defined(CONFIG_SEC_H_PROJECT) && !defined(CONFIG_SEC_FRESCO_PROJECT) && !defined(CONFIG_MACH_KS01EUR)
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_BIAS_PA, 0x78),
-#else
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_BIAS_PA, 0x7A),
-	/* Reduce HPH DAC bias to 70% */
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_BIAS_PA, 0x7A),
-#endif
-
-	/*
-	 * There is a diode to pull down the micbias while doing
-	 * insertion detection.  This diode can cause leakage.
-	 * Set bit 0 to 1 to prevent leakage.
-	 * Setting this bit of micbias 2 prevents leakage for all other micbias.
-	 */
-	TAIKO_REG_VAL(TAIKO_A_MICB_2_MBHC, 0x41),
-
-	/* Disable TX7 internal biasing path which can cause leakage */
-	TAIKO_REG_VAL(TAIKO_A_TX_SUP_SWITCH_CTRL_1, 0xBF),
-	/* Enable MICB 4 VDDIO switch to prevent leakage */
-	TAIKO_REG_VAL(TAIKO_A_MICB_4_MBHC, 0x81),
-
-	/* Close leakage on the spkdrv */
-	TAIKO_REG_VAL(TAIKO_A_SPKR_DRV_DBG_PWRSTG, 0x24),
-};
-
-/*
- * Don't update TAIKO_A_CHIP_CTL, TAIKO_A_BUCK_CTRL_CCL_1 and
- * TAIKO_A_RX_EAR_CMBUFF as those are updated in taiko_reg_defaults
- */
-static const struct wcd9xxx_reg_mask_val taiko_2_0_reg_defaults[] = {
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_1_GAIN, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_2_GAIN, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_1_2_ADC_IB, 0x44),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_3_GAIN, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_4_GAIN, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_3_4_ADC_IB, 0x44),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_5_GAIN, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_6_GAIN, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX_5_6_ADC_IB, 0x44),
-	TAIKO_REG_VAL(WCD9XXX_A_BUCK_MODE_3, 0xCE),
-	TAIKO_REG_VAL(WCD9XXX_A_BUCK_CTRL_VCL_1, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_BUCK_CTRL_CCL_4, 0x51),
-	TAIKO_REG_VAL(TAIKO_A_NCP_DTEST, 0x10),
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_CHOP_CTL, 0xA4),
-#if !defined(CONFIG_MACH_VIENNA_LTE) && !defined(CONFIG_MACH_LT03_LTE) && !defined(CONFIG_MACH_PICASSO_LTE) && !defined(CONFIG_SEC_H_PROJECT) && !defined(CONFIG_SEC_FRESCO_PROJECT) && !defined(CONFIG_MACH_KS01EUR)
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_OCP_CTL, 0x6B),
-#else
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_BIAS_PA, 0x7A),
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_OCP_CTL, 0x6B),
-#endif
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_CNP_WG_CTL, 0xDA),
-	TAIKO_REG_VAL(TAIKO_A_RX_HPH_CNP_WG_TIME, 0x15),
-	TAIKO_REG_VAL(TAIKO_A_RX_EAR_BIAS_PA, 0x76),
-	TAIKO_REG_VAL(TAIKO_A_RX_EAR_CNP, 0xC0),
-#if !defined(CONFIG_MACH_VIENNA_LTE) && !defined(CONFIG_MACH_LT03_LTE) && !defined(CONFIG_MACH_PICASSO_LTE) && !defined(CONFIG_SEC_H_PROJECT) && !defined(CONFIG_SEC_FRESCO_PROJECT) && !defined(CONFIG_MACH_KS01EUR)
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_BIAS_PA, 0x78),
-#else
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_BIAS_PA, 0x7A),
-#endif
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_1_TEST, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_2_TEST, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_3_TEST, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_RX_LINE_4_TEST, 0x2),
-	TAIKO_REG_VAL(TAIKO_A_SPKR_DRV_OCP_CTL, 0x97),
-	TAIKO_REG_VAL(TAIKO_A_SPKR_DRV_CLIP_DET, 0x1),
-	TAIKO_REG_VAL(TAIKO_A_SPKR_DRV_IEC, 0x0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX1_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX2_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX3_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX4_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX5_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX6_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX7_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX8_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX9_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_TX10_MUX_CTL, 0x48),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX1_B4_CTL, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX2_B4_CTL, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX3_B4_CTL, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX4_B4_CTL, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX5_B4_CTL, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX6_B4_CTL, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_CDC_RX7_B4_CTL, 0x8),
-	TAIKO_REG_VAL(TAIKO_A_CDC_VBAT_GAIN_UPD_MON, 0x0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_PA_RAMP_B1_CTL, 0x0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_PA_RAMP_B2_CTL, 0x0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_PA_RAMP_B3_CTL, 0x0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_PA_RAMP_B4_CTL, 0x0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_SPKR_CLIPDET_B1_CTL, 0x0),
-	TAIKO_REG_VAL(TAIKO_A_CDC_COMP0_B4_CTL, 0x37),
-	TAIKO_REG_VAL(TAIKO_A_CDC_COMP0_B5_CTL, 0x7f),
-	TAIKO_REG_VAL(TAIKO_A_CDC_COMP0_B5_CTL, 0x7f),
-};
-
-static void taiko_update_reg_defaults(struct snd_soc_codec *codec)
-{
-	u32 i;
-	struct wcd9xxx *taiko_core = dev_get_drvdata(codec->dev->parent);
-
-	for (i = 0; i < ARRAY_SIZE(taiko_reg_defaults); i++)
-		snd_soc_write(codec, taiko_reg_defaults[i].reg,
-			      taiko_reg_defaults[i].val);
-
-	if (TAIKO_IS_1_0(taiko_core->version)) {
-		for (i = 0; i < ARRAY_SIZE(taiko_1_0_reg_defaults); i++)
-			snd_soc_write(codec, taiko_1_0_reg_defaults[i].reg,
-				      taiko_1_0_reg_defaults[i].val);
-		if (spkr_drv_wrnd == 1)
-			snd_soc_write(codec, TAIKO_A_SPKR_DRV_EN, 0xEF);
-	} else {
-		for (i = 0; i < ARRAY_SIZE(taiko_2_0_reg_defaults); i++)
-			snd_soc_write(codec, taiko_2_0_reg_defaults[i].reg,
-				      taiko_2_0_reg_defaults[i].val);
-		spkr_drv_wrnd = -1;
-	}
-}
-
-static const struct wcd9xxx_reg_mask_val taiko_codec_reg_init_val[] = {
-	/* Initialize current threshold to 350MA
-	 * number of wait and run cycles to 4096
-	 */
-	{TAIKO_A_RX_HPH_OCP_CTL, 0xE1, 0x61},
-	{TAIKO_A_RX_COM_OCP_COUNT, 0xFF, 0xFF},
-	{TAIKO_A_RX_HPH_L_TEST, 0x01, 0x01},
-	{TAIKO_A_RX_HPH_R_TEST, 0x01, 0x01},
-
-	/* Initialize gain registers to use register gain */
-	{TAIKO_A_RX_HPH_L_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_HPH_R_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_1_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_2_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_3_GAIN, 0x20, 0x20},
-	{TAIKO_A_RX_LINE_4_GAIN, 0x20, 0x20},
-	{TAIKO_A_SPKR_DRV_GAIN, 0x04, 0x04},
-
-	/* Use 16 bit sample size for TX1 to TX6 */
-	{TAIKO_A_CDC_CONN_TX_SB_B1_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B2_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B3_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B4_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B5_CTL, 0x30, 0x20},
-	{TAIKO_A_CDC_CONN_TX_SB_B6_CTL, 0x30, 0x20},
-
-	/* Use 16 bit sample size for TX7 to TX10 */
-	{TAIKO_A_CDC_CONN_TX_SB_B7_CTL, 0x60, 0x40},
-	{TAIKO_A_CDC_CONN_TX_SB_B8_CTL, 0x60, 0x40},
-	{TAIKO_A_CDC_CONN_TX_SB_B9_CTL, 0x60, 0x40},
-	{TAIKO_A_CDC_CONN_TX_SB_B10_CTL, 0x60, 0x40},
-
-	/*enable HPF filter for TX paths */
-	{TAIKO_A_CDC_TX1_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX2_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX3_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX4_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX5_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX6_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX7_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX8_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX9_MUX_CTL, 0x8, 0x0},
-	{TAIKO_A_CDC_TX10_MUX_CTL, 0x8, 0x0},
-
-	/* Compander zone selection */
-	{TAIKO_A_CDC_COMP0_B4_CTL, 0x3F, 0x37},
-	{TAIKO_A_CDC_COMP1_B4_CTL, 0x3F, 0x37},
-	{TAIKO_A_CDC_COMP2_B4_CTL, 0x3F, 0x37},
-	{TAIKO_A_CDC_COMP0_B5_CTL, 0x7F, 0x7F},
-	{TAIKO_A_CDC_COMP1_B5_CTL, 0x7F, 0x7F},
-	{TAIKO_A_CDC_COMP2_B5_CTL, 0x7F, 0x7F},
-
-	/*
-	 * Setup wavegen timer to 20msec and disable chopper
-	 * as default. This corresponds to Compander OFF
-	 */
-	{TAIKO_A_RX_HPH_CNP_WG_CTL, 0xFF, 0xDB},
-	{TAIKO_A_RX_HPH_CNP_WG_TIME, 0xFF, 0x58},
-	{TAIKO_A_RX_HPH_BIAS_WG_OCP, 0xFF, 0x1A},
-	{TAIKO_A_RX_HPH_CHOP_CTL, 0xFF, 0x24},
-
-	/* Choose max non-overlap time for NCP */
-	{TAIKO_A_NCP_CLK, 0xFF, 0xFC},
-
-	/* Program the 0.85 volt VBG_REFERENCE */
-	{TAIKO_A_BIAS_CURR_CTL_2, 0xFF, 0x04},
-
-	/* set MAD input MIC to DMIC1 */
-	{TAIKO_A_CDC_CONN_MAD, 0x0F, 0x08},
-
-};
-
-static void taiko_codec_init_reg(struct snd_soc_codec *codec)
-{
-	u32 i;
-
-	for (i = 0; i < ARRAY_SIZE(taiko_codec_reg_init_val); i++)
-		snd_soc_update_bits(codec, taiko_codec_reg_init_val[i].reg,
-				taiko_codec_reg_init_val[i].mask,
-				taiko_codec_reg_init_val[i].val);
-}
-
-static void taiko_slim_interface_init_reg(struct snd_soc_codec *codec)
-{
-	int i;
-
-	for (i = 0; i < WCD9XXX_SLIM_NUM_PORT_REG; i++)
-		wcd9xxx_interface_reg_write(codec->control_data,
-					    TAIKO_SLIM_PGD_PORT_INT_EN0 + i,
-					    0xFF);
-}
-
-static int taiko_setup_irqs(struct taiko_priv *taiko)
-{
-	int ret = 0;
-	struct snd_soc_codec *codec = taiko->codec;
-	struct wcd9xxx *wcd9xxx = codec->control_data;
-	struct wcd9xxx_core_resource *core_res =
-				&wcd9xxx->core_res;
-
-	ret = wcd9xxx_request_irq(core_res, WCD9XXX_IRQ_SLIMBUS,
-				  taiko_slimbus_irq, "SLIMBUS Slave", taiko);
-	if (ret)
-		pr_err("%s: Failed to request irq %d\n", __func__,
-		       WCD9XXX_IRQ_SLIMBUS);
-	else
-		taiko_slim_interface_init_reg(codec);
-
-	return ret;
-}
-
-static void taiko_cleanup_irqs(struct taiko_priv *taiko)
-{
-	struct snd_soc_codec *codec = taiko->codec;
-	struct wcd9xxx *wcd9xxx = codec->control_data;
-	struct wcd9xxx_core_resource *core_res =
-				&wcd9xxx->core_res;
-
-	wcd9xxx_free_irq(core_res, WCD9XXX_IRQ_SLIMBUS, taiko);
-}
-static
-struct firmware_cal *taiko_get_hwdep_fw_cal(struct snd_soc_codec *codec,
-			enum wcd_cal_type type)
-{
-	struct taiko_priv *taiko;
-	struct firmware_cal *hwdep_cal;
-
-	if (!codec) {
-		pr_err("%s: NULL codec pointer\n", __func__);
-		return NULL;
-	}
-	taiko = snd_soc_codec_get_drvdata(codec);
-	hwdep_cal = wcdcal_get_fw_cal(taiko->fw_data, type);
-	if (!hwdep_cal) {
-		dev_err(codec->dev, "%s: cal not sent by %d\n",
-				 __func__, type);
-		return NULL;
-	}
-
-	return hwdep_cal;
-}
-
-int taiko_hs_detect(struct snd_soc_codec *codec,
-		    struct wcd9xxx_mbhc_config *mbhc_cfg)
-{
-	int rc;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	rc = wcd9xxx_mbhc_start(&taiko->mbhc, mbhc_cfg);
-	if (!rc)
-		taiko->mbhc_started = true;
-	return rc;
-}
-EXPORT_SYMBOL(taiko_hs_detect);
-
-void taiko_hs_detect_exit(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	wcd9xxx_mbhc_stop(&taiko->mbhc);
-	taiko->mbhc_started = false;
-}
-EXPORT_SYMBOL(taiko_hs_detect_exit);
-
-void taiko_event_register(
-	int (*machine_event_cb)(struct snd_soc_codec *codec,
-				enum wcd9xxx_codec_event),
-	struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	taiko->machine_codec_event_cb = machine_event_cb;
-}
-EXPORT_SYMBOL(taiko_event_register);
-
-static void taiko_init_slim_slave_cfg(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *priv = snd_soc_codec_get_drvdata(codec);
-	struct afe_param_cdc_slimbus_slave_cfg *cfg;
-	struct wcd9xxx *wcd9xxx = codec->control_data;
-	uint64_t eaddr = 0;
-
-	cfg = &priv->slimbus_slave_cfg;
-	cfg->minor_version = 1;
-	cfg->tx_slave_port_offset = 0;
-	cfg->rx_slave_port_offset = 16;
-
-	memcpy(&eaddr, &wcd9xxx->slim->e_addr, sizeof(wcd9xxx->slim->e_addr));
-	WARN_ON(sizeof(wcd9xxx->slim->e_addr) != 6);
-	cfg->device_enum_addr_lsw = eaddr & 0xFFFFFFFF;
-	cfg->device_enum_addr_msw = eaddr >> 32;
-
-	pr_debug("%s: slimbus logical address 0x%llx\n", __func__, eaddr);
-}
-
-static int taiko_device_down(struct wcd9xxx *wcd9xxx)
-{
-	struct snd_soc_codec *codec;
-
-	codec = (struct snd_soc_codec *)(wcd9xxx->ssr_priv);
-	snd_soc_card_change_online_state(codec->card, 0);
-
-	return 0;
-}
-
-static int wcd9xxx_prepare_static_pa(struct wcd9xxx_mbhc *mbhc,
-				     struct list_head *lh)
-{
-	int i;
-	struct snd_soc_codec *codec = mbhc->codec;
-
-	const struct wcd9xxx_reg_mask_val reg_set_paon[] = {
-		{WCD9XXX_A_RX_HPH_OCP_CTL, 0x18, 0x00},
-		{WCD9XXX_A_RX_HPH_L_TEST, 0x1, 0x0},
-		{WCD9XXX_A_RX_HPH_R_TEST, 0x1, 0x0},
-		{WCD9XXX_A_RX_HPH_BIAS_WG_OCP, 0xff, 0x1A},
-		{WCD9XXX_A_RX_HPH_CNP_WG_CTL, 0xff, 0xDB},
-		{WCD9XXX_A_RX_HPH_CNP_WG_TIME, 0xff, 0x15},
-		{WCD9XXX_A_CDC_RX1_B6_CTL, 0xff, 0x81},
-		{WCD9XXX_A_CDC_CLK_RX_B1_CTL, 0x01, 0x01},
-		{WCD9XXX_A_RX_HPH_CHOP_CTL, 0xff, 0xA4},
-		{WCD9XXX_A_RX_HPH_L_GAIN, 0xff, 0x2C},
-		{WCD9XXX_A_CDC_RX2_B6_CTL, 0xff, 0x81},
-		{WCD9XXX_A_CDC_CLK_RX_B1_CTL, 0x02, 0x02},
-		{WCD9XXX_A_RX_HPH_R_GAIN, 0xff, 0x2C},
-		{WCD9XXX_A_NCP_CLK, 0xff, 0xFC},
-		{WCD9XXX_A_BUCK_CTRL_CCL_3, 0xff, 0x60},
-		{WCD9XXX_A_RX_COM_BIAS, 0xff, 0x80},
-		{WCD9XXX_A_BUCK_MODE_3, 0xff, 0xC6},
-		{WCD9XXX_A_BUCK_MODE_4, 0xff, 0xE6},
-		{WCD9XXX_A_BUCK_MODE_5, 0xff, 0x02},
-		{WCD9XXX_A_BUCK_MODE_1, 0xff, 0xA1},
-		{WCD9XXX_A_NCP_EN, 0xff, 0xFF},
-		{WCD9XXX_A_BUCK_MODE_5, 0xff, 0x7B},
-		{WCD9XXX_A_CDC_CLSH_B1_CTL, 0xff, 0xE6},
-		{WCD9XXX_A_RX_HPH_L_DAC_CTL, 0xff, 0xC0},
-		{WCD9XXX_A_RX_HPH_R_DAC_CTL, 0xff, 0xC0},
-	};
-
-	for (i = 0; i < ARRAY_SIZE(reg_set_paon); i++)
-		wcd9xxx_soc_update_bits_push(codec, lh,
-					     reg_set_paon[i].reg,
-					     reg_set_paon[i].mask,
-					     reg_set_paon[i].val, 0);
-	pr_debug("%s: PAs are prepared\n", __func__);
-
-	return 0;
-}
-
-static int wcd9xxx_enable_static_pa(struct wcd9xxx_mbhc *mbhc, bool enable)
-{
-	struct snd_soc_codec *codec = mbhc->codec;
-	const int wg_time = snd_soc_read(codec, WCD9XXX_A_RX_HPH_CNP_WG_TIME) *
-			    TAIKO_WG_TIME_FACTOR_US;
-
-	snd_soc_update_bits(codec, WCD9XXX_A_RX_HPH_CNP_EN, 0x30,
-			    enable ? 0x30 : 0x0);
-	/* Wait for wave gen time to avoid pop noise */
-	usleep_range(wg_time, wg_time + WCD9XXX_USLEEP_RANGE_MARGIN_US);
-	pr_debug("%s: PAs are %s as static mode (wg_time %d)\n", __func__,
-		 enable ? "enabled" : "disabled", wg_time);
-	return 0;
-}
-
-static int taiko_setup_zdet(struct wcd9xxx_mbhc *mbhc,
-			    enum mbhc_impedance_detect_stages stage)
-{
-	int ret = 0;
-	struct snd_soc_codec *codec = mbhc->codec;
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-	const int ramp_wait_us = 18 * 1000;
-
-#define __wr(reg, mask, value)						  \
-	do {								  \
-		ret = wcd9xxx_soc_update_bits_push(codec,		  \
-						   &taiko->reg_save_restore, \
-						   reg, mask, value, 0);  \
-		if (ret < 0)						  \
-			return ret;					  \
-	} while (0)
-
-	switch (stage) {
-
-	case PRE_MEAS:
-		INIT_LIST_HEAD(&taiko->reg_save_restore);
-		wcd9xxx_prepare_static_pa(mbhc, &taiko->reg_save_restore);
-		wcd9xxx_enable_static_pa(mbhc, true);
-
-		/*
-		 * save old value of registers and write the new value to
-		 * restore old value back, WCD9XXX_A_CDC_PA_RAMP_B{1,2,3,4}_CTL
-		 * registers don't need to be restored as those are solely used
-		 * by impedance detection.
-		 */
-		/* Phase 1 */
-		/* Reset the PA Ramp */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B1_CTL, 0x1C);
-		/*
-		 * Connect the PA Ramp to PA chain and release reset with
-		 * keep it connected.
-		 */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B1_CTL, 0x1F);
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B1_CTL, 0x03);
-		/*
-		 * Program the PA Ramp to FS_48K, L shift 1 and sample
-		 * num to 24
-		 */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B3_CTL,
-			      0x3 << 4 | 0x6);
-		/* 0x56 for 10mv.  0xC0 is for 50mv */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B4_CTL, 0xC0);
-		/* Enable MBHC MUX, Set MUX current to 37.5uA and ADC7 */
-		__wr(WCD9XXX_A_MBHC_SCALING_MUX_1, 0xFF, 0xC0);
-		__wr(WCD9XXX_A_MBHC_SCALING_MUX_2, 0xFF, 0xF0);
-		__wr(WCD9XXX_A_TX_7_MBHC_TEST_CTL, 0xFF, 0x78);
-		__wr(WCD9XXX_A_TX_7_MBHC_EN, 0xFF, 0x8C);
-		/* Change NSA and NAVG */
-		__wr(WCD9XXX_A_CDC_MBHC_TIMER_B4_CTL, 0x4 << 4, 0x4 << 4);
-		__wr(WCD9XXX_A_CDC_MBHC_TIMER_B5_CTL, 0xFF, 0x10);
-		/* Reset MBHC and set it up for STA */
-		__wr(WCD9XXX_A_CDC_MBHC_CLK_CTL, 0xFF, 0x0A);
-		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_EN_CTL, 0x2);
-		__wr(WCD9XXX_A_CDC_MBHC_CLK_CTL, 0xFF, 0x02);
-
-		/* Set HPH_MBHC for zdet */
-		__wr(WCD9XXX_A_MBHC_HPH, 0xB3, 0x80);
-		break;
-	case POST_MEAS:
-		/* Phase 2 */
-		/* Start the PA ramp on HPH L and R */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B2_CTL, 0x05);
-		/* Ramp generator takes ~17ms */
-		usleep_range(ramp_wait_us,
-				ramp_wait_us + WCD9XXX_USLEEP_RANGE_MARGIN_US);
-
-		/* Disable Ical */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B2_CTL, 0x00);
-		/* Ramp generator takes ~17ms */
-		usleep_range(ramp_wait_us,
-				ramp_wait_us + WCD9XXX_USLEEP_RANGE_MARGIN_US);
-		break;
-	case PA_DISABLE:
-		/* Ramp HPH L & R back to Zero */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B2_CTL, 0x0A);
-		/* Ramp generator takes ~17ms */
-		usleep_range(ramp_wait_us,
-				ramp_wait_us + WCD9XXX_USLEEP_RANGE_MARGIN_US);
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B2_CTL, 0x00);
-
-		/* Clean up starts */
-		/* Turn off PA ramp generator */
-		snd_soc_write(codec, WCD9XXX_A_CDC_PA_RAMP_B1_CTL, 0x0);
-		if (!mbhc->hph_pa_dac_state &&
-		    (!(test_bit(MBHC_EVENT_PA_HPHL, &mbhc->event_state) ||
-		       test_bit(MBHC_EVENT_PA_HPHR, &mbhc->event_state))))
-			wcd9xxx_enable_static_pa(mbhc, false);
-		wcd9xxx_restore_registers(codec, &taiko->reg_save_restore);
-		break;
-	}
-#undef __wr
-
-	return ret;
-}
-
-static void taiko_compute_impedance(s16 *l, s16 *r, uint32_t *zl, uint32_t *zr)
-{
-
-	int64_t rl, rr = 0; /* milliohm */
-	const int alphal = 364; /* 0.005555 * 65536 = 364.05 */
-	const int alphar = 364; /* 0.005555 * 65536 = 364.05 */
-	const int beta = 3855; /* 0.011765 * 5 * 65536 = 3855.15 */
-	const int rref = 11333; /* not scaled up */
-	const int shift = 16;
-
-	rl = (int)(l[0] - l[1]) * 1000 / (l[0] - l[2]);
-	rl = rl * rref * alphal;
-	rl = rl >> shift;
-	rl = rl * beta;
-	rl = rl >> shift;
-	*zl = rl;
-
-	rr = (int)(r[0] - r[1]) * 1000 / (r[0] - r[2]);
-	rr = rr * rref  * alphar;
-	rr = rr >> shift;
-	rr = rr * beta;
-	rr = rr >> shift;
-	*zr = rr;
-}
-
-static enum wcd9xxx_cdc_type taiko_get_cdc_type(void)
-{
-	return WCD9XXX_CDC_TYPE_TAIKO;
-}
-
-static const struct wcd9xxx_mbhc_cb mbhc_cb = {
-	.get_cdc_type = taiko_get_cdc_type,
-	.setup_zdet = taiko_setup_zdet,
-	.compute_impedance = taiko_compute_impedance,
-	.get_hwdep_fw_cal = taiko_get_hwdep_fw_cal,
-};
-
-static const struct wcd9xxx_mbhc_intr cdc_intr_ids = {
-	.poll_plug_rem = WCD9XXX_IRQ_MBHC_REMOVAL,
-	.shortavg_complete = WCD9XXX_IRQ_MBHC_SHORT_TERM,
-	.potential_button_press = WCD9XXX_IRQ_MBHC_PRESS,
-	.button_release = WCD9XXX_IRQ_MBHC_RELEASE,
-	.dce_est_complete = WCD9XXX_IRQ_MBHC_POTENTIAL,
-	.insertion = WCD9XXX_IRQ_MBHC_INSERTION,
-	.hph_left_ocp = WCD9XXX_IRQ_HPH_PA_OCPL_FAULT,
-	.hph_right_ocp = WCD9XXX_IRQ_HPH_PA_OCPR_FAULT,
-	.hs_jack_switch = WCD9320_IRQ_MBHC_JACK_SWITCH,
-};
-
-static int taiko_post_reset_cb(struct wcd9xxx *wcd9xxx)
-{
-	int ret = 0;
-	struct snd_soc_codec *codec;
-	struct taiko_priv *taiko;
-	int rco_clk_rate;
-	int count;
-
-	codec = (struct snd_soc_codec *)(wcd9xxx->ssr_priv);
-	taiko = snd_soc_codec_get_drvdata(codec);
-
-	snd_soc_card_change_online_state(codec->card, 1);
-
-	mutex_lock(&codec->mutex);
-
-        if (codec->reg_def_copy) {
-            pr_debug("%s: Update ASOC cache", __func__);
-            kfree(codec->reg_cache);
-            codec->reg_cache = kmemdup(codec->reg_def_copy,
-                                            codec->reg_size, GFP_KERNEL);
-            if (!codec->reg_cache) {
-                pr_err("%s: Cache update failed!\n", __func__);
-                mutex_unlock(&codec->mutex);
-                return -ENOMEM;
-            }
-        }
-
-	taiko_update_reg_defaults(codec);
-	if (wcd9xxx->mclk_rate == TAIKO_MCLK_CLK_12P288MHZ)
-		snd_soc_update_bits(codec, TAIKO_A_CHIP_CTL, 0x06, 0x0);
-	else if (wcd9xxx->mclk_rate == TAIKO_MCLK_CLK_9P6MHZ)
-		snd_soc_update_bits(codec, TAIKO_A_CHIP_CTL, 0x06, 0x2);
-	taiko_codec_init_reg(codec);
-
-	if (spkr_drv_wrnd == 1)
-		snd_soc_update_bits(codec, TAIKO_A_SPKR_DRV_EN, 0x80, 0x80);
-
-	codec->cache_sync = true;
-	snd_soc_cache_sync(codec);
-	codec->cache_sync = false;
-
-	ret = taiko_handle_pdata(taiko);
-	if (IS_ERR_VALUE(ret))
-		pr_err("%s: bad pdata\n", __func__);
-
-	taiko_init_slim_slave_cfg(codec);
-	taiko_slim_interface_init_reg(codec);
-
-	wcd9xxx_resmgr_post_ssr(&taiko->resmgr);
-
-	if (taiko->mbhc_started) {
-		wcd9xxx_mbhc_deinit(&taiko->mbhc);
-		taiko->mbhc_started = false;
-
-		if (TAIKO_IS_1_0(wcd9xxx->version))
-			rco_clk_rate = TAIKO_MCLK_CLK_12P288MHZ;
-		else
-			rco_clk_rate = TAIKO_MCLK_CLK_9P6MHZ;
-
-		ret = wcd9xxx_mbhc_init(&taiko->mbhc, &taiko->resmgr, codec,
-					taiko_enable_mbhc_micbias,
-					&mbhc_cb, &cdc_intr_ids,
-					rco_clk_rate, false);
-		if (ret)
-			pr_err("%s: mbhc init failed %d\n", __func__, ret);
-		else
-			taiko_hs_detect(codec, taiko->mbhc.mbhc_cfg);
-	}
-	taiko->machine_codec_event_cb(codec, WCD9XXX_CODEC_EVENT_CODEC_UP);
-
-	taiko_cleanup_irqs(taiko);
-	ret = taiko_setup_irqs(taiko);
-	if (ret)
-		pr_err("%s: Failed to setup irq: %d\n", __func__, ret);
-
-	for (count = 0; count < NUM_CODEC_DAIS; count++)
-		taiko->dai[count].bus_down_in_recovery = true;
-
-	mutex_unlock(&codec->mutex);
-	return ret;
-}
-
-void *taiko_get_afe_config(struct snd_soc_codec *codec,
-			   enum afe_config_type config_type)
-{
-	struct taiko_priv *priv = snd_soc_codec_get_drvdata(codec);
-	struct wcd9xxx *taiko_core = dev_get_drvdata(codec->dev->parent);
-
-	switch (config_type) {
-	case AFE_SLIMBUS_SLAVE_CONFIG:
-		return &priv->slimbus_slave_cfg;
-	case AFE_CDC_REGISTERS_CONFIG:
-		return &taiko_audio_reg_cfg;
-	case AFE_SLIMBUS_SLAVE_PORT_CONFIG:
-		return &taiko_slimbus_slave_port_cfg;
-	case AFE_AANC_VERSION:
-		return &taiko_cdc_aanc_version;
-	case AFE_CLIP_BANK_SEL:
-		if (!TAIKO_IS_1_0(taiko_core->version))
-			return &clip_bank_sel;
-		else
-			return NULL;
-	case AFE_CDC_CLIP_REGISTERS_CONFIG:
-		if (!TAIKO_IS_1_0(taiko_core->version))
-			return &taiko_clip_reg_cfg;
-		else
-			return NULL;
-	default:
-		pr_err("%s: Unknown config_type 0x%x\n", __func__, config_type);
-		return NULL;
-	}
-}
-
-static struct wcd9xxx_reg_address taiko_reg_address = {
-	.micb_4_mbhc = TAIKO_A_MICB_4_MBHC,
-	.micb_4_int_rbias = TAIKO_A_MICB_4_INT_RBIAS,
-	.micb_4_ctl = TAIKO_A_MICB_4_CTL,
-};
-
-static int wcd9xxx_ssr_register(struct wcd9xxx *control,
-				int (*device_down_cb)(struct wcd9xxx *wcd9xxx),
-				int (*device_up_cb)(struct wcd9xxx *wcd9xxx),
-				void *priv)
-{
-	control->dev_down = device_down_cb;
-	control->post_reset = device_up_cb;
-	control->ssr_priv = priv;
-	return 0;
-}
-
-static const struct snd_soc_dapm_widget taiko_1_dapm_widgets[] = {
-	SND_SOC_DAPM_ADC_E("ADC1", NULL, TAIKO_A_TX_1_2_EN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU |
-			   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC2", NULL, TAIKO_A_TX_1_2_EN, 3, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU |
-			   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC3", NULL, TAIKO_A_TX_3_4_EN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			   SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC4", NULL, TAIKO_A_TX_3_4_EN, 3, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			   SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC5", NULL, TAIKO_A_TX_5_6_EN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_ADC_E("ADC6", NULL, TAIKO_A_TX_5_6_EN, 3, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_POST_PMU),
-};
-
-static const struct snd_soc_dapm_widget taiko_2_dapm_widgets[] = {
-	SND_SOC_DAPM_ADC_E("ADC1", NULL, TAIKO_A_CDC_TX_1_GAIN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU |
-			   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC2", NULL, TAIKO_A_CDC_TX_2_GAIN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU |
-			   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC3", NULL, TAIKO_A_CDC_TX_3_GAIN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			   SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC4", NULL, TAIKO_A_CDC_TX_4_GAIN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-			   SND_SOC_DAPM_POST_PMD),
-	SND_SOC_DAPM_ADC_E("ADC5", NULL, TAIKO_A_CDC_TX_5_GAIN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_POST_PMU),
-	SND_SOC_DAPM_ADC_E("ADC6", NULL, TAIKO_A_CDC_TX_6_GAIN, 7, 0,
-			   taiko_codec_enable_adc,
-			   SND_SOC_DAPM_POST_PMU),
-};
-
-static struct regulator *taiko_codec_find_regulator(struct snd_soc_codec *codec,
-						    const char *name)
-{
-	int i;
-	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
-
-	for (i = 0; i < core->num_of_supplies; i++) {
-		if (core->supplies[i].supply &&
-		    !strcmp(core->supplies[i].supply, name))
-			return core->supplies[i].consumer;
-	}
-
-	return NULL;
-}
-
-static int taiko_codec_probe(struct snd_soc_codec *codec)
-{
-	struct wcd9xxx *control;
-	struct taiko_priv *taiko;
-	struct wcd9xxx_pdata *pdata;
-	struct wcd9xxx *wcd9xxx;
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-#if defined(CONFIG_SEC_JACTIVE_PROJECT)
-	extern unsigned int system_rev;
-#endif
-	int ret = 0;
-	int i, rco_clk_rate;
-	void *ptr = NULL;
-	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
-	struct wcd9xxx_core_resource *core_res;
-
-	codec->control_data = dev_get_drvdata(codec->dev->parent);
-	control = codec->control_data;
-
-	wcd9xxx_ssr_register(control, taiko_device_down,
-			     taiko_post_reset_cb, (void *)codec);
-
-	dev_info(codec->dev, "%s()\n", __func__);
-
-	taiko = kzalloc(sizeof(struct taiko_priv), GFP_KERNEL);
-	if (!taiko) {
-		dev_err(codec->dev, "Failed to allocate private data\n");
-		return -ENOMEM;
-	}
-	for (i = 0 ; i < NUM_DECIMATORS; i++) {
-		tx_hpf_work[i].taiko = taiko;
-		tx_hpf_work[i].decimator = i + 1;
-		INIT_DELAYED_WORK(&tx_hpf_work[i].dwork,
-			tx_hpf_corner_freq_callback);
-	}
-
-	snd_soc_codec_set_drvdata(codec, taiko);
-
-	/* codec resmgr module init */
-	wcd9xxx = codec->control_data;
-	core_res = &wcd9xxx->core_res;
-	pdata = dev_get_platdata(codec->dev->parent);
-	ret = wcd9xxx_resmgr_init(&taiko->resmgr, codec, core_res, pdata,
-				  &pdata->micbias, &taiko_reg_address,
-				  WCD9XXX_CDC_TYPE_TAIKO);
-	if (ret) {
-		pr_err("%s: wcd9xxx init failed %d\n", __func__, ret);
-		goto err_nomem_slimch;
-	}
-
-	taiko->clsh_d.buck_mv = taiko_codec_get_buck_mv(codec);
-	/* Taiko does not support dynamic switching of vdd_cp */
-	taiko->clsh_d.is_dynamic_vdd_cp = false;
-	wcd9xxx_clsh_init(&taiko->clsh_d, &taiko->resmgr);
-
-	if (TAIKO_IS_1_0(core->version))
-		rco_clk_rate = TAIKO_MCLK_CLK_12P288MHZ;
-	else
-		rco_clk_rate = TAIKO_MCLK_CLK_9P6MHZ;
-	taiko->fw_data = kzalloc(sizeof(*(taiko->fw_data)), GFP_KERNEL);
-	if (!taiko->fw_data) {
-		dev_err(codec->dev, "Failed to allocate fw_data\n");
-		goto err_nomem_slimch;
-	}
-	set_bit(WCD9XXX_ANC_CAL, taiko->fw_data->cal_bit);
-	set_bit(WCD9XXX_MAD_CAL, taiko->fw_data->cal_bit);
-	set_bit(WCD9XXX_MBHC_CAL, taiko->fw_data->cal_bit);
-	ret = wcd_cal_create_hwdep(taiko->fw_data,
-					WCD9XXX_CODEC_HWDEP_NODE, codec);
-	if (ret < 0) {
-		dev_err(codec->dev, "%s hwdep failed %d\n", __func__, ret);
-		goto err_hwdep;
-	}
-
-#if defined(CONFIG_MACH_KLTE_KOR)
-	if (system_rev >= 13) {
-		/* init and start mbhc */
-		ret = wcd9xxx_mbhc_init(&taiko->mbhc, &taiko->resmgr, codec,
-					taiko_enable_mbhc_micbias,
-					&mbhc_cb, &cdc_intr_ids,
-					rco_clk_rate, false);
-		if (ret) {
-			pr_err("%s: mbhc init failed %d\n", __func__, ret);
-			goto err_hwdep;
-		}
-	}
-#elif defined(CONFIG_MACH_KLTE_JPN)
-	if (system_rev >= 11) {
-		/* init and start mbhc */
-		ret = wcd9xxx_mbhc_init(&taiko->mbhc, &taiko->resmgr, codec,
-					taiko_enable_mbhc_micbias,
-					&mbhc_cb, &cdc_intr_ids,
-					rco_clk_rate, false);
-		if (ret) {
-			pr_err("%s: mbhc init failed %d\n", __func__, ret);
-			goto err_hwdep;
-		}
-	}
-#else
-#if !defined(CONFIG_SAMSUNG_JACK) && !defined(CONFIG_MUIC_DET_JACK)
-	/* init and start mbhc */
-	ret = wcd9xxx_mbhc_init(&taiko->mbhc, &taiko->resmgr, codec,
-				taiko_enable_mbhc_micbias,
-				&mbhc_cb, &cdc_intr_ids,
-				rco_clk_rate, false);
-	if (ret) {
-		pr_err("%s: mbhc init failed %d\n", __func__, ret);
-		goto err_hwdep;
-	}
-#elif defined(CONFIG_SEC_JACTIVE_PROJECT)
-/* init and start mbhc */
-	pr_info("taiko_codec_probe system_rev %d",system_rev);
-	if(system_rev < 3)
-	{
-        ret = wcd9xxx_mbhc_init(&taiko->mbhc, &taiko->resmgr, codec,
-                    taiko_enable_mbhc_micbias,
-                    &mbhc_cb, &cdc_intr_ids,
-                    rco_clk_rate, false);
-        if (ret) {
-            pr_err("%s: mbhc init failed %d\n", __func__, ret);
-            goto err_hwdep;
-        }
-	}
-#endif
-#endif
-
-	taiko->codec = codec;
-	for (i = 0; i < COMPANDER_MAX; i++) {
-		taiko->comp_enabled[i] = 0;
-		taiko->comp_fs[i] = COMPANDER_FS_48KHZ;
-	}
-	taiko->intf_type = wcd9xxx_get_intf_type();
-	taiko->aux_pga_cnt = 0;
-	taiko->aux_l_gain = 0x1F;
-	taiko->aux_r_gain = 0x1F;
-	taiko->ldo_h_users = 0;
-	taiko->micb_2_users = 0;
-	taiko_update_reg_defaults(codec);
-	pr_debug("%s: MCLK Rate = %x\n", __func__, wcd9xxx->mclk_rate);
-	if (wcd9xxx->mclk_rate == TAIKO_MCLK_CLK_12P288MHZ)
-		snd_soc_update_bits(codec, TAIKO_A_CHIP_CTL, 0x06, 0x0);
-	else if (wcd9xxx->mclk_rate == TAIKO_MCLK_CLK_9P6MHZ)
-		snd_soc_update_bits(codec, TAIKO_A_CHIP_CTL, 0x06, 0x2);
-	taiko_codec_init_reg(codec);
-	ret = taiko_handle_pdata(taiko);
-	if (IS_ERR_VALUE(ret)) {
-		pr_err("%s: bad pdata\n", __func__);
-		goto err_hwdep;
-	}
-
-	taiko->spkdrv_reg = taiko_codec_find_regulator(codec,
-						       WCD9XXX_VDD_SPKDRV_NAME);
-
-	if (spkr_drv_wrnd > 0) {
-		WCD9XXX_BG_CLK_LOCK(&taiko->resmgr);
-		wcd9xxx_resmgr_get_bandgap(&taiko->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-		WCD9XXX_BG_CLK_UNLOCK(&taiko->resmgr);
-	}
-
-#if defined(CONFIG_SND_SOC_ESXXX)
-	remote_add_codec_controls(codec);
-#elif defined(CONFIG_SND_SOC_ES325)
-	es325_remote_add_codec_controls(codec);
-#endif
-
-	ptr = kmalloc((sizeof(taiko_rx_chs) +
-		       sizeof(taiko_tx_chs)), GFP_KERNEL);
-	if (!ptr) {
-		pr_err("%s: no mem for slim chan ctl data\n", __func__);
-		ret = -ENOMEM;
-		goto err_hwdep;
-	}
-
-	if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
-		snd_soc_dapm_new_controls(dapm, taiko_dapm_i2s_widgets,
-			ARRAY_SIZE(taiko_dapm_i2s_widgets));
-		snd_soc_dapm_add_routes(dapm, audio_i2s_map,
-			ARRAY_SIZE(audio_i2s_map));
-		if (TAIKO_IS_1_0(core->version))
-			snd_soc_dapm_add_routes(dapm, audio_i2s_map_1_0,
-						ARRAY_SIZE(audio_i2s_map_1_0));
-		else
-			snd_soc_dapm_add_routes(dapm, audio_i2s_map_2_0,
-						ARRAY_SIZE(audio_i2s_map_2_0));
-		for (i = 0; i < ARRAY_SIZE(taiko_i2s_dai); i++)
-			INIT_LIST_HEAD(&taiko->dai[i].wcd9xxx_ch_list);
-	} else if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_SLIMBUS) {
-		for (i = 0; i < NUM_CODEC_DAIS; i++) {
-			INIT_LIST_HEAD(&taiko->dai[i].wcd9xxx_ch_list);
-			init_waitqueue_head(&taiko->dai[i].dai_wait);
-		}
-		taiko_slimbus_slave_port_cfg.slave_dev_intfdev_la =
-		    control->slim_slave->laddr;
-		taiko_slimbus_slave_port_cfg.slave_dev_pgd_la =
-		    control->slim->laddr;
-		taiko_slimbus_slave_port_cfg.slave_port_mapping[0] =
-		    TAIKO_MAD_SLIMBUS_TX_PORT;
-
-		taiko_init_slim_slave_cfg(codec);
-	}
-
-	if (TAIKO_IS_1_0(control->version)) {
-		snd_soc_dapm_new_controls(dapm, taiko_1_dapm_widgets,
-					  ARRAY_SIZE(taiko_1_dapm_widgets));
-		snd_soc_add_codec_controls(codec,
-			taiko_1_x_analog_gain_controls,
-			ARRAY_SIZE(taiko_1_x_analog_gain_controls));
-	} else {
-		snd_soc_dapm_new_controls(dapm, taiko_2_dapm_widgets,
-					  ARRAY_SIZE(taiko_2_dapm_widgets));
-		snd_soc_add_codec_controls(codec,
-			taiko_2_x_analog_gain_controls,
-			ARRAY_SIZE(taiko_2_x_analog_gain_controls));
-	}
-
-	snd_soc_add_codec_controls(codec, impedance_detect_controls,
-				   ARRAY_SIZE(impedance_detect_controls));
-
-	control->num_rx_port = TAIKO_RX_MAX;
-	control->rx_chs = ptr;
-	memcpy(control->rx_chs, taiko_rx_chs, sizeof(taiko_rx_chs));
-	control->num_tx_port = TAIKO_TX_MAX;
-	control->tx_chs = ptr + sizeof(taiko_rx_chs);
-	memcpy(control->tx_chs, taiko_tx_chs, sizeof(taiko_tx_chs));
-
-	snd_soc_dapm_sync(dapm);
-
-	ret = taiko_setup_irqs(taiko);
-	if (ret) {
-		pr_err("%s: taiko irq setup failed %d\n", __func__, ret);
-		goto err_irq;
-	}
-
-	atomic_set(&kp_taiko_priv, (unsigned long)taiko);
-	mutex_lock(&dapm->codec->mutex);
-	snd_soc_dapm_disable_pin(dapm, "ANC HPHL");
-	snd_soc_dapm_disable_pin(dapm, "ANC HPHR");
-	snd_soc_dapm_disable_pin(dapm, "ANC HEADPHONE");
-	snd_soc_dapm_disable_pin(dapm, "ANC EAR PA");
-	snd_soc_dapm_disable_pin(dapm, "ANC EAR");
-	snd_soc_dapm_sync(dapm);
-	mutex_unlock(&dapm->codec->mutex);
-
-	codec->ignore_pmdown_time = 1;
-	return ret;
-
-err_irq:
-	taiko_cleanup_irqs(taiko);
-        kfree(ptr);
-err_hwdep:
-	kfree(taiko->fw_data);
-err_nomem_slimch:
-	kfree(taiko);
-	return ret;
-}
-static int taiko_codec_remove(struct snd_soc_codec *codec)
-{
-	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
-#if defined(CONFIG_SEC_JACTIVE_PROJECT)
-	extern unsigned int system_rev;
-#endif
-	WCD9XXX_BG_CLK_LOCK(&taiko->resmgr);
-	atomic_set(&kp_taiko_priv, 0);
-
-	if (spkr_drv_wrnd > 0)
-		wcd9xxx_resmgr_put_bandgap(&taiko->resmgr,
-					   WCD9XXX_BANDGAP_AUDIO_MODE);
-	WCD9XXX_BG_CLK_UNLOCK(&taiko->resmgr);
-
-	taiko_cleanup_irqs(taiko);
-
-#if defined(CONFIG_MACH_KLTE_KOR)
-	if (system_rev >= 13) {
-		/* cleanup MBHC */
-		wcd9xxx_mbhc_deinit(&taiko->mbhc);
-	}
-#elif defined(CONFIG_MACH_KLTE_JPN)
-	if (system_rev >= 11) {
-		/* cleanup MBHC */
-		wcd9xxx_mbhc_deinit(&taiko->mbhc);
-	}
-#else
-#if !defined(CONFIG_SAMSUNG_JACK) && !defined(CONFIG_MUIC_DET_JACK)
-	/* cleanup MBHC */
-	wcd9xxx_mbhc_deinit(&taiko->mbhc);
-#elif defined(CONFIG_SEC_JACTIVE_PROJECT)
-	pr_info("taiko_codec_remove system_rev %d",system_rev);
-	if(system_rev < 3)
-	{
-		wcd9xxx_mbhc_deinit(&taiko->mbhc);
-	}
-#endif
-#endif
-	/* cleanup resmgr */
-	wcd9xxx_resmgr_deinit(&taiko->resmgr);
-
-	taiko->spkdrv_reg = NULL;
-
-	kfree(taiko->fw_data);
-	kfree(taiko);
-	return 0;
-}
-static struct snd_soc_codec_driver soc_codec_dev_taiko = {
-	.probe	= taiko_codec_probe,
-	.remove	= taiko_codec_remove,
-
-	.read = taiko_read,
-	.write = taiko_write,
-
-	.readable_register = taiko_readable,
-	.volatile_register = taiko_volatile,
-
-	.reg_cache_size = TAIKO_CACHE_SIZE,
-	.reg_cache_default = taiko_reset_reg_defaults,
-	.reg_word_size = 1,
-
-	.controls = taiko_snd_controls,
-	.num_controls = ARRAY_SIZE(taiko_snd_controls),
-	.dapm_widgets = taiko_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(taiko_dapm_widgets),
-	.dapm_routes = audio_map,
-	.num_dapm_routes = ARRAY_SIZE(audio_map),
-};
-
-#ifdef CONFIG_PM
-static int taiko_suspend(struct device *dev)
-{
-	dev_dbg(dev, "%s: system suspend\n", __func__);
-	return 0;
-}
-
-static int taiko_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct taiko_priv *taiko = platform_get_drvdata(pdev);
-
-	if (!taiko) {
-		dev_err(dev, "%s: taiko private data is NULL\n", __func__);
-		return -EINVAL;
-	}
-	dev_dbg(dev, "%s: system resume\n", __func__);
-	/* Notify */
-	wcd9xxx_resmgr_notifier_call(&taiko->resmgr, WCD9XXX_EVENT_POST_RESUME);
-	return 0;
-}
-
-static const struct dev_pm_ops taiko_pm_ops = {
-	.suspend	= taiko_suspend,
-	.resume		= taiko_resume,
-};
-#endif
-
-static int __devinit taiko_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS)
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_taiko,
-			taiko_dai, ARRAY_SIZE(taiko_dai));
-	else if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)
-		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_taiko,
-			taiko_i2s_dai, ARRAY_SIZE(taiko_i2s_dai));
-	return ret;
-}
-static int __devexit taiko_remove(struct platform_device *pdev)
-{
-	snd_soc_unregister_codec(&pdev->dev);
-	return 0;
-}
-static struct platform_driver taiko_codec_driver = {
-	.probe = taiko_probe,
-	.remove = taiko_remove,
-	.driver = {
-		.name = "taiko_codec",
-		.owner = THIS_MODULE,
-#ifdef CONFIG_PM
-		.pm = &taiko_pm_ops,
-#endif
-	},
-};
-
-static int __init taiko_codec_init(void)
-{
-	return platform_driver_register(&taiko_codec_driver);
-}
-
-static void __exit taiko_codec_exit(void)
-{
-	platform_driver_unregister(&taiko_codec_driver);
-}
-
-module_init(taiko_codec_init);
-module_exit(taiko_codec_exit);
-
-MODULE_DESCRIPTION("Taiko codec driver");
-MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/wcd9320.o_shipped b/sound/soc/codecs/wcd9320.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..d81904a39263ee39036053768cef9f4707c6e279
GIT binary patch
literal 148052
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
U%8(#4@v+u;+&lDsD~OofU(mQRh5!Hn

literal 0
HcmV?d00001

-- 
2.11.0

