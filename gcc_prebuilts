From 2a3684b17b2cffa7b1373abb4723cbd5a5c37583 Mon Sep 17 00:00:00 2001
From: Samuel Pascua <pascua.samuel.14@gmail.com>
Date: Tue, 1 Oct 2019 10:11:59 +0800
Subject: [PATCH] asd

---
 fs/f2fs/segment.c         | 2754 -------------------------------------
 fs/f2fs/segment.o_shipped |  Bin 0 -> 47584 bytes
 2 files changed, 2754 deletions(-)
 delete mode 100644 fs/f2fs/segment.c
 create mode 100644 fs/f2fs/segment.o_shipped

diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.c
deleted file mode 100644
index 34a1c1394f1d..000000000000
--- a/fs/f2fs/segment.c
+++ /dev/null
@@ -1,2754 +0,0 @@
-/*
- * fs/f2fs/segment.c
- *
- * Copyright (c) 2012 Samsung Electronics Co., Ltd.
- *             http://www.samsung.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/fs.h>
-#include <linux/f2fs_fs.h>
-#include <linux/bio.h>
-#include <linux/blkdev.h>
-#include <linux/prefetch.h>
-#include <linux/kthread.h>
-#include <linux/swap.h>
-#include <linux/timer.h>
-
-#include "f2fs.h"
-#include "segment.h"
-#include "node.h"
-#include "trace.h"
-#include <trace/events/f2fs.h>
-
-#define __reverse_ffz(x) __reverse_ffs(~(x))
-
-static struct kmem_cache *discard_entry_slab;
-static struct kmem_cache *sit_entry_set_slab;
-static struct kmem_cache *inmem_entry_slab;
-
-static unsigned long __reverse_ulong(unsigned char *str)
-{
-	unsigned long tmp = 0;
-	int shift = 24, idx = 0;
-
-#if BITS_PER_LONG == 64
-	shift = 56;
-#endif
-	while (shift >= 0) {
-		tmp |= (unsigned long)str[idx++] << shift;
-		shift -= BITS_PER_BYTE;
-	}
-	return tmp;
-}
-
-/**
- * Copied from latest lib/llist.c
- * llist_for_each_entry_safe - iterate over some deleted entries of
- *                             lock-less list of given type
- *			       safe against removal of list entry
- * @pos:	the type * to use as a loop cursor.
- * @n:		another type * to use as temporary storage
- * @node:	the first entry of deleted list entries.
- * @member:	the name of the llist_node with the struct.
- *
- * In general, some entries of the lock-less list can be traversed
- * safely only after being removed from list, so start with an entry
- * instead of list head.
- *
- * If being used on entries deleted from lock-less list directly, the
- * traverse order is from the newest to the oldest added entry.  If
- * you want to traverse from the oldest to the newest, you must
- * reverse the order by yourself before traversing.
- */
-#define llist_for_each_entry_safe(pos, n, node, member)			       \
-	for (pos = llist_entry((node), typeof(*pos), member);		       \
-		&pos->member != NULL &&					       \
-		(n = llist_entry(pos->member.next, typeof(*n), member), true); \
-		pos = n)
-
-/**
- * Copied from latest lib/llist.c
- * llist_reverse_order - reverse order of a llist chain
- * @head:	first item of the list to be reversed
- *
- * Reverse the order of a chain of llist entries and return the
- * new first entry.
- */
-struct llist_node *llist_reverse_order(struct llist_node *head)
-{
-	struct llist_node *new_head = NULL;
-
-	while (head) {
-		struct llist_node *tmp = head;
-		head = head->next;
-		tmp->next = new_head;
-		new_head = tmp;
-	}
-
-	return new_head;
-}
-
-/**
- * Copied from latest linux/list.h
- * list_last_entry - get the last element from a list
- * @ptr:        the list head to take the element from.
- * @type:       the type of the struct this is embedded in.
- * @member:     the name of the list_struct within the struct.
- *
- * Note, that list is expected to be not empty.
- */
-#define list_last_entry(ptr, type, member) \
-	list_entry((ptr)->prev, type, member)
-
-/*
- * __reverse_ffs is copied from include/asm-generic/bitops/__ffs.h since
- * MSB and LSB are reversed in a byte by f2fs_set_bit.
- */
-static inline unsigned long __reverse_ffs(unsigned long word)
-{
-	int num = 0;
-
-#if BITS_PER_LONG == 64
-	if ((word & 0xffffffff00000000UL) == 0)
-		num += 32;
-	else
-		word >>= 32;
-#endif
-	if ((word & 0xffff0000) == 0)
-		num += 16;
-	else
-		word >>= 16;
-
-	if ((word & 0xff00) == 0)
-		num += 8;
-	else
-		word >>= 8;
-
-	if ((word & 0xf0) == 0)
-		num += 4;
-	else
-		word >>= 4;
-
-	if ((word & 0xc) == 0)
-		num += 2;
-	else
-		word >>= 2;
-
-	if ((word & 0x2) == 0)
-		num += 1;
-	return num;
-}
-
-/*
- * __find_rev_next(_zero)_bit is copied from lib/find_next_bit.c because
- * f2fs_set_bit makes MSB and LSB reversed in a byte.
- * @size must be integral times of unsigned long.
- * Example:
- *                             MSB <--> LSB
- *   f2fs_set_bit(0, bitmap) => 1000 0000
- *   f2fs_set_bit(7, bitmap) => 0000 0001
- */
-static unsigned long __find_rev_next_bit(const unsigned long *addr,
-			unsigned long size, unsigned long offset)
-{
-	const unsigned long *p = addr + BIT_WORD(offset);
-	unsigned long result = size;
-	unsigned long tmp;
-
-	if (offset >= size)
-		return size;
-
-	size -= (offset & ~(BITS_PER_LONG - 1));
-	offset %= BITS_PER_LONG;
-
-	while (1) {
-		if (*p == 0)
-			goto pass;
-
-		tmp = __reverse_ulong((unsigned char *)p);
-
-		tmp &= ~0UL >> offset;
-		if (size < BITS_PER_LONG)
-			tmp &= (~0UL << (BITS_PER_LONG - size));
-		if (tmp)
-			goto found;
-pass:
-		if (size <= BITS_PER_LONG)
-			break;
-		size -= BITS_PER_LONG;
-		offset = 0;
-		p++;
-	}
-	return result;
-found:
-	return result - size + __reverse_ffs(tmp);
-}
-
-static unsigned long __find_rev_next_zero_bit(const unsigned long *addr,
-			unsigned long size, unsigned long offset)
-{
-	const unsigned long *p = addr + BIT_WORD(offset);
-	unsigned long result = size;
-	unsigned long tmp;
-
-	if (offset >= size)
-		return size;
-
-	size -= (offset & ~(BITS_PER_LONG - 1));
-	offset %= BITS_PER_LONG;
-
-	while (1) {
-		if (*p == ~0UL)
-			goto pass;
-
-		tmp = __reverse_ulong((unsigned char *)p);
-
-		if (offset)
-			tmp |= ~0UL << (BITS_PER_LONG - offset);
-		if (size < BITS_PER_LONG)
-			tmp |= ~0UL >> size;
-		if (tmp != ~0UL)
-			goto found;
-pass:
-		if (size <= BITS_PER_LONG)
-			break;
-		size -= BITS_PER_LONG;
-		offset = 0;
-		p++;
-	}
-	return result;
-found:
-	return result - size + __reverse_ffz(tmp);
-}
-
-void register_inmem_page(struct inode *inode, struct page *page)
-{
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct inmem_pages *new;
-
-	f2fs_trace_pid(page);
-
-	set_page_private(page, (unsigned long)ATOMIC_WRITTEN_PAGE);
-	SetPagePrivate(page);
-
-	new = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);
-
-	/* add atomic page indices to the list */
-	new->page = page;
-	INIT_LIST_HEAD(&new->list);
-
-	/* increase reference count with clean state */
-	mutex_lock(&fi->inmem_lock);
-	get_page(page);
-	list_add_tail(&new->list, &fi->inmem_pages);
-	inc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);
-	mutex_unlock(&fi->inmem_lock);
-
-	trace_f2fs_register_inmem_page(page, INMEM);
-}
-
-static int __revoke_inmem_pages(struct inode *inode,
-				struct list_head *head, bool drop, bool recover)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct inmem_pages *cur, *tmp;
-	int err = 0;
-
-	list_for_each_entry_safe(cur, tmp, head, list) {
-		struct page *page = cur->page;
-
-		if (drop)
-			trace_f2fs_commit_inmem_page(page, INMEM_DROP);
-
-		lock_page(page);
-
-		if (recover) {
-			struct dnode_of_data dn;
-			struct node_info ni;
-
-			trace_f2fs_commit_inmem_page(page, INMEM_REVOKE);
-
-			set_new_dnode(&dn, inode, NULL, NULL, 0);
-			if (get_dnode_of_data(&dn, page->index, LOOKUP_NODE)) {
-				err = -EAGAIN;
-				goto next;
-			}
-			get_node_info(sbi, dn.nid, &ni);
-			f2fs_replace_block(sbi, &dn, dn.data_blkaddr,
-					cur->old_addr, ni.version, true, true);
-			f2fs_put_dnode(&dn);
-		}
-next:
-		/* we don't need to invalidate this in the sccessful status */
-		if (drop || recover)
-			ClearPageUptodate(page);
-		set_page_private(page, 0);
-		ClearPagePrivate(page);
-		f2fs_put_page(page, 1);
-
-		list_del(&cur->list);
-		kmem_cache_free(inmem_entry_slab, cur);
-		dec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);
-	}
-	return err;
-}
-
-void drop_inmem_pages(struct inode *inode)
-{
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-
-	clear_inode_flag(inode, FI_ATOMIC_FILE);
-
-	mutex_lock(&fi->inmem_lock);
-	__revoke_inmem_pages(inode, &fi->inmem_pages, true, false);
-	mutex_unlock(&fi->inmem_lock);
-}
-
-static int __commit_inmem_pages(struct inode *inode,
-					struct list_head *revoke_list)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct inmem_pages *cur, *tmp;
-	struct f2fs_io_info fio = {
-		.sbi = sbi,
-		.type = DATA,
-		.rw = WRITE_SYNC | REQ_PRIO,
-		.encrypted_page = NULL,
-	};
-	bool submit_bio = false;
-	int err = 0;
-
-	list_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {
-		struct page *page = cur->page;
-
-		lock_page(page);
-		if (page->mapping == inode->i_mapping) {
-			trace_f2fs_commit_inmem_page(page, INMEM);
-
-			set_page_dirty(page);
-			f2fs_wait_on_page_writeback(page, DATA, true);
-			if (clear_page_dirty_for_io(page)) {
-				inode_dec_dirty_pages(inode);
-				remove_dirty_inode(inode);
-			}
-
-			fio.page = page;
-			err = do_write_data_page(&fio);
-			if (err) {
-				unlock_page(page);
-				break;
-			}
-
-			/* record old blkaddr for revoking */
-			cur->old_addr = fio.old_blkaddr;
-
-			submit_bio = true;
-		}
-		unlock_page(page);
-		list_move_tail(&cur->list, revoke_list);
-	}
-
-	if (submit_bio)
-		f2fs_submit_merged_bio_cond(sbi, inode, NULL, 0, DATA, WRITE);
-
-	if (!err)
-		__revoke_inmem_pages(inode, revoke_list, false, false);
-
-	return err;
-}
-
-int commit_inmem_pages(struct inode *inode)
-{
-	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
-	struct f2fs_inode_info *fi = F2FS_I(inode);
-	struct list_head revoke_list;
-	int err;
-
-	INIT_LIST_HEAD(&revoke_list);
-	f2fs_balance_fs(sbi, true);
-	f2fs_lock_op(sbi);
-
-	mutex_lock(&fi->inmem_lock);
-	err = __commit_inmem_pages(inode, &revoke_list);
-	if (err) {
-		int ret;
-		/*
-		 * try to revoke all committed pages, but still we could fail
-		 * due to no memory or other reason, if that happened, EAGAIN
-		 * will be returned, which means in such case, transaction is
-		 * already not integrity, caller should use journal to do the
-		 * recovery or rewrite & commit last transaction. For other
-		 * error number, revoking was done by filesystem itself.
-		 */
-		ret = __revoke_inmem_pages(inode, &revoke_list, false, true);
-		if (ret)
-			err = ret;
-
-		/* drop all uncommitted pages */
-		__revoke_inmem_pages(inode, &fi->inmem_pages, true, false);
-	}
-	mutex_unlock(&fi->inmem_lock);
-
-	f2fs_unlock_op(sbi);
-	return err;
-}
-
-/*
- * This function balances dirty node and dentry pages.
- * In addition, it controls garbage collection.
- */
-void f2fs_balance_fs(struct f2fs_sb_info *sbi, bool need)
-{
-#ifdef CONFIG_F2FS_FAULT_INJECTION
-	if (time_to_inject(sbi, FAULT_CHECKPOINT))
-		f2fs_stop_checkpoint(sbi, false);
-#endif
-
-	if (!need)
-		return;
-
-	/* balance_fs_bg is able to be pending */
-	if (excess_cached_nats(sbi))
-		f2fs_balance_fs_bg(sbi);
-
-	/*
-	 * We should do GC or end up with checkpoint, if there are so many dirty
-	 * dir/node pages without enough free segments.
-	 */
-	if (has_not_enough_free_secs(sbi, 0, 0)) {
-		mutex_lock(&sbi->gc_mutex);
-		f2fs_gc(sbi, false, false);
-	}
-}
-
-void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)
-{
-	/* try to shrink extent cache when there is no enough memory */
-	if (!available_free_memory(sbi, EXTENT_CACHE))
-		f2fs_shrink_extent_tree(sbi, EXTENT_CACHE_SHRINK_NUMBER);
-
-	/* check the # of cached NAT entries */
-	if (!available_free_memory(sbi, NAT_ENTRIES))
-		try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK);
-
-	if (!available_free_memory(sbi, FREE_NIDS))
-		try_to_free_nids(sbi, MAX_FREE_NIDS);
-	else
-		build_free_nids(sbi, false);
-
-	if (!is_idle(sbi))
-		return;
-
-	/* checkpoint is the only way to shrink partial cached entries */
-	if (!available_free_memory(sbi, NAT_ENTRIES) ||
-			!available_free_memory(sbi, INO_ENTRIES) ||
-			excess_prefree_segs(sbi) ||
-			excess_dirty_nats(sbi) ||
-			f2fs_time_over(sbi, CP_TIME)) {
-		if (test_opt(sbi, DATA_FLUSH)) {
-			struct blk_plug plug;
-
-			blk_start_plug(&plug);
-			sync_dirty_inodes(sbi, FILE_INODE);
-			blk_finish_plug(&plug);
-		}
-		f2fs_sync_fs(sbi->sb, true);
-		stat_inc_bg_cp_count(sbi->stat_info);
-	}
-}
-
-struct __submit_bio_ret {
-	struct completion event;
-	int error;
-};
-
-static void __submit_bio_wait_endio(struct bio *bio, int error)
-{
-	struct __submit_bio_ret *ret = bio->bi_private;
-
-	ret->error = error;
-	complete(&ret->event);
-}
-
-static int __submit_bio_wait(int rw, struct bio *bio)
-{
-	struct __submit_bio_ret ret;
-
-	rw |= REQ_SYNC;
-	init_completion(&ret.event);
-	bio->bi_private = &ret;
-	bio->bi_end_io = __submit_bio_wait_endio;
-	submit_bio(rw, bio);
-	wait_for_completion(&ret.event);
-
-	return ret.error;
-}
-
-static int issue_flush_thread(void *data)
-{
-	struct f2fs_sb_info *sbi = data;
-	struct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;
-	wait_queue_head_t *q = &fcc->flush_wait_queue;
-repeat:
-	if (kthread_should_stop())
-		return 0;
-
-	if (!llist_empty(&fcc->issue_list)) {
-		struct bio *bio;
-		struct flush_cmd *cmd, *next;
-		int ret;
-
-		bio = f2fs_bio_alloc(0);
-
-		fcc->dispatch_list = llist_del_all(&fcc->issue_list);
-		fcc->dispatch_list = llist_reverse_order(fcc->dispatch_list);
-
-		bio->bi_bdev = sbi->sb->s_bdev;
-		ret = __submit_bio_wait(WRITE_FLUSH, bio);
-
-		llist_for_each_entry_safe(cmd, next,
-					  fcc->dispatch_list, llnode) {
-			cmd->ret = ret;
-			complete(&cmd->wait);
-		}
-		bio_put(bio);
-		fcc->dispatch_list = NULL;
-	}
-
-	wait_event_interruptible(*q,
-		kthread_should_stop() || !llist_empty(&fcc->issue_list));
-	goto repeat;
-}
-
-int f2fs_issue_flush(struct f2fs_sb_info *sbi)
-{
-	struct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;
-	struct flush_cmd cmd;
-
-	trace_f2fs_issue_flush(sbi->sb, test_opt(sbi, NOBARRIER),
-					test_opt(sbi, FLUSH_MERGE));
-
-	if (test_opt(sbi, NOBARRIER))
-		return 0;
-
-	if (!test_opt(sbi, FLUSH_MERGE) || !atomic_read(&fcc->submit_flush)) {
-		struct bio *bio = f2fs_bio_alloc(0);
-		int ret;
-
-		atomic_inc(&fcc->submit_flush);
-		bio->bi_bdev = sbi->sb->s_bdev;
-		ret = __submit_bio_wait(WRITE_FLUSH, bio);
-		atomic_dec(&fcc->submit_flush);
-		bio_put(bio);
-		return ret;
-	}
-
-	init_completion(&cmd.wait);
-
-	atomic_inc(&fcc->submit_flush);
-	llist_add(&cmd.llnode, &fcc->issue_list);
-
-	if (!fcc->dispatch_list)
-		wake_up(&fcc->flush_wait_queue);
-
-	if (fcc->f2fs_issue_flush) {
-		wait_for_completion(&cmd.wait);
-		atomic_dec(&fcc->submit_flush);
-	} else {
-		llist_del_all(&fcc->issue_list);
-		atomic_set(&fcc->submit_flush, 0);
-	}
-
-	return cmd.ret;
-}
-
-int create_flush_cmd_control(struct f2fs_sb_info *sbi)
-{
-	dev_t dev = sbi->sb->s_bdev->bd_dev;
-	struct flush_cmd_control *fcc;
-	int err = 0;
-
-	if (SM_I(sbi)->cmd_control_info) {
-		fcc = SM_I(sbi)->cmd_control_info;
-		goto init_thread;
-	}
-
-	fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);
-	if (!fcc)
-		return -ENOMEM;
-	atomic_set(&fcc->submit_flush, 0);
-	init_waitqueue_head(&fcc->flush_wait_queue);
-	init_llist_head(&fcc->issue_list);
-	SM_I(sbi)->cmd_control_info = fcc;
-	if (!test_opt(sbi, FLUSH_MERGE))
-		return err;
-
-init_thread:
-	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
-				"f2fs_flush-%u:%u", MAJOR(dev), MINOR(dev));
-	if (IS_ERR(fcc->f2fs_issue_flush)) {
-		err = PTR_ERR(fcc->f2fs_issue_flush);
-		kfree(fcc);
-		SM_I(sbi)->cmd_control_info = NULL;
-		return err;
-	}
-
-	return err;
-}
-
-void destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free)
-{
-	struct flush_cmd_control *fcc = SM_I(sbi)->cmd_control_info;
-
-	if (fcc && fcc->f2fs_issue_flush) {
-		struct task_struct *flush_thread = fcc->f2fs_issue_flush;
-
-		fcc->f2fs_issue_flush = NULL;
-		kthread_stop(flush_thread);
-	}
-	if (free) {
-		kfree(fcc);
-		SM_I(sbi)->cmd_control_info = NULL;
-	}
-}
-
-static void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	/* need not be added */
-	if (IS_CURSEG(sbi, segno))
-		return;
-
-	if (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))
-		dirty_i->nr_dirty[dirty_type]++;
-
-	if (dirty_type == DIRTY) {
-		struct seg_entry *sentry = get_seg_entry(sbi, segno);
-		enum dirty_type t = sentry->type;
-
-		if (unlikely(t >= DIRTY)) {
-			f2fs_bug_on(sbi, 1);
-			return;
-		}
-		if (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))
-			dirty_i->nr_dirty[t]++;
-	}
-}
-
-static void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	if (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))
-		dirty_i->nr_dirty[dirty_type]--;
-
-	if (dirty_type == DIRTY) {
-		struct seg_entry *sentry = get_seg_entry(sbi, segno);
-		enum dirty_type t = sentry->type;
-
-		if (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))
-			dirty_i->nr_dirty[t]--;
-
-		if (get_valid_blocks(sbi, segno, sbi->segs_per_sec) == 0)
-			clear_bit(GET_SECNO(sbi, segno),
-						dirty_i->victim_secmap);
-	}
-}
-
-/*
- * Should not occur error such as -ENOMEM.
- * Adding dirty entry into seglist is not critical operation.
- * If a given segment is one of current working segments, it won't be added.
- */
-static void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned short valid_blocks;
-
-	if (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))
-		return;
-
-	mutex_lock(&dirty_i->seglist_lock);
-
-	valid_blocks = get_valid_blocks(sbi, segno, 0);
-
-	if (valid_blocks == 0) {
-		__locate_dirty_segment(sbi, segno, PRE);
-		__remove_dirty_segment(sbi, segno, DIRTY);
-	} else if (valid_blocks < sbi->blocks_per_seg) {
-		__locate_dirty_segment(sbi, segno, DIRTY);
-	} else {
-		/* Recovery routine with SSR needs this */
-		__remove_dirty_segment(sbi, segno, DIRTY);
-	}
-
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-#ifdef CONFIG_BLK_DEV_ZONED
-static int f2fs_issue_discard_zone(struct f2fs_sb_info *sbi,
-					block_t blkstart, block_t blklen)
-{
-	sector_t sector = SECTOR_FROM_BLOCK(blkstart);
-	sector_t nr_sects = SECTOR_FROM_BLOCK(blklen);
-	struct block_device *bdev = sbi->sb->s_bdev;
-
-	if (sector & (bdev_zone_size(bdev) - 1) ||
-				nr_sects != bdev_zone_size(bdev)) {
-		f2fs_msg(sbi->sb, KERN_INFO,
-			 "Unaligned discard attempted (sector %llu + %llu)",
-			 (unsigned long long)sector,
-			 (unsigned long long)nr_sects);
-		return -EIO;
-	}
-
-	/*
-	 * We need to know the type of the zone: for conventional zones,
-	 * use regular discard if the drive supports it. For sequential
-	 * zones, reset the zone write pointer.
-	 */
-	switch (get_blkz_type(sbi, blkstart)) {
-
-	case BLK_ZONE_TYPE_CONVENTIONAL:
-		if (!blk_queue_discard(bdev_get_queue(bdev)))
-			return 0;
-		return blkdev_issue_discard(bdev, sector, nr_sects,
-						GFP_NOFS, 0);
-	case BLK_ZONE_TYPE_SEQWRITE_REQ:
-	case BLK_ZONE_TYPE_SEQWRITE_PREF:
-		trace_f2fs_issue_reset_zone(sbi->sb, blkstart);
-		return blkdev_reset_zones(bdev, sector,
-					  nr_sects, GFP_NOFS);
-	default:
-		/* Unknown zone type: broken device ? */
-		return -EIO;
-	}
-}
-#endif
-
-static int f2fs_issue_discard(struct f2fs_sb_info *sbi,
-				block_t blkstart, block_t blklen)
-{
-	sector_t start = SECTOR_FROM_BLOCK(blkstart);
-	sector_t len = SECTOR_FROM_BLOCK(blklen);
-	struct seg_entry *se;
-	unsigned int offset;
-	block_t i;
-
-	for (i = blkstart; i < blkstart + blklen; i++) {
-		se = get_seg_entry(sbi, GET_SEGNO(sbi, i));
-		offset = GET_BLKOFF_FROM_SEG0(sbi, i);
-
-		if (!f2fs_test_and_set_bit(offset, se->discard_map))
-			sbi->discard_blks--;
-	}
-	trace_f2fs_issue_discard(sbi->sb, blkstart, blklen);
-
-#ifdef CONFIG_BLK_DEV_ZONED
-	if (f2fs_sb_mounted_blkzoned(sbi->sb))
-		return f2fs_issue_discard_zone(sbi, blkstart, blklen);
-#endif
-	return blkdev_issue_discard(sbi->sb->s_bdev, start, len, GFP_NOFS, 0);
-}
-
-static void __add_discard_entry(struct f2fs_sb_info *sbi,
-		struct cp_control *cpc, struct seg_entry *se,
-		unsigned int start, unsigned int end)
-{
-	struct list_head *head = &SM_I(sbi)->discard_list;
-	struct discard_entry *new, *last;
-
-	if (!list_empty(head)) {
-		last = list_last_entry(head, struct discard_entry, list);
-		if (START_BLOCK(sbi, cpc->trim_start) + start ==
-						last->blkaddr + last->len) {
-			last->len += end - start;
-			goto done;
-		}
-	}
-
-	new = f2fs_kmem_cache_alloc(discard_entry_slab, GFP_NOFS);
-	INIT_LIST_HEAD(&new->list);
-	new->blkaddr = START_BLOCK(sbi, cpc->trim_start) + start;
-	new->len = end - start;
-	list_add_tail(&new->list, head);
-done:
-	SM_I(sbi)->nr_discards += end - start;
-}
-
-static void add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	int entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);
-	int max_blocks = sbi->blocks_per_seg;
-	struct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);
-	unsigned long *cur_map = (unsigned long *)se->cur_valid_map;
-	unsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;
-	unsigned long *discard_map = (unsigned long *)se->discard_map;
-	unsigned long *dmap = SIT_I(sbi)->tmp_map;
-	unsigned int start = 0, end = -1;
-	bool force = (cpc->reason == CP_DISCARD);
-	int i;
-
-	if (se->valid_blocks == max_blocks || !f2fs_discard_en(sbi))
-		return;
-
-	if (!force) {
-		if (!test_opt(sbi, DISCARD) || !se->valid_blocks ||
-		    SM_I(sbi)->nr_discards >= SM_I(sbi)->max_discards)
-			return;
-	}
-
-	/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */
-	for (i = 0; i < entries; i++)
-		dmap[i] = force ? ~ckpt_map[i] & ~discard_map[i] :
-				(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];
-
-	while (force || SM_I(sbi)->nr_discards <= SM_I(sbi)->max_discards) {
-		start = __find_rev_next_bit(dmap, max_blocks, end + 1);
-		if (start >= max_blocks)
-			break;
-
-		end = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);
-		if (force && start && end != max_blocks
-					&& (end - start) < cpc->trim_minlen)
-			continue;
-
-		__add_discard_entry(sbi, cpc, se, start, end);
-	}
-}
-
-void release_discard_addrs(struct f2fs_sb_info *sbi)
-{
-	struct list_head *head = &(SM_I(sbi)->discard_list);
-	struct discard_entry *entry, *this;
-
-	/* drop caches */
-	list_for_each_entry_safe(entry, this, head, list) {
-		list_del(&entry->list);
-		kmem_cache_free(discard_entry_slab, entry);
-	}
-}
-
-/*
- * Should call clear_prefree_segments after checkpoint is done.
- */
-static void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned int segno;
-
-	mutex_lock(&dirty_i->seglist_lock);
-	for_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))
-		__set_test_and_free(sbi, segno);
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	struct list_head *head = &(SM_I(sbi)->discard_list);
-	struct discard_entry *entry, *this;
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned long *prefree_map = dirty_i->dirty_segmap[PRE];
-	unsigned int start = 0, end = -1;
-	unsigned int secno, start_segno;
-	bool force = (cpc->reason == CP_DISCARD);
-
-	mutex_lock(&dirty_i->seglist_lock);
-
-	while (1) {
-		int i;
-		start = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);
-		if (start >= MAIN_SEGS(sbi))
-			break;
-		end = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),
-								start + 1);
-
-		for (i = start; i < end; i++)
-			clear_bit(i, prefree_map);
-
-		dirty_i->nr_dirty[PRE] -= end - start;
-
-		if (force || !test_opt(sbi, DISCARD))
-			continue;
-
-		if (!test_opt(sbi, LFS) || sbi->segs_per_sec == 1) {
-			f2fs_issue_discard(sbi, START_BLOCK(sbi, start),
-				(end - start) << sbi->log_blocks_per_seg);
-			continue;
-		}
-next:
-		secno = GET_SECNO(sbi, start);
-		start_segno = secno * sbi->segs_per_sec;
-		if (!IS_CURSEC(sbi, secno) &&
-			!get_valid_blocks(sbi, start, sbi->segs_per_sec))
-			f2fs_issue_discard(sbi, START_BLOCK(sbi, start_segno),
-				sbi->segs_per_sec << sbi->log_blocks_per_seg);
-
-		start = start_segno + sbi->segs_per_sec;
-		if (start < end)
-			goto next;
-	}
-	mutex_unlock(&dirty_i->seglist_lock);
-
-	/* send small discards */
-	list_for_each_entry_safe(entry, this, head, list) {
-		if (force && entry->len < cpc->trim_minlen)
-			goto skip;
-		f2fs_issue_discard(sbi, entry->blkaddr, entry->len);
-		cpc->trimmed += entry->len;
-skip:
-		list_del(&entry->list);
-		SM_I(sbi)->nr_discards -= entry->len;
-		kmem_cache_free(discard_entry_slab, entry);
-	}
-}
-
-static bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-
-	if (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {
-		sit_i->dirty_sentries++;
-		return false;
-	}
-
-	return true;
-}
-
-static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,
-					unsigned int segno, int modified)
-{
-	struct seg_entry *se = get_seg_entry(sbi, segno);
-	se->type = type;
-	if (modified)
-		__mark_sit_entry_dirty(sbi, segno);
-}
-
-static void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)
-{
-	struct seg_entry *se;
-	unsigned int segno, offset;
-	long int new_vblocks;
-
-	segno = GET_SEGNO(sbi, blkaddr);
-
-	se = get_seg_entry(sbi, segno);
-	new_vblocks = se->valid_blocks + del;
-	offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);
-
-	f2fs_bug_on(sbi, (new_vblocks >> (sizeof(unsigned short) << 3) ||
-				(new_vblocks > sbi->blocks_per_seg)));
-
-	se->valid_blocks = new_vblocks;
-	se->mtime = get_mtime(sbi);
-	SIT_I(sbi)->max_mtime = se->mtime;
-
-	/* Update valid block bitmap */
-	if (del > 0) {
-		if (f2fs_test_and_set_bit(offset, se->cur_valid_map))
-			f2fs_bug_on(sbi, 1);
-		if (f2fs_discard_en(sbi) &&
-			!f2fs_test_and_set_bit(offset, se->discard_map))
-			sbi->discard_blks--;
-	} else {
-		if (!f2fs_test_and_clear_bit(offset, se->cur_valid_map))
-			f2fs_bug_on(sbi, 1);
-		if (f2fs_discard_en(sbi) &&
-			f2fs_test_and_clear_bit(offset, se->discard_map))
-			sbi->discard_blks++;
-	}
-	if (!f2fs_test_bit(offset, se->ckpt_valid_map))
-		se->ckpt_valid_blocks += del;
-
-	__mark_sit_entry_dirty(sbi, segno);
-
-	/* update total number of valid blocks to be written in ckpt area */
-	SIT_I(sbi)->written_valid_blocks += del;
-
-	if (sbi->segs_per_sec > 1)
-		get_sec_entry(sbi, segno)->valid_blocks += del;
-}
-
-void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new)
-{
-	update_sit_entry(sbi, new, 1);
-	if (GET_SEGNO(sbi, old) != NULL_SEGNO)
-		update_sit_entry(sbi, old, -1);
-
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, old));
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, new));
-}
-
-void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)
-{
-	unsigned int segno = GET_SEGNO(sbi, addr);
-	struct sit_info *sit_i = SIT_I(sbi);
-
-	f2fs_bug_on(sbi, addr == NULL_ADDR);
-	if (addr == NEW_ADDR)
-		return;
-
-	/* add it into sit main buffer */
-	mutex_lock(&sit_i->sentry_lock);
-
-	update_sit_entry(sbi, addr, -1);
-
-	/* add it into dirty seglist */
-	locate_dirty_segment(sbi, segno);
-
-	mutex_unlock(&sit_i->sentry_lock);
-}
-
-bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int segno, offset;
-	struct seg_entry *se;
-	bool is_cp = false;
-
-	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
-		return true;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	segno = GET_SEGNO(sbi, blkaddr);
-	se = get_seg_entry(sbi, segno);
-	offset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);
-
-	if (f2fs_test_bit(offset, se->ckpt_valid_map))
-		is_cp = true;
-
-	mutex_unlock(&sit_i->sentry_lock);
-
-	return is_cp;
-}
-
-/*
- * This function should be resided under the curseg_mutex lock
- */
-static void __add_sum_entry(struct f2fs_sb_info *sbi, int type,
-					struct f2fs_summary *sum)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	void *addr = curseg->sum_blk;
-	addr += curseg->next_blkoff * sizeof(struct f2fs_summary);
-	memcpy(addr, sum, sizeof(struct f2fs_summary));
-}
-
-/*
- * Calculate the number of current summary pages for writing
- */
-int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)
-{
-	int valid_sum_count = 0;
-	int i, sum_in_page;
-
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		if (sbi->ckpt->alloc_type[i] == SSR)
-			valid_sum_count += sbi->blocks_per_seg;
-		else {
-			if (for_ra)
-				valid_sum_count += le16_to_cpu(
-					F2FS_CKPT(sbi)->cur_data_blkoff[i]);
-			else
-				valid_sum_count += curseg_blkoff(sbi, i);
-		}
-	}
-
-	sum_in_page = (PAGE_SIZE - 2 * SUM_JOURNAL_SIZE -
-			SUM_FOOTER_SIZE) / SUMMARY_SIZE;
-	if (valid_sum_count <= sum_in_page)
-		return 1;
-	else if ((valid_sum_count - sum_in_page) <=
-		(PAGE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)
-		return 2;
-	return 3;
-}
-
-/*
- * Caller should put this summary page
- */
-struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)
-{
-	return get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));
-}
-
-void update_meta_page(struct f2fs_sb_info *sbi, void *src, block_t blk_addr)
-{
-	struct page *page = grab_meta_page(sbi, blk_addr);
-	void *dst = page_address(page);
-
-	if (src)
-		memcpy(dst, src, PAGE_SIZE);
-	else
-		memset(dst, 0, PAGE_SIZE);
-	set_page_dirty(page);
-	f2fs_put_page(page, 1);
-}
-
-static void write_sum_page(struct f2fs_sb_info *sbi,
-			struct f2fs_summary_block *sum_blk, block_t blk_addr)
-{
-	update_meta_page(sbi, (void *)sum_blk, blk_addr);
-}
-
-static void write_current_sum_page(struct f2fs_sb_info *sbi,
-						int type, block_t blk_addr)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	struct page *page = grab_meta_page(sbi, blk_addr);
-	struct f2fs_summary_block *src = curseg->sum_blk;
-	struct f2fs_summary_block *dst;
-
-	dst = (struct f2fs_summary_block *)page_address(page);
-
-	mutex_lock(&curseg->curseg_mutex);
-
-	down_read(&curseg->journal_rwsem);
-	memcpy(&dst->journal, curseg->journal, SUM_JOURNAL_SIZE);
-	up_read(&curseg->journal_rwsem);
-
-	memcpy(dst->entries, src->entries, SUM_ENTRY_SIZE);
-	memcpy(&dst->footer, &src->footer, SUM_FOOTER_SIZE);
-
-	mutex_unlock(&curseg->curseg_mutex);
-
-	set_page_dirty(page);
-	f2fs_put_page(page, 1);
-}
-
-static int is_next_segment_free(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int segno = curseg->segno + 1;
-	struct free_segmap_info *free_i = FREE_I(sbi);
-
-	if (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)
-		return !test_bit(segno, free_i->free_segmap);
-	return 0;
-}
-
-/*
- * Find a new segment from the free segments bitmap to right order
- * This function should be returned with success, otherwise BUG
- */
-static void get_new_segment(struct f2fs_sb_info *sbi,
-			unsigned int *newseg, bool new_sec, int dir)
-{
-	struct free_segmap_info *free_i = FREE_I(sbi);
-	unsigned int segno, secno, zoneno;
-	unsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;
-	unsigned int hint = *newseg / sbi->segs_per_sec;
-	unsigned int old_zoneno = GET_ZONENO_FROM_SEGNO(sbi, *newseg);
-	unsigned int left_start = hint;
-	bool init = true;
-	int go_left = 0;
-	int i;
-
-	spin_lock(&free_i->segmap_lock);
-
-	if (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {
-		segno = find_next_zero_bit(free_i->free_segmap,
-				(hint + 1) * sbi->segs_per_sec, *newseg + 1);
-		if (segno < (hint + 1) * sbi->segs_per_sec)
-			goto got_it;
-	}
-find_other_zone:
-	secno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);
-	if (secno >= MAIN_SECS(sbi)) {
-		if (dir == ALLOC_RIGHT) {
-			secno = find_next_zero_bit(free_i->free_secmap,
-							MAIN_SECS(sbi), 0);
-			f2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));
-		} else {
-			go_left = 1;
-			left_start = hint - 1;
-		}
-	}
-	if (go_left == 0)
-		goto skip_left;
-
-	while (test_bit(left_start, free_i->free_secmap)) {
-		if (left_start > 0) {
-			left_start--;
-			continue;
-		}
-		left_start = find_next_zero_bit(free_i->free_secmap,
-							MAIN_SECS(sbi), 0);
-		f2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));
-		break;
-	}
-	secno = left_start;
-skip_left:
-	hint = secno;
-	segno = secno * sbi->segs_per_sec;
-	zoneno = secno / sbi->secs_per_zone;
-
-	/* give up on finding another zone */
-	if (!init)
-		goto got_it;
-	if (sbi->secs_per_zone == 1)
-		goto got_it;
-	if (zoneno == old_zoneno)
-		goto got_it;
-	if (dir == ALLOC_LEFT) {
-		if (!go_left && zoneno + 1 >= total_zones)
-			goto got_it;
-		if (go_left && zoneno == 0)
-			goto got_it;
-	}
-	for (i = 0; i < NR_CURSEG_TYPE; i++)
-		if (CURSEG_I(sbi, i)->zone == zoneno)
-			break;
-
-	if (i < NR_CURSEG_TYPE) {
-		/* zone is in user, try another */
-		if (go_left)
-			hint = zoneno * sbi->secs_per_zone - 1;
-		else if (zoneno + 1 >= total_zones)
-			hint = 0;
-		else
-			hint = (zoneno + 1) * sbi->secs_per_zone;
-		init = false;
-		goto find_other_zone;
-	}
-got_it:
-	/* set it as dirty segment in free segmap */
-	f2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));
-	__set_inuse(sbi, segno);
-	*newseg = segno;
-	spin_unlock(&free_i->segmap_lock);
-}
-
-static void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	struct summary_footer *sum_footer;
-
-	curseg->segno = curseg->next_segno;
-	curseg->zone = GET_ZONENO_FROM_SEGNO(sbi, curseg->segno);
-	curseg->next_blkoff = 0;
-	curseg->next_segno = NULL_SEGNO;
-
-	sum_footer = &(curseg->sum_blk->footer);
-	memset(sum_footer, 0, sizeof(struct summary_footer));
-	if (IS_DATASEG(type))
-		SET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);
-	if (IS_NODESEG(type))
-		SET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);
-	__set_sit_entry_type(sbi, type, curseg->segno, modified);
-}
-
-/*
- * Allocate a current working segment.
- * This function always allocates a free segment in LFS manner.
- */
-static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int segno = curseg->segno;
-	int dir = ALLOC_LEFT;
-
-	write_sum_page(sbi, curseg->sum_blk,
-				GET_SUM_BLOCK(sbi, segno));
-	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
-		dir = ALLOC_RIGHT;
-
-	if (test_opt(sbi, NOHEAP))
-		dir = ALLOC_RIGHT;
-
-	get_new_segment(sbi, &segno, new_sec, dir);
-	curseg->next_segno = segno;
-	reset_curseg(sbi, type, 1);
-	curseg->alloc_type = LFS;
-}
-
-static void __next_free_blkoff(struct f2fs_sb_info *sbi,
-			struct curseg_info *seg, block_t start)
-{
-	struct seg_entry *se = get_seg_entry(sbi, seg->segno);
-	int entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);
-	unsigned long *target_map = SIT_I(sbi)->tmp_map;
-	unsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;
-	unsigned long *cur_map = (unsigned long *)se->cur_valid_map;
-	int i, pos;
-
-	for (i = 0; i < entries; i++)
-		target_map[i] = ckpt_map[i] | cur_map[i];
-
-	pos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);
-
-	seg->next_blkoff = pos;
-}
-
-/*
- * If a segment is written by LFS manner, next block offset is just obtained
- * by increasing the current block offset. However, if a segment is written by
- * SSR manner, next block offset obtained by calling __next_free_blkoff
- */
-static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,
-				struct curseg_info *seg)
-{
-	if (seg->alloc_type == SSR)
-		__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);
-	else
-		seg->next_blkoff++;
-}
-
-/*
- * This function always allocates a used segment(from dirty seglist) by SSR
- * manner, so it should recover the existing segment information of valid blocks
- */
-static void change_curseg(struct f2fs_sb_info *sbi, int type, bool reuse)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	unsigned int new_segno = curseg->next_segno;
-	struct f2fs_summary_block *sum_node;
-	struct page *sum_page;
-
-	write_sum_page(sbi, curseg->sum_blk,
-				GET_SUM_BLOCK(sbi, curseg->segno));
-	__set_test_and_inuse(sbi, new_segno);
-
-	mutex_lock(&dirty_i->seglist_lock);
-	__remove_dirty_segment(sbi, new_segno, PRE);
-	__remove_dirty_segment(sbi, new_segno, DIRTY);
-	mutex_unlock(&dirty_i->seglist_lock);
-
-	reset_curseg(sbi, type, 1);
-	curseg->alloc_type = SSR;
-	__next_free_blkoff(sbi, curseg, 0);
-
-	if (reuse) {
-		sum_page = get_sum_page(sbi, new_segno);
-		sum_node = (struct f2fs_summary_block *)page_address(sum_page);
-		memcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);
-		f2fs_put_page(sum_page, 1);
-	}
-}
-
-static int get_ssr_segment(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	const struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;
-
-	if (IS_NODESEG(type) || !has_not_enough_free_secs(sbi, 0, 0))
-		return v_ops->get_victim(sbi,
-				&(curseg)->next_segno, BG_GC, type, SSR);
-
-	/* For data segments, let's do SSR more intensively */
-	for (; type >= CURSEG_HOT_DATA; type--)
-		if (v_ops->get_victim(sbi, &(curseg)->next_segno,
-						BG_GC, type, SSR))
-			return 1;
-	return 0;
-}
-
-/*
- * flush out current segment and replace it with new segment
- * This function should be returned with success, otherwise BUG
- */
-static void allocate_segment_by_default(struct f2fs_sb_info *sbi,
-						int type, bool force)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-
-	if (force)
-		new_curseg(sbi, type, true);
-	else if (type == CURSEG_WARM_NODE)
-		new_curseg(sbi, type, false);
-	else if (curseg->alloc_type == LFS && is_next_segment_free(sbi, type))
-		new_curseg(sbi, type, false);
-	else if (need_SSR(sbi) && get_ssr_segment(sbi, type))
-		change_curseg(sbi, type, true);
-	else
-		new_curseg(sbi, type, false);
-
-	stat_inc_seg_type(sbi, curseg);
-}
-
-void allocate_new_segments(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *curseg;
-	unsigned int old_segno;
-	int i;
-
-	if (test_opt(sbi, LFS))
-		return;
-
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		curseg = CURSEG_I(sbi, i);
-		old_segno = curseg->segno;
-		SIT_I(sbi)->s_ops->allocate_segment(sbi, i, true);
-		locate_dirty_segment(sbi, old_segno);
-	}
-}
-
-static const struct segment_allocation default_salloc_ops = {
-	.allocate_segment = allocate_segment_by_default,
-};
-
-int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)
-{
-	__u64 start = F2FS_BYTES_TO_BLK(range->start);
-	__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;
-	unsigned int start_segno, end_segno;
-	struct cp_control cpc;
-	int err = 0;
-
-	if (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)
-		return -EINVAL;
-
-	cpc.trimmed = 0;
-	if (end <= MAIN_BLKADDR(sbi))
-		goto out;
-
-	if (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {
-		f2fs_msg(sbi->sb, KERN_WARNING,
-			"Found FS corruption, run fsck to fix.");
-		goto out;
-	}
-
-	/* start/end segment number in main_area */
-	start_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);
-	end_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :
-						GET_SEGNO(sbi, end);
-	cpc.reason = CP_DISCARD;
-	cpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));
-
-	/* do checkpoint to issue discard commands safely */
-	for (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {
-		cpc.trim_start = start_segno;
-
-		if (sbi->discard_blks == 0)
-			break;
-		else if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))
-			cpc.trim_end = end_segno;
-		else
-			cpc.trim_end = min_t(unsigned int,
-				rounddown(start_segno +
-				BATCHED_TRIM_SEGMENTS(sbi),
-				sbi->segs_per_sec) - 1, end_segno);
-
-		mutex_lock(&sbi->gc_mutex);
-		err = write_checkpoint(sbi, &cpc);
-		mutex_unlock(&sbi->gc_mutex);
-		if (err)
-			break;
-
-		schedule();
-	}
-out:
-	range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);
-	return err;
-}
-
-static bool __has_curseg_space(struct f2fs_sb_info *sbi, int type)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-	if (curseg->next_blkoff < sbi->blocks_per_seg)
-		return true;
-	return false;
-}
-
-static int __get_segment_type_2(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA)
-		return CURSEG_HOT_DATA;
-	else
-		return CURSEG_HOT_NODE;
-}
-
-static int __get_segment_type_4(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA) {
-		struct inode *inode = page->mapping->host;
-
-		if (S_ISDIR(inode->i_mode))
-			return CURSEG_HOT_DATA;
-		else
-			return CURSEG_COLD_DATA;
-	} else {
-		if (IS_DNODE(page) && is_cold_node(page))
-			return CURSEG_WARM_NODE;
-		else
-			return CURSEG_COLD_NODE;
-	}
-}
-
-static int __get_segment_type_6(struct page *page, enum page_type p_type)
-{
-	if (p_type == DATA) {
-		struct inode *inode = page->mapping->host;
-
-		if (S_ISDIR(inode->i_mode))
-			return CURSEG_HOT_DATA;
-		else if (is_cold_data(page) || file_is_cold(inode))
-			return CURSEG_COLD_DATA;
-		else
-			return CURSEG_WARM_DATA;
-	} else {
-		if (IS_DNODE(page))
-			return is_cold_node(page) ? CURSEG_WARM_NODE :
-						CURSEG_HOT_NODE;
-		else
-			return CURSEG_COLD_NODE;
-	}
-}
-
-static int __get_segment_type(struct page *page, enum page_type p_type)
-{
-	switch (F2FS_P_SB(page)->active_logs) {
-	case 2:
-		return __get_segment_type_2(page, p_type);
-	case 4:
-		return __get_segment_type_4(page, p_type);
-	}
-	/* NR_CURSEG_TYPE(6) logs by default */
-	f2fs_bug_on(F2FS_P_SB(page),
-		F2FS_P_SB(page)->active_logs != NR_CURSEG_TYPE);
-	return __get_segment_type_6(page, p_type);
-}
-
-void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,
-		block_t old_blkaddr, block_t *new_blkaddr,
-		struct f2fs_summary *sum, int type)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, type);
-
-	mutex_lock(&curseg->curseg_mutex);
-	mutex_lock(&sit_i->sentry_lock);
-
-	*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);
-
-	/*
-	 * __add_sum_entry should be resided under the curseg_mutex
-	 * because, this function updates a summary entry in the
-	 * current summary block.
-	 */
-	__add_sum_entry(sbi, type, sum);
-
-	__refresh_next_blkoff(sbi, curseg);
-
-	stat_inc_block_count(sbi, curseg);
-
-	if (!__has_curseg_space(sbi, type))
-		sit_i->s_ops->allocate_segment(sbi, type, false);
-	/*
-	 * SIT information should be updated before segment allocation,
-	 * since SSR needs latest valid block information.
-	 */
-	refresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);
-
-	mutex_unlock(&sit_i->sentry_lock);
-
-	if (page && IS_NODESEG(type))
-		fill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));
-
-	mutex_unlock(&curseg->curseg_mutex);
-}
-
-static void do_write_page(struct f2fs_summary *sum, struct f2fs_io_info *fio)
-{
-	int type = __get_segment_type(fio->page, fio->type);
-
-	if (fio->type == NODE || fio->type == DATA)
-		mutex_lock(&fio->sbi->wio_mutex[fio->type]);
-
-	allocate_data_block(fio->sbi, fio->page, fio->old_blkaddr,
-					&fio->new_blkaddr, sum, type);
-
-	/* writeout dirty page into bdev */
-	f2fs_submit_page_mbio(fio);
-
-	if (fio->type == NODE || fio->type == DATA)
-		mutex_unlock(&fio->sbi->wio_mutex[fio->type]);
-}
-
-void write_meta_page(struct f2fs_sb_info *sbi, struct page *page)
-{
-	struct f2fs_io_info fio = {
-		.sbi = sbi,
-		.type = META,
-		.rw = WRITE_SYNC | REQ_META | REQ_PRIO,
-		.old_blkaddr = page->index,
-		.new_blkaddr = page->index,
-		.page = page,
-		.encrypted_page = NULL,
-	};
-
-	if (unlikely(page->index >= MAIN_BLKADDR(sbi)))
-		fio.rw &= ~REQ_META;
-
-	set_page_writeback(page);
-	f2fs_submit_page_mbio(&fio);
-}
-
-void write_node_page(unsigned int nid, struct f2fs_io_info *fio)
-{
-	struct f2fs_summary sum;
-
-	set_summary(&sum, nid, 0, 0);
-	do_write_page(&sum, fio);
-}
-
-void write_data_page(struct dnode_of_data *dn, struct f2fs_io_info *fio)
-{
-	struct f2fs_sb_info *sbi = fio->sbi;
-	struct f2fs_summary sum;
-	struct node_info ni;
-
-	f2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);
-	get_node_info(sbi, dn->nid, &ni);
-	set_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);
-	do_write_page(&sum, fio);
-	f2fs_update_data_blkaddr(dn, fio->new_blkaddr);
-}
-
-void rewrite_data_page(struct f2fs_io_info *fio)
-{
-	fio->new_blkaddr = fio->old_blkaddr;
-	stat_inc_inplace_blocks(fio->sbi);
-	f2fs_submit_page_mbio(fio);
-}
-
-void __f2fs_replace_block(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,
-				block_t old_blkaddr, block_t new_blkaddr,
-				bool recover_curseg, bool recover_newaddr)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg;
-	unsigned int segno, old_cursegno;
-	struct seg_entry *se;
-	int type;
-	unsigned short old_blkoff;
-
-	segno = GET_SEGNO(sbi, new_blkaddr);
-	se = get_seg_entry(sbi, segno);
-	type = se->type;
-
-	if (!recover_curseg) {
-		/* for recovery flow */
-		if (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {
-			if (old_blkaddr == NULL_ADDR)
-				type = CURSEG_COLD_DATA;
-			else
-				type = CURSEG_WARM_DATA;
-		}
-	} else {
-		if (!IS_CURSEG(sbi, segno))
-			type = CURSEG_WARM_DATA;
-	}
-
-	curseg = CURSEG_I(sbi, type);
-
-	mutex_lock(&curseg->curseg_mutex);
-	mutex_lock(&sit_i->sentry_lock);
-
-	old_cursegno = curseg->segno;
-	old_blkoff = curseg->next_blkoff;
-
-	/* change the current segment */
-	if (segno != curseg->segno) {
-		curseg->next_segno = segno;
-		change_curseg(sbi, type, true);
-	}
-
-	curseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);
-	__add_sum_entry(sbi, type, sum);
-
-	if (!recover_curseg || recover_newaddr)
-		update_sit_entry(sbi, new_blkaddr, 1);
-	if (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)
-		update_sit_entry(sbi, old_blkaddr, -1);
-
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));
-	locate_dirty_segment(sbi, GET_SEGNO(sbi, new_blkaddr));
-
-	locate_dirty_segment(sbi, old_cursegno);
-
-	if (recover_curseg) {
-		if (old_cursegno != curseg->segno) {
-			curseg->next_segno = old_cursegno;
-			change_curseg(sbi, type, true);
-		}
-		curseg->next_blkoff = old_blkoff;
-	}
-
-	mutex_unlock(&sit_i->sentry_lock);
-	mutex_unlock(&curseg->curseg_mutex);
-}
-
-void f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,
-				block_t old_addr, block_t new_addr,
-				unsigned char version, bool recover_curseg,
-				bool recover_newaddr)
-{
-	struct f2fs_summary sum;
-
-	set_summary(&sum, dn->nid, dn->ofs_in_node, version);
-
-	__f2fs_replace_block(sbi, &sum, old_addr, new_addr,
-					recover_curseg, recover_newaddr);
-
-	f2fs_update_data_blkaddr(dn, new_addr);
-}
-
-void f2fs_wait_on_page_writeback(struct page *page,
-				enum page_type type, bool ordered)
-{
-	if (PageWriteback(page)) {
-		struct f2fs_sb_info *sbi = F2FS_P_SB(page);
-
-		f2fs_submit_merged_bio_cond(sbi, NULL, page, 0, type, WRITE);
-		if (ordered)
-			wait_on_page_writeback(page);
-		else
-			/* wait_for_stable_page(page) doesn't support */
-			wait_on_page_writeback(page);
-	}
-}
-
-void f2fs_wait_on_encrypted_page_writeback(struct f2fs_sb_info *sbi,
-							block_t blkaddr)
-{
-	struct page *cpage;
-
-	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
-		return;
-
-	cpage = find_lock_page(META_MAPPING(sbi), blkaddr);
-	if (cpage) {
-		f2fs_wait_on_page_writeback(cpage, DATA, true);
-		f2fs_put_page(cpage, 1);
-	}
-}
-
-static int read_compacted_summaries(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct curseg_info *seg_i;
-	unsigned char *kaddr;
-	struct page *page;
-	block_t start;
-	int i, j, offset;
-
-	start = start_sum_block(sbi);
-
-	page = get_meta_page(sbi, start++);
-	kaddr = (unsigned char *)page_address(page);
-
-	/* Step 1: restore nat cache */
-	seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);
-	memcpy(seg_i->journal, kaddr, SUM_JOURNAL_SIZE);
-
-	/* Step 2: restore sit cache */
-	seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	memcpy(seg_i->journal, kaddr + SUM_JOURNAL_SIZE, SUM_JOURNAL_SIZE);
-	offset = 2 * SUM_JOURNAL_SIZE;
-
-	/* Step 3: restore summary entries */
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		unsigned short blk_off;
-		unsigned int segno;
-
-		seg_i = CURSEG_I(sbi, i);
-		segno = le32_to_cpu(ckpt->cur_data_segno[i]);
-		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);
-		seg_i->next_segno = segno;
-		reset_curseg(sbi, i, 0);
-		seg_i->alloc_type = ckpt->alloc_type[i];
-		seg_i->next_blkoff = blk_off;
-
-		if (seg_i->alloc_type == SSR)
-			blk_off = sbi->blocks_per_seg;
-
-		for (j = 0; j < blk_off; j++) {
-			struct f2fs_summary *s;
-			s = (struct f2fs_summary *)(kaddr + offset);
-			seg_i->sum_blk->entries[j] = *s;
-			offset += SUMMARY_SIZE;
-			if (offset + SUMMARY_SIZE <= PAGE_SIZE -
-						SUM_FOOTER_SIZE)
-				continue;
-
-			f2fs_put_page(page, 1);
-			page = NULL;
-
-			page = get_meta_page(sbi, start++);
-			kaddr = (unsigned char *)page_address(page);
-			offset = 0;
-		}
-	}
-	f2fs_put_page(page, 1);
-	return 0;
-}
-
-static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)
-{
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct f2fs_summary_block *sum;
-	struct curseg_info *curseg;
-	struct page *new;
-	unsigned short blk_off;
-	unsigned int segno = 0;
-	block_t blk_addr = 0;
-
-	/* get segment number and block addr */
-	if (IS_DATASEG(type)) {
-		segno = le32_to_cpu(ckpt->cur_data_segno[type]);
-		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -
-							CURSEG_HOT_DATA]);
-		if (__exist_node_summaries(sbi))
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);
-		else
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);
-	} else {
-		segno = le32_to_cpu(ckpt->cur_node_segno[type -
-							CURSEG_HOT_NODE]);
-		blk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -
-							CURSEG_HOT_NODE]);
-		if (__exist_node_summaries(sbi))
-			blk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,
-							type - CURSEG_HOT_NODE);
-		else
-			blk_addr = GET_SUM_BLOCK(sbi, segno);
-	}
-
-	new = get_meta_page(sbi, blk_addr);
-	sum = (struct f2fs_summary_block *)page_address(new);
-
-	if (IS_NODESEG(type)) {
-		if (__exist_node_summaries(sbi)) {
-			struct f2fs_summary *ns = &sum->entries[0];
-			int i;
-			for (i = 0; i < sbi->blocks_per_seg; i++, ns++) {
-				ns->version = 0;
-				ns->ofs_in_node = 0;
-			}
-		} else {
-			int err;
-
-			err = restore_node_summary(sbi, segno, sum);
-			if (err) {
-				f2fs_put_page(new, 1);
-				return err;
-			}
-		}
-	}
-
-	/* set uncompleted segment to curseg */
-	curseg = CURSEG_I(sbi, type);
-	mutex_lock(&curseg->curseg_mutex);
-
-	/* update journal info */
-	down_write(&curseg->journal_rwsem);
-	memcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);
-	up_write(&curseg->journal_rwsem);
-
-	memcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);
-	memcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);
-	curseg->next_segno = segno;
-	reset_curseg(sbi, type, 0);
-	curseg->alloc_type = ckpt->alloc_type[type];
-	curseg->next_blkoff = blk_off;
-	mutex_unlock(&curseg->curseg_mutex);
-	f2fs_put_page(new, 1);
-	return 0;
-}
-
-static int restore_curseg_summaries(struct f2fs_sb_info *sbi)
-{
-	int type = CURSEG_HOT_DATA;
-	int err;
-
-	if (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG)) {
-		int npages = npages_for_summary_flush(sbi, true);
-
-		if (npages >= 2)
-			ra_meta_pages(sbi, start_sum_block(sbi), npages,
-							META_CP, true);
-
-		/* restore for compacted data summary */
-		if (read_compacted_summaries(sbi))
-			return -EINVAL;
-		type = CURSEG_HOT_NODE;
-	}
-
-	if (__exist_node_summaries(sbi))
-		ra_meta_pages(sbi, sum_blk_addr(sbi, NR_CURSEG_TYPE, type),
-					NR_CURSEG_TYPE - type, META_CP, true);
-
-	for (; type <= CURSEG_COLD_NODE; type++) {
-		err = read_normal_summaries(sbi, type);
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
-static void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)
-{
-	struct page *page;
-	unsigned char *kaddr;
-	struct f2fs_summary *summary;
-	struct curseg_info *seg_i;
-	int written_size = 0;
-	int i, j;
-
-	page = grab_meta_page(sbi, blkaddr++);
-	kaddr = (unsigned char *)page_address(page);
-
-	/* Step 1: write nat cache */
-	seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);
-	memcpy(kaddr, seg_i->journal, SUM_JOURNAL_SIZE);
-	written_size += SUM_JOURNAL_SIZE;
-
-	/* Step 2: write sit cache */
-	seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	memcpy(kaddr + written_size, seg_i->journal, SUM_JOURNAL_SIZE);
-	written_size += SUM_JOURNAL_SIZE;
-
-	/* Step 3: write summary entries */
-	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
-		unsigned short blkoff;
-		seg_i = CURSEG_I(sbi, i);
-		if (sbi->ckpt->alloc_type[i] == SSR)
-			blkoff = sbi->blocks_per_seg;
-		else
-			blkoff = curseg_blkoff(sbi, i);
-
-		for (j = 0; j < blkoff; j++) {
-			if (!page) {
-				page = grab_meta_page(sbi, blkaddr++);
-				kaddr = (unsigned char *)page_address(page);
-				written_size = 0;
-			}
-			summary = (struct f2fs_summary *)(kaddr + written_size);
-			*summary = seg_i->sum_blk->entries[j];
-			written_size += SUMMARY_SIZE;
-
-			if (written_size + SUMMARY_SIZE <= PAGE_SIZE -
-							SUM_FOOTER_SIZE)
-				continue;
-
-			set_page_dirty(page);
-			f2fs_put_page(page, 1);
-			page = NULL;
-		}
-	}
-	if (page) {
-		set_page_dirty(page);
-		f2fs_put_page(page, 1);
-	}
-}
-
-static void write_normal_summaries(struct f2fs_sb_info *sbi,
-					block_t blkaddr, int type)
-{
-	int i, end;
-	if (IS_DATASEG(type))
-		end = type + NR_CURSEG_DATA_TYPE;
-	else
-		end = type + NR_CURSEG_NODE_TYPE;
-
-	for (i = type; i < end; i++)
-		write_current_sum_page(sbi, i, blkaddr + (i - type));
-}
-
-void write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)
-{
-	if (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG))
-		write_compacted_summaries(sbi, start_blk);
-	else
-		write_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);
-}
-
-void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)
-{
-	write_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);
-}
-
-int lookup_journal_in_cursum(struct f2fs_journal *journal, int type,
-					unsigned int val, int alloc)
-{
-	int i;
-
-	if (type == NAT_JOURNAL) {
-		for (i = 0; i < nats_in_cursum(journal); i++) {
-			if (le32_to_cpu(nid_in_journal(journal, i)) == val)
-				return i;
-		}
-		if (alloc && __has_cursum_space(journal, 1, NAT_JOURNAL))
-			return update_nats_in_cursum(journal, 1);
-	} else if (type == SIT_JOURNAL) {
-		for (i = 0; i < sits_in_cursum(journal); i++)
-			if (le32_to_cpu(segno_in_journal(journal, i)) == val)
-				return i;
-		if (alloc && __has_cursum_space(journal, 1, SIT_JOURNAL))
-			return update_sits_in_cursum(journal, 1);
-	}
-	return -1;
-}
-
-static struct page *get_current_sit_page(struct f2fs_sb_info *sbi,
-					unsigned int segno)
-{
-	return get_meta_page(sbi, current_sit_addr(sbi, segno));
-}
-
-static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,
-					unsigned int start)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct page *src_page, *dst_page;
-	pgoff_t src_off, dst_off;
-	void *src_addr, *dst_addr;
-
-	src_off = current_sit_addr(sbi, start);
-	dst_off = next_sit_addr(sbi, src_off);
-
-	/* get current sit block page without lock */
-	src_page = get_meta_page(sbi, src_off);
-	dst_page = grab_meta_page(sbi, dst_off);
-	f2fs_bug_on(sbi, PageDirty(src_page));
-
-	src_addr = page_address(src_page);
-	dst_addr = page_address(dst_page);
-	memcpy(dst_addr, src_addr, PAGE_SIZE);
-
-	set_page_dirty(dst_page);
-	f2fs_put_page(src_page, 1);
-
-	set_to_next_sit(sit_i, start);
-
-	return dst_page;
-}
-
-static struct sit_entry_set *grab_sit_entry_set(void)
-{
-	struct sit_entry_set *ses =
-			f2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_NOFS);
-
-	ses->entry_cnt = 0;
-	INIT_LIST_HEAD(&ses->set_list);
-	return ses;
-}
-
-static void release_sit_entry_set(struct sit_entry_set *ses)
-{
-	list_del(&ses->set_list);
-	kmem_cache_free(sit_entry_set_slab, ses);
-}
-
-static void adjust_sit_entry_set(struct sit_entry_set *ses,
-						struct list_head *head)
-{
-	struct sit_entry_set *next = ses;
-
-	if (list_is_last(&ses->set_list, head))
-		return;
-
-	list_for_each_entry_continue(next, head, set_list)
-		if (ses->entry_cnt <= next->entry_cnt)
-			break;
-
-	list_move_tail(&ses->set_list, &next->set_list);
-}
-
-static void add_sit_entry(unsigned int segno, struct list_head *head)
-{
-	struct sit_entry_set *ses;
-	unsigned int start_segno = START_SEGNO(segno);
-
-	list_for_each_entry(ses, head, set_list) {
-		if (ses->start_segno == start_segno) {
-			ses->entry_cnt++;
-			adjust_sit_entry_set(ses, head);
-			return;
-		}
-	}
-
-	ses = grab_sit_entry_set();
-
-	ses->start_segno = start_segno;
-	ses->entry_cnt++;
-	list_add(&ses->set_list, head);
-}
-
-static void add_sits_in_set(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_sm_info *sm_info = SM_I(sbi);
-	struct list_head *set_list = &sm_info->sit_entry_set;
-	unsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;
-	unsigned int segno;
-
-	for_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))
-		add_sit_entry(segno, set_list);
-}
-
-static void remove_sits_in_journal(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	int i;
-
-	down_write(&curseg->journal_rwsem);
-	for (i = 0; i < sits_in_cursum(journal); i++) {
-		unsigned int segno;
-		bool dirtied;
-
-		segno = le32_to_cpu(segno_in_journal(journal, i));
-		dirtied = __mark_sit_entry_dirty(sbi, segno);
-
-		if (!dirtied)
-			add_sit_entry(segno, &SM_I(sbi)->sit_entry_set);
-	}
-	update_sits_in_cursum(journal, -i);
-	up_write(&curseg->journal_rwsem);
-}
-
-/*
- * CP calls this function, which flushes SIT entries including sit_journal,
- * and moves prefree segs to free segs.
- */
-void flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned long *bitmap = sit_i->dirty_sentries_bitmap;
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	struct sit_entry_set *ses, *tmp;
-	struct list_head *head = &SM_I(sbi)->sit_entry_set;
-	bool to_journal = true;
-	struct seg_entry *se;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	if (!sit_i->dirty_sentries)
-		goto out;
-
-	/*
-	 * add and account sit entries of dirty bitmap in sit entry
-	 * set temporarily
-	 */
-	add_sits_in_set(sbi);
-
-	/*
-	 * if there are no enough space in journal to store dirty sit
-	 * entries, remove all entries from journal and add and account
-	 * them in sit entry set.
-	 */
-	if (!__has_cursum_space(journal, sit_i->dirty_sentries, SIT_JOURNAL))
-		remove_sits_in_journal(sbi);
-
-	/*
-	 * there are two steps to flush sit entries:
-	 * #1, flush sit entries to journal in current cold data summary block.
-	 * #2, flush sit entries to sit page.
-	 */
-	list_for_each_entry_safe(ses, tmp, head, set_list) {
-		struct page *page = NULL;
-		struct f2fs_sit_block *raw_sit = NULL;
-		unsigned int start_segno = ses->start_segno;
-		unsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,
-						(unsigned long)MAIN_SEGS(sbi));
-		unsigned int segno = start_segno;
-
-		if (to_journal &&
-			!__has_cursum_space(journal, ses->entry_cnt, SIT_JOURNAL))
-			to_journal = false;
-
-		if (to_journal) {
-			down_write(&curseg->journal_rwsem);
-		} else {
-			page = get_next_sit_page(sbi, start_segno);
-			raw_sit = page_address(page);
-		}
-
-		/* flush dirty sit entries in region of current sit set */
-		for_each_set_bit_from(segno, bitmap, end) {
-			int offset, sit_offset;
-
-			se = get_seg_entry(sbi, segno);
-
-			/* add discard candidates */
-			if (cpc->reason != CP_DISCARD) {
-				cpc->trim_start = segno;
-				add_discard_addrs(sbi, cpc);
-			}
-
-			if (to_journal) {
-				offset = lookup_journal_in_cursum(journal,
-							SIT_JOURNAL, segno, 1);
-				f2fs_bug_on(sbi, offset < 0);
-				segno_in_journal(journal, offset) =
-							cpu_to_le32(segno);
-				seg_info_to_raw_sit(se,
-					&sit_in_journal(journal, offset));
-			} else {
-				sit_offset = SIT_ENTRY_OFFSET(sit_i, segno);
-				seg_info_to_raw_sit(se,
-						&raw_sit->entries[sit_offset]);
-			}
-
-			__clear_bit(segno, bitmap);
-			sit_i->dirty_sentries--;
-			ses->entry_cnt--;
-		}
-
-		if (to_journal)
-			up_write(&curseg->journal_rwsem);
-		else
-			f2fs_put_page(page, 1);
-
-		f2fs_bug_on(sbi, ses->entry_cnt);
-		release_sit_entry_set(ses);
-	}
-
-	f2fs_bug_on(sbi, !list_empty(head));
-	f2fs_bug_on(sbi, sit_i->dirty_sentries);
-out:
-	if (cpc->reason == CP_DISCARD) {
-		for (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)
-			add_discard_addrs(sbi, cpc);
-	}
-	mutex_unlock(&sit_i->sentry_lock);
-
-	set_prefree_as_free_segments(sbi);
-}
-
-static int build_sit_info(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
-	struct sit_info *sit_i;
-	unsigned int sit_segs, start;
-	char *src_bitmap, *dst_bitmap;
-	unsigned int bitmap_size;
-
-	/* allocate memory for SIT information */
-	sit_i = kzalloc(sizeof(struct sit_info), GFP_KERNEL);
-	if (!sit_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->sit_info = sit_i;
-
-	sit_i->sentries = f2fs_kvzalloc(MAIN_SEGS(sbi) *
-					sizeof(struct seg_entry), GFP_KERNEL);
-	if (!sit_i->sentries)
-		return -ENOMEM;
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-	sit_i->dirty_sentries_bitmap = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-	if (!sit_i->dirty_sentries_bitmap)
-		return -ENOMEM;
-
-	for (start = 0; start < MAIN_SEGS(sbi); start++) {
-		sit_i->sentries[start].cur_valid_map
-			= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-		sit_i->sentries[start].ckpt_valid_map
-			= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-		if (!sit_i->sentries[start].cur_valid_map ||
-				!sit_i->sentries[start].ckpt_valid_map)
-			return -ENOMEM;
-
-		if (f2fs_discard_en(sbi)) {
-			sit_i->sentries[start].discard_map
-				= kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-			if (!sit_i->sentries[start].discard_map)
-				return -ENOMEM;
-		}
-	}
-
-	sit_i->tmp_map = kzalloc(SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);
-	if (!sit_i->tmp_map)
-		return -ENOMEM;
-
-	if (sbi->segs_per_sec > 1) {
-		sit_i->sec_entries = f2fs_kvzalloc(MAIN_SECS(sbi) *
-					sizeof(struct sec_entry), GFP_KERNEL);
-		if (!sit_i->sec_entries)
-			return -ENOMEM;
-	}
-
-	/* get information related with SIT */
-	sit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;
-
-	/* setup SIT bitmap from ckeckpoint pack */
-	bitmap_size = __bitmap_size(sbi, SIT_BITMAP);
-	src_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);
-
-	dst_bitmap = kmemdup(src_bitmap, bitmap_size, GFP_KERNEL);
-	if (!dst_bitmap)
-		return -ENOMEM;
-
-	/* init SIT information */
-	sit_i->s_ops = &default_salloc_ops;
-
-	sit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);
-	sit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;
-	sit_i->written_valid_blocks = 0;
-	sit_i->sit_bitmap = dst_bitmap;
-	sit_i->bitmap_size = bitmap_size;
-	sit_i->dirty_sentries = 0;
-	sit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;
-	sit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);
-	sit_i->mounted_time = CURRENT_TIME_SEC.tv_sec;
-	mutex_init(&sit_i->sentry_lock);
-	return 0;
-}
-
-static int build_free_segmap(struct f2fs_sb_info *sbi)
-{
-	struct free_segmap_info *free_i;
-	unsigned int bitmap_size, sec_bitmap_size;
-
-	/* allocate memory for free segmap information */
-	free_i = kzalloc(sizeof(struct free_segmap_info), GFP_KERNEL);
-	if (!free_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->free_info = free_i;
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-	free_i->free_segmap = f2fs_kvmalloc(bitmap_size, GFP_KERNEL);
-	if (!free_i->free_segmap)
-		return -ENOMEM;
-
-	sec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));
-	free_i->free_secmap = f2fs_kvmalloc(sec_bitmap_size, GFP_KERNEL);
-	if (!free_i->free_secmap)
-		return -ENOMEM;
-
-	/* set all segments as dirty temporarily */
-	memset(free_i->free_segmap, 0xff, bitmap_size);
-	memset(free_i->free_secmap, 0xff, sec_bitmap_size);
-
-	/* init free segmap information */
-	free_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));
-	free_i->free_segments = 0;
-	free_i->free_sections = 0;
-	spin_lock_init(&free_i->segmap_lock);
-	return 0;
-}
-
-static int build_curseg(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *array;
-	int i;
-
-	array = kcalloc(NR_CURSEG_TYPE, sizeof(*array), GFP_KERNEL);
-	if (!array)
-		return -ENOMEM;
-
-	SM_I(sbi)->curseg_array = array;
-
-	for (i = 0; i < NR_CURSEG_TYPE; i++) {
-		mutex_init(&array[i].curseg_mutex);
-		array[i].sum_blk = kzalloc(PAGE_SIZE, GFP_KERNEL);
-		if (!array[i].sum_blk)
-			return -ENOMEM;
-		init_rwsem(&array[i].journal_rwsem);
-		array[i].journal = kzalloc(sizeof(struct f2fs_journal),
-							GFP_KERNEL);
-		if (!array[i].journal)
-			return -ENOMEM;
-		array[i].segno = NULL_SEGNO;
-		array[i].next_blkoff = 0;
-	}
-	return restore_curseg_summaries(sbi);
-}
-
-static void build_sit_entries(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);
-	struct f2fs_journal *journal = curseg->journal;
-	struct seg_entry *se;
-	struct f2fs_sit_entry sit;
-	int sit_blk_cnt = SIT_BLK_CNT(sbi);
-	unsigned int i, start, end;
-	unsigned int readed, start_blk = 0;
-
-	do {
-		readed = ra_meta_pages(sbi, start_blk, BIO_MAX_PAGES,
-							META_SIT, true);
-
-		start = start_blk * sit_i->sents_per_block;
-		end = (start_blk + readed) * sit_i->sents_per_block;
-
-		for (; start < end && start < MAIN_SEGS(sbi); start++) {
-			struct f2fs_sit_block *sit_blk;
-			struct page *page;
-
-			se = &sit_i->sentries[start];
-			page = get_current_sit_page(sbi, start);
-			sit_blk = (struct f2fs_sit_block *)page_address(page);
-			sit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];
-			f2fs_put_page(page, 1);
-
-			check_block_count(sbi, start, &sit);
-			seg_info_from_raw_sit(se, &sit);
-
-			/* build discard map only one time */
-			if (f2fs_discard_en(sbi)) {
-				memcpy(se->discard_map, se->cur_valid_map,
-							SIT_VBLOCK_MAP_SIZE);
-				sbi->discard_blks += sbi->blocks_per_seg -
-							se->valid_blocks;
-			}
-
-			if (sbi->segs_per_sec > 1)
-				get_sec_entry(sbi, start)->valid_blocks +=
-							se->valid_blocks;
-		}
-		start_blk += readed;
-	} while (start_blk < sit_blk_cnt);
-
-	down_read(&curseg->journal_rwsem);
-	for (i = 0; i < sits_in_cursum(journal); i++) {
-		unsigned int old_valid_blocks;
-
-		start = le32_to_cpu(segno_in_journal(journal, i));
-		se = &sit_i->sentries[start];
-		sit = sit_in_journal(journal, i);
-
-		old_valid_blocks = se->valid_blocks;
-
-		check_block_count(sbi, start, &sit);
-		seg_info_from_raw_sit(se, &sit);
-
-		if (f2fs_discard_en(sbi)) {
-			memcpy(se->discard_map, se->cur_valid_map,
-						SIT_VBLOCK_MAP_SIZE);
-			sbi->discard_blks += old_valid_blocks -
-						se->valid_blocks;
-		}
-
-		if (sbi->segs_per_sec > 1)
-			get_sec_entry(sbi, start)->valid_blocks +=
-				se->valid_blocks - old_valid_blocks;
-	}
-	up_read(&curseg->journal_rwsem);
-}
-
-static void init_free_segmap(struct f2fs_sb_info *sbi)
-{
-	unsigned int start;
-	int type;
-
-	for (start = 0; start < MAIN_SEGS(sbi); start++) {
-		struct seg_entry *sentry = get_seg_entry(sbi, start);
-		if (!sentry->valid_blocks)
-			__set_free(sbi, start);
-		else
-			SIT_I(sbi)->written_valid_blocks +=
-						sentry->valid_blocks;
-	}
-
-	/* set use the current segments */
-	for (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {
-		struct curseg_info *curseg_t = CURSEG_I(sbi, type);
-		__set_test_and_inuse(sbi, curseg_t->segno);
-	}
-}
-
-static void init_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	struct free_segmap_info *free_i = FREE_I(sbi);
-	unsigned int segno = 0, offset = 0;
-	unsigned short valid_blocks;
-
-	while (1) {
-		/* find dirty segment based on free segmap */
-		segno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);
-		if (segno >= MAIN_SEGS(sbi))
-			break;
-		offset = segno + 1;
-		valid_blocks = get_valid_blocks(sbi, segno, 0);
-		if (valid_blocks == sbi->blocks_per_seg || !valid_blocks)
-			continue;
-		if (valid_blocks > sbi->blocks_per_seg) {
-			f2fs_bug_on(sbi, 1);
-			continue;
-		}
-		mutex_lock(&dirty_i->seglist_lock);
-		__locate_dirty_segment(sbi, segno, DIRTY);
-		mutex_unlock(&dirty_i->seglist_lock);
-	}
-}
-
-static int init_victim_secmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	unsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));
-
-	dirty_i->victim_secmap = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-	if (!dirty_i->victim_secmap)
-		return -ENOMEM;
-	return 0;
-}
-
-static int build_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i;
-	unsigned int bitmap_size, i;
-
-	/* allocate memory for dirty segments list information */
-	dirty_i = kzalloc(sizeof(struct dirty_seglist_info), GFP_KERNEL);
-	if (!dirty_i)
-		return -ENOMEM;
-
-	SM_I(sbi)->dirty_info = dirty_i;
-	mutex_init(&dirty_i->seglist_lock);
-
-	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));
-
-	for (i = 0; i < NR_DIRTY_TYPE; i++) {
-		dirty_i->dirty_segmap[i] = f2fs_kvzalloc(bitmap_size, GFP_KERNEL);
-		if (!dirty_i->dirty_segmap[i])
-			return -ENOMEM;
-	}
-
-	init_dirty_segmap(sbi);
-	return init_victim_secmap(sbi);
-}
-
-/*
- * Update min, max modified time for cost-benefit GC algorithm
- */
-static void init_min_max_mtime(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int segno;
-
-	mutex_lock(&sit_i->sentry_lock);
-
-	sit_i->min_mtime = LLONG_MAX;
-
-	for (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {
-		unsigned int i;
-		unsigned long long mtime = 0;
-
-		for (i = 0; i < sbi->segs_per_sec; i++)
-			mtime += get_seg_entry(sbi, segno + i)->mtime;
-
-		mtime = div_u64(mtime, sbi->segs_per_sec);
-
-		if (sit_i->min_mtime > mtime)
-			sit_i->min_mtime = mtime;
-	}
-	sit_i->max_mtime = get_mtime(sbi);
-	mutex_unlock(&sit_i->sentry_lock);
-}
-
-int build_segment_manager(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
-	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
-	struct f2fs_sm_info *sm_info;
-	int err;
-
-	sm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);
-	if (!sm_info)
-		return -ENOMEM;
-
-	/* init sm info */
-	sbi->sm_info = sm_info;
-	sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);
-	sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);
-	sm_info->segment_count = le32_to_cpu(raw_super->segment_count);
-	sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
-	sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
-	sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);
-	sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);
-	sm_info->rec_prefree_segments = sm_info->main_segments *
-					DEF_RECLAIM_PREFREE_SEGMENTS / 100;
-	if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)
-		sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;
-
-	if (!test_opt(sbi, LFS))
-		sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;
-	sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;
-	sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;
-
-	INIT_LIST_HEAD(&sm_info->discard_list);
-	sm_info->nr_discards = 0;
-	sm_info->max_discards = 0;
-
-	sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;
-
-	INIT_LIST_HEAD(&sm_info->sit_entry_set);
-
-	if (!f2fs_readonly(sbi->sb)) {
-		err = create_flush_cmd_control(sbi);
-		if (err)
-			return err;
-	}
-
-	err = build_sit_info(sbi);
-	if (err)
-		return err;
-	err = build_free_segmap(sbi);
-	if (err)
-		return err;
-	err = build_curseg(sbi);
-	if (err)
-		return err;
-
-	/* reinit free segmap based on SIT */
-	build_sit_entries(sbi);
-
-	init_free_segmap(sbi);
-	err = build_dirty_segmap(sbi);
-	if (err)
-		return err;
-
-	init_min_max_mtime(sbi);
-	return 0;
-}
-
-static void discard_dirty_segmap(struct f2fs_sb_info *sbi,
-		enum dirty_type dirty_type)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-
-	mutex_lock(&dirty_i->seglist_lock);
-	f2fs_kvfree(dirty_i->dirty_segmap[dirty_type]);
-	dirty_i->nr_dirty[dirty_type] = 0;
-	mutex_unlock(&dirty_i->seglist_lock);
-}
-
-static void destroy_victim_secmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	f2fs_kvfree(dirty_i->victim_secmap);
-}
-
-static void destroy_dirty_segmap(struct f2fs_sb_info *sbi)
-{
-	struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);
-	int i;
-
-	if (!dirty_i)
-		return;
-
-	/* discard pre-free/dirty segments list */
-	for (i = 0; i < NR_DIRTY_TYPE; i++)
-		discard_dirty_segmap(sbi, i);
-
-	destroy_victim_secmap(sbi);
-	SM_I(sbi)->dirty_info = NULL;
-	kfree(dirty_i);
-}
-
-static void destroy_curseg(struct f2fs_sb_info *sbi)
-{
-	struct curseg_info *array = SM_I(sbi)->curseg_array;
-	int i;
-
-	if (!array)
-		return;
-	SM_I(sbi)->curseg_array = NULL;
-	for (i = 0; i < NR_CURSEG_TYPE; i++) {
-		kfree(array[i].sum_blk);
-		kfree(array[i].journal);
-	}
-	kfree(array);
-}
-
-static void destroy_free_segmap(struct f2fs_sb_info *sbi)
-{
-	struct free_segmap_info *free_i = SM_I(sbi)->free_info;
-	if (!free_i)
-		return;
-	SM_I(sbi)->free_info = NULL;
-	f2fs_kvfree(free_i->free_segmap);
-	f2fs_kvfree(free_i->free_secmap);
-	kfree(free_i);
-}
-
-static void destroy_sit_info(struct f2fs_sb_info *sbi)
-{
-	struct sit_info *sit_i = SIT_I(sbi);
-	unsigned int start;
-
-	if (!sit_i)
-		return;
-
-	if (sit_i->sentries) {
-		for (start = 0; start < MAIN_SEGS(sbi); start++) {
-			kfree(sit_i->sentries[start].cur_valid_map);
-			kfree(sit_i->sentries[start].ckpt_valid_map);
-			kfree(sit_i->sentries[start].discard_map);
-		}
-	}
-	kfree(sit_i->tmp_map);
-
-	f2fs_kvfree(sit_i->sentries);
-	f2fs_kvfree(sit_i->sec_entries);
-	f2fs_kvfree(sit_i->dirty_sentries_bitmap);
-
-	SM_I(sbi)->sit_info = NULL;
-	kfree(sit_i->sit_bitmap);
-	kfree(sit_i);
-}
-
-void destroy_segment_manager(struct f2fs_sb_info *sbi)
-{
-	struct f2fs_sm_info *sm_info = SM_I(sbi);
-
-	if (!sm_info)
-		return;
-	destroy_flush_cmd_control(sbi, true);
-	destroy_dirty_segmap(sbi);
-	destroy_curseg(sbi);
-	destroy_free_segmap(sbi);
-	destroy_sit_info(sbi);
-	sbi->sm_info = NULL;
-	kfree(sm_info);
-}
-
-int __init create_segment_manager_caches(void)
-{
-	discard_entry_slab = f2fs_kmem_cache_create("discard_entry",
-			sizeof(struct discard_entry));
-	if (!discard_entry_slab)
-		goto fail;
-
-	sit_entry_set_slab = f2fs_kmem_cache_create("sit_entry_set",
-			sizeof(struct sit_entry_set));
-	if (!sit_entry_set_slab)
-		goto destory_discard_entry;
-
-	inmem_entry_slab = f2fs_kmem_cache_create("inmem_page_entry",
-			sizeof(struct inmem_pages));
-	if (!inmem_entry_slab)
-		goto destroy_sit_entry_set;
-	return 0;
-
-destroy_sit_entry_set:
-	kmem_cache_destroy(sit_entry_set_slab);
-destory_discard_entry:
-	kmem_cache_destroy(discard_entry_slab);
-fail:
-	return -ENOMEM;
-}
-
-void destroy_segment_manager_caches(void)
-{
-	kmem_cache_destroy(sit_entry_set_slab);
-	kmem_cache_destroy(discard_entry_slab);
-	kmem_cache_destroy(inmem_entry_slab);
-}
diff --git a/fs/f2fs/segment.o_shipped b/fs/f2fs/segment.o_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..686cb0ec9c495882ffa9de902ac7654895bc0f49
GIT binary patch
literal 47584
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

literal 0
HcmV?d00001

-- 
2.17.1

